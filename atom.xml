<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>温故而知新</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.greateman.top/"/>
  <updated>2018-09-06T01:53:31.000Z</updated>
  <id>https://www.greateman.top/</id>
  
  <author>
    <name>肖悦</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>【Git】忽略规则及不生效解决办法</title>
    <link href="https://www.greateman.top/%E3%80%90Git%E3%80%91%E5%BF%BD%E7%95%A5%E8%A7%84%E5%88%99%E5%8F%8A%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95.html"/>
    <id>https://www.greateman.top/【Git】忽略规则及不生效解决办法.html</id>
    <published>2018-09-06T01:53:31.000Z</published>
    <updated>2018-09-06T01:53:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>简单的规则记录</p><a id="more"></a><h1 id="Git忽略规则"><a href="#Git忽略规则" class="headerlink" title="Git忽略规则"></a>Git忽略规则</h1><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改根目录中 .gitignore 文件的方法（如果没有这个文件，则需自己手工建立此文件）。这个文件每一行保存了一个匹配的规则例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">\#此为注释 – 将被 Git 忽略</span><br><span class="line"></span><br><span class="line">*.sample            #忽略所有 .sample 结尾的文件</span><br><span class="line"></span><br><span class="line">!lib.sample         #但 lib.sample 除外</span><br><span class="line"></span><br><span class="line">/TODO               #仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO</span><br><span class="line"></span><br><span class="line">build/              #忽略 build/ 目录下的所有文件</span><br><span class="line"></span><br><span class="line">doc/*.txt           #会忽略 doc/notes.txt 但不包括 doc/server/arch.txt</span><br></pre></td></tr></table></figure><h1 id="gitignore规则不生效的解决办法"><a href="#gitignore规则不生效的解决办法" class="headerlink" title=".gitignore规则不生效的解决办法"></a>.gitignore规则不生效的解决办法</h1><p>把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被追踪的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未被追踪状态），然后再提交：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m 'update .gitignore'</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简单的规则记录&lt;/p&gt;
    
    </summary>
    
      <category term="版本控制" scheme="https://www.greateman.top/categories/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/"/>
    
    
      <category term="git" scheme="https://www.greateman.top/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Centos7关闭firewall防火墙，改用iptables</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91Centos7%E5%85%B3%E9%97%ADfirewall%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%8C%E6%94%B9%E7%94%A8iptables.html"/>
    <id>https://www.greateman.top/【Linux】Centos7关闭firewall防火墙，改用iptables.html</id>
    <published>2018-08-31T01:37:31.000Z</published>
    <updated>2018-08-31T01:37:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>关闭firewall防火墙，改用iptables<br><a id="more"></a></p><h2 id="1、关闭默认的firewall"><a href="#1、关闭默认的firewall" class="headerlink" title="1、关闭默认的firewall"></a>1、关闭默认的firewall</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld.service    #停止firewall</span><br><span class="line">systemctl disable firewalld.service #禁止firewall开机启动</span><br><span class="line">firewall-<span class="built_in">cmd</span> --state    #查看默认防火墙状态（关闭后显示notrunning，开启后显示running）</span><br></pre></td></tr></table></figure><h2 id="2、开启iptables"><a href="#2、开启iptables" class="headerlink" title="2、开启iptables"></a>2、开启iptables</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum install iptables    #（根据centOS7的版本和内核，有些版本已经装过，可以跳过此命令）</span><br><span class="line">yum install iptables-services</span><br><span class="line">service iptables restart</span><br><span class="line">chkconfig iptables on 或者 systemctl enable iptables.service开机自启&lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="3、编辑防火墙文件"><a href="#3、编辑防火墙文件" class="headerlink" title="3、编辑防火墙文件"></a>3、编辑防火墙文件</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/sysconfig/iptables</span><br></pre></td></tr></table></figure><p>开启21,22,80,3306端口</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style="font-size:<span class="number">18</span>px;"&gt;# sampleconfiguration <span class="keyword">for</span> iptables service </span><br><span class="line"># # you can edit thismanually or use system-config-firewall </span><br><span class="line"># # please <span class="keyword">do</span> <span class="keyword">not</span> askus to add additional ports/services to this default configuration </span><br><span class="line">*filter </span><br><span class="line">:INPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>] </span><br><span class="line">:FORWARD ACCEPT [<span class="number">0</span>:<span class="number">0</span>] </span><br><span class="line">:OUTPUT ACCEPT [<span class="number">0</span>:<span class="number">0</span>] </span><br><span class="line">-A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT </span><br><span class="line">-A INPUT -p icmp -j ACCEPT </span><br><span class="line">-A INPUT -i lo -j ACCEPT </span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">21</span> -j ACCEPT </span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">22</span> -j ACCEPT </span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">80</span> -j ACCEPT </span><br><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport <span class="number">3306</span> -j ACCEPT </span><br><span class="line">-A INPUT -j REJECT --reject-with icmp-host-prohibited </span><br><span class="line">-A FORWARD -j REJECT --reject-with icmp-host-prohibited </span><br><span class="line">COMMIT &lt;/span&gt;</span><br></pre></td></tr></table></figure><h2 id="4、查看iptables"><a href="#4、查看iptables" class="headerlink" title="4、查看iptables"></a>4、查看iptables</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;关闭firewall防火墙，改用iptables&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】更新yum源 改成阿里云源</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91%E6%9B%B4%E6%96%B0yum%E6%BA%90-%E6%94%B9%E6%88%90%E9%98%BF%E9%87%8C%E4%BA%91%E6%BA%90.html"/>
    <id>https://www.greateman.top/【Linux】更新yum源-改成阿里云源.html</id>
    <published>2018-08-31T01:36:30.000Z</published>
    <updated>2018-08-31T01:36:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>更新yum源 改成阿里云源</p><a id="more"></a><h2 id="1、备份"><a href="#1、备份" class="headerlink" title="1、备份"></a>1、备份</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup</span><br></pre></td></tr></table></figure><h2 id="2、更换源"><a href="#2、更换源" class="headerlink" title="2、更换源"></a>2、更换源</h2><ul><li><p>Centos5</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">5</span>.repo</span><br></pre></td></tr></table></figure><p> 或者</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">5</span>.repo</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>CentOS 6</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">6</span>.repo</span><br></pre></td></tr></table></figure><p> 或者</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">6</span>.repo</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>CentOS 7</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">7</span>.repo</span><br></pre></td></tr></table></figure><p> 或者</p> <figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="number">7</span>.repo</span><br></pre></td></tr></table></figure></li></ul><h2 id="3、清理并生成缓存"><a href="#3、清理并生成缓存" class="headerlink" title="3、清理并生成缓存"></a>3、清理并生成缓存</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br></pre></td></tr></table></figure><h2 id="4、yum基本语法"><a href="#4、yum基本语法" class="headerlink" title="4、yum基本语法"></a>4、yum基本语法</h2><h3 id="4-1-语法"><a href="#4-1-语法" class="headerlink" title="4.1 语法"></a>4.1 语法</h3><p>yum [options] [command] [package …]<br>参数：<br>options：可选，包括-h（帮助），-y（安装过程中提示全部选yes），-q（不显示安装过程）<br>command：要进行的操作<br>package：操作的对象</p><h3 id="4-2-常用命令"><a href="#4-2-常用命令" class="headerlink" title="4.2 常用命令"></a>4.2 常用命令</h3><p>1）列出所有可更新的软件清单命令：yum check-update<br>2）更新所有软件命令：yum update<br>3）仅安装指定的软件命令：yum install <package_name><br>4）仅更新指定的软件命令：yum update <package_name><br>5）列出所有可安裝的软件清单命令：yum list，list后面可以接各种参数，详情请man yum<br>6）删除软件包命令：yum remove <package_name><br>7）查找软件包 命令：yum search <keyword><br>8）清除缓存命令:</keyword></package_name></package_name></package_name></p><pre><code>yum clean packages: 清除缓存目录下的软件包yum clean headers: 清除缓存目录下的 headersyum clean oldheaders: 清除缓存目录下旧的 headersyum clean, yum clean all (= yum clean packages; yum clean oldheaders):清除缓存目录下的软件包及旧的headers</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;更新yum源 改成阿里云源&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Solr7】数据导入</title>
    <link href="https://www.greateman.top/%E3%80%90Solr7%E3%80%91%E6%95%B0%E6%8D%AE%E5%AF%BC%E5%85%A5.html"/>
    <id>https://www.greateman.top/【Solr7】数据导入.html</id>
    <published>2018-08-30T11:18:54.000Z</published>
    <updated>2018-08-30T11:18:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>solr本身可以实现数据的导入功能，同时其提供jar还能整合如java、python等语言来导入。本文针对solr本身的数据导入功能。<br><a id="more"></a></p><h2 id="1、导入jar到lib下"><a href="#1、导入jar到lib下" class="headerlink" title="1、导入jar到lib下"></a>1、导入jar到lib下</h2><p>solr-7.2.1\dist\solr-dataimporthandler-7.2.1.jar和mysql-connector-java-5.1.35.jar两个jar包放入<br>solr-7.2.1\server\solr-webapp\webapp\WEB-INF\lib下。</p><h2 id="2、新建数据查询文档"><a href="#2、新建数据查询文档" class="headerlink" title="2、新建数据查询文档"></a>2、新建数据查询文档</h2><p>在solr_home/core/conf目录下，新建data_config.xml并编写代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">dataConfig</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"JdbcDataSource"</span> <span class="attr">driver</span>=<span class="string">"com.mysql.jdbc.Driver"</span> <span class="attr">url</span>=<span class="string">"jdbc:mysql://localhost:3306/taotao?characterEncoding=utf-8&amp;amp;useSSL=false"</span> <span class="attr">user</span>=<span class="string">"root"</span> <span class="attr">password</span>=<span class="string">"123456"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">document</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entity</span> <span class="attr">name</span>=<span class="string">"tb_item"</span> </span></span><br><span class="line"><span class="tag">        <span class="attr">query</span>=<span class="string">"SELECT A.*, B.item_desc,c.NAME FROM tb_item A INNER JOIN tb_item_desc B ON A.id = B.item_id INNER JOIN tb_item_cat C ON A.cid = C.id"</span> </span></span><br><span class="line">        &lt;!--增量更新，dataimporter是此文件同目录下导入数据后生成的文件--&gt;</span><br><span class="line">            deltaImportQuery="SELECT A.*, B.item_desc,c.NAME FROM tb_item A INNER JOIN tb_item_desc B ON A.id = B.item_id INNER JOIN tb_item_cat C ON A.cid = C.id where A.updated &gt; '$&#123;dataimporter.tb_item.last_index_time&#125;'"&gt;</span><br><span class="line">            <span class="comment">&lt;!--column是数据库字段，name是solr中的field--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">name</span>=<span class="string">"id"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"title"</span> <span class="attr">name</span>=<span class="string">"item_title"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"sell_point"</span> <span class="attr">name</span>=<span class="string">"item_sell_point"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"price"</span> <span class="attr">name</span>=<span class="string">"item_price"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"image"</span> <span class="attr">name</span>=<span class="string">"item_image"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"name"</span> <span class="attr">name</span>=<span class="string">"item_category_name"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">field</span> <span class="attr">column</span>=<span class="string">"item_desc"</span> <span class="attr">name</span>=<span class="string">"item_desc"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entity</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">document</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataConfig</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3、添加field"><a href="#3、添加field" class="headerlink" title="3、添加field"></a>3、添加field</h2><p>solr_home/core/conf目录下的managed-schema文件中，添加上述字段</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"id"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">required</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_title"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_sell_point"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_price"</span>  <span class="attr">type</span>=<span class="string">"plong"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_image"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"false"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_category_name"</span> <span class="attr">type</span>=<span class="string">"string"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"item_desc"</span> <span class="attr">type</span>=<span class="string">"text_ik"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"false"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4、添加requestHandler"><a href="#4、添加requestHandler" class="headerlink" title="4、添加requestHandler"></a>4、添加requestHandler</h2><p>在solr_home/core/conf/solrconfig.xml文件中的requestHandler标签前面加上如下代码</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">requestHandler</span> <span class="attr">name</span>=<span class="string">"/dataimport"</span> <span class="attr">class</span>=<span class="string">"org.apache.solr.handler.dataimport.DataImportHandler"</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;<span class="name">lst</span> <span class="attr">name</span>=<span class="string">"defaults"</span>&gt;</span> </span><br><span class="line">      <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">"config"</span>&gt;</span>data_config.xml<span class="tag">&lt;/<span class="name">str</span>&gt;</span> </span><br><span class="line">   <span class="tag">&lt;/<span class="name">lst</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">requestHandler</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="5、浏览器中完成导入"><a href="#5、浏览器中完成导入" class="headerlink" title="5、浏览器中完成导入"></a>5、浏览器中完成导入</h2><p>在浏览器打开solr,在DataImport中执行导入，左侧绿色字体为导入状态（可点击Refesh Status按钮刷新），如图：</p><p><img src="https://img-blog.csdn.net/20180306105138315?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDM3ODE4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="数据导入"></p><h2 id="6、查询"><a href="#6、查询" class="headerlink" title="6、查询"></a>6、查询</h2><p>在Query中查看导入结果，如图：</p><p><img src="https://img-blog.csdn.net/20180306105403462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDM3ODE4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="此处输入图片的描述"></p><h2 id="7、疑问"><a href="#7、疑问" class="headerlink" title="7、疑问"></a>7、疑问</h2><p>在第二歩中的增量查询，使用了时间比较，一个时间是数据库的timestamp(服务器时间),另一个是solr更新时间。<br>但是solr使用的是UTC时间，比我们少8个小时。</p><p>解决方案参考：<a href="https://www.jianshu.com/p/8f65ffbd5c74" target="_blank" rel="noopener">彻底解决Solr日期类型的时区问题</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;solr本身可以实现数据的导入功能，同时其提供jar还能整合如java、python等语言来导入。本文针对solr本身的数据导入功能。&lt;br&gt;
    
    </summary>
    
      <category term="全文搜索" scheme="https://www.greateman.top/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="Solr" scheme="https://www.greateman.top/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>【Solr7】安装及部署</title>
    <link href="https://www.greateman.top/%E3%80%90Solr7%E3%80%91%E5%AE%89%E8%A3%85%E5%8F%8A%E9%83%A8%E7%BD%B2.html"/>
    <id>https://www.greateman.top/【Solr7】安装及部署.html</id>
    <published>2018-08-30T05:54:31.000Z</published>
    <updated>2018-08-30T05:54:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>本博客使用的版本为 <strong>7.2.1</strong>。有关Solr的详细介绍及使用，参见<a href="https://www.w3cschool.cn/solr_doc/solr_doc-t3642fkr.html" target="_blank" rel="noopener">Solr中国官方文档</a>。<br><a id="more"></a></p><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><p>Solr 是Apache下的一个顶级开源项目，采用Java开发，它是基于Lucene的全文搜索服务。<br>solr可以实现全文检索功能（索引、搜索），solr是可以独立运行在tomcat等web容器中。<br>Solr不提供构建UI的功能，Solr提供了一个管理界面，通过管理界面可以查询Solr的配置和运行情况。<br>Solr主要对外提供索引和搜索服务。<br>下面是一个如何将 Solr 集成到应用程序中的示例：<br><img src="https://7n.w3cschool.cn/attachments/image/20171103/1509691910631328.png" alt="此处输入图片的描述"></p><h2 id="2、系统要求"><a href="#2、系统要求" class="headerlink" title="2、系统要求"></a>2、系统要求</h2><p>您可以在任何系统中安装 Solr，但是这些系统中必须有适用的 Java 运行时环境（JRE），具体介绍如下文所述。</p><p>目前，这包括 Linux，MacOS / OS X 和 Microsoft Windows。</p><p>Java 要求<br>您将需要 1.8 或更高版本的 Java 运行时环境（JRE）。在命令行中，检查您的 Java 版本，如下所示：</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java -version</span><br><span class="line">java version "<span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_60"</span><br><span class="line">Java(TM) SE Runtime Environment (build <span class="number">1</span>.<span class="number">8</span>.<span class="number">0</span>_60-b27)</span><br><span class="line">Java HotSpot(TM) <span class="number">64</span>-Bit Server VM (build <span class="number">25</span>.<span class="number">60</span>-b23, mixed <span class="built_in">mode</span>)</span><br></pre></td></tr></table></figure><h2 id="3、下载安装"><a href="#3、下载安装" class="headerlink" title="3、下载安装"></a>3、下载安装</h2><p>Solr 可从 Solr 网站获取。您可以在此下载最新版本的 Solr：<a href="https://lucene.apache.org/solr/mirrors-solr-latest-redir.html。" target="_blank" rel="noopener">https://lucene.apache.org/solr/mirrors-solr-latest-redir.html。</a></p><p>Solr 有三个独立的软件包：</p><ul><li>solr-7.0.0.tgz：适用于 Linux / Unix / OSX 系统</li><li>solr-7.0.0.zip：适用于 Microsoft Windows 系统</li><li>solr-7.0.0-src.tgz：Solr 源代码包。如果您想在 Solr 上开发而不使用官方的 Git 存储库，这将非常有用。</li></ul><p>下载解压 Solr 之后，您将会看到以下的目录和文件：<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/solr/fileSystem.png" alt="解压目录"></p><ul><li><p>bin </p><p> 此目录中包含几个重要的脚本，这些脚本将使使用 Solr 更容易。</p><p> solr 和 solr.cmd<br> 这是Solr 的控制脚本，也称为bin/solr（对于 * nix）或者bin/solr.cmd（对于 Windows）。这个脚本是启动和停止 Solr 的首选工具。您也可以在运行 SolrCloud 模式时创建集合或内核、配置身份验证以及配置文件。</p><p> post<br> Post Tool，它提供了用于发布内容到 Solr 的一个简单的命令行界面。</p><p> solr.in.sh 和 solr.in.cmd<br> 这些分别是为 * nix 和 Windows 系统提供的属性文件。在这里配置了 Java、Jetty 和 Solr 的系统级属性。许多这些设置可以在使用bin/solr或者bin/solr.cmd时被覆盖，但这允许您在一个地方设置所有的属性。</p><p> install_solr_services.sh<br> 该脚本用于 * nix 系统以安装 Solr 作为服务。在 “将Solr用于生产 ” 一节中有更详细的描述。</p></li><li><p>contrib<br> Solr 的contrib目录包含 Solr 专用功能的附加插件。 </p></li><li><p>dist<br> 该dist目录包含主要的 Solr .jar 文件。</p></li><li><p>docs<br> 该docs目录包括一个链接到在线 Javadocs 的 Solr。</p></li><li><p>example<br> 该example目录包括演示各种 Solr 功能的几种类型的示例。有关此目录中的内容的详细信息，请参阅下面的 Solr 示例。</p></li><li><p>licenses<br> 该licenses目录包括 Solr 使用的第三方库的所有许可证。</p></li><li><p>server<br> 此目录是 Solr 应用程序的核心所在。此目录中的 README 提供了详细的概述，但以下是一些特点：</p><p> Solr 的 Admin UI（server/solr-webapp）<br> Jetty 库（server/lib）<br> 日志文件（server/logs）和日志配置（server/resources）。有关如何自定义 Solr 的默认日志记录的详细信息，请参阅配置日志记录一节。<br> 示例配置（server/solr/configsets）</p></li></ul><h2 id="4、运行"><a href="#4、运行" class="headerlink" title="4、运行"></a>4、运行</h2><p>Solr的运行分为单机运行和集群运行，这里以单机为例：</p><ol><li>在bin目录下执行bin/solr start     </li></ol><p>此命令会启动solr应用服务器默认端口为8983，如果想指定端口号启动可以加参数–p例 如：solr start –p 8888.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">D:\Modules\Solr\solr-7.2.1\bin&gt;solr.cmd start</span><br><span class="line">Waiting up to 30 to see Solr running on port 8983</span><br><span class="line">Started Solr server on port 8983. Happy searching!</span><br></pre></td></tr></table></figure></p><p>如图这句提示出现后证明服务启动成功(启动过程中如果打印java异常堆栈log4j2.xml 文件名、目录名或卷标语法不正确。没有关系不妨碍我们正常使用solr可以忽略此问题)，接下来在浏览器输入<a href="http://localhost:8983/solr可以进入Admin" target="_blank" rel="noopener">http://localhost:8983/solr可以进入Admin</a> UI界面验证是否启动成功。</p><p>2.常用命令</p><pre><code>solr start –p 端口号 单机版启动solr服务solr restart –p 端口号 重启solr服务solr stop –p 端口号关闭solr服务solr create –c name 创建一个core实例(core概念后面介绍)</code></pre><h2 id="5、创建core实例"><a href="#5、创建core实例" class="headerlink" title="5、创建core实例"></a>5、创建core实例</h2><p>core简介：<br>简单说core就是solr的一个实例，一个solr服务下可以有多个core，每个core下都有自己的索引库和与之相应的配置文件，所以在操作solr创建索引之前要创建一个core，因为索引都存在core下面。</p><p> core创建：<br> core的创建方式有很多种一下列出两种比较方便的。</p><ol><li>在bin目录下执行solr create –c name，创建一个core<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/solr/createCore.png" alt="此处输入图片的描述"></li><li>手动创建文件夹，在solr admin管理页面添加<br>在solr home即solr-x.x.x/server/solr下，创建一个文件夹，名字为core的名字<br>复制同路径下的 configsets下任意文件夹下的conf目录到刚创建的core目录中<br>在管理页面，添加core,对应更改</li></ol><h2 id="6、添加中文分词器"><a href="#6、添加中文分词器" class="headerlink" title="6、添加中文分词器"></a>6、添加中文分词器</h2><p>中文分词器有很多种，使用最多的是IK分词器，solr自带一个中文分词器，但没有IK好用。</p><p><a href="http://search.maven.org/#search%7Cga%7C1%7Ccom.github.magese" target="_blank" rel="noopener">solr7版本的ik分词器下载地址</a><br><a href="https://github.com/magese/ik-analyzer-solr7" target="_blank" rel="noopener">solr7版本的ik分词器作者的GitHUb</a></p><p>详细配置过程参见 上述github库说明。</p><h2 id="7、参考"><a href="#7、参考" class="headerlink" title="7、参考"></a>7、参考</h2><p><a href="https://blog.csdn.net/u011052863?t=1" target="_blank" rel="noopener">solr7.3 环境搭建 配置中文分词器 ik-analyzer-solr7 详细步骤</a><br><a href="https://www.cnblogs.com/mengjinluohua/p/8439546.html" target="_blank" rel="noopener">Solr7.2.1环境搭建和配置ik中文分词器</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本博客使用的版本为 &lt;strong&gt;7.2.1&lt;/strong&gt;。有关Solr的详细介绍及使用，参见&lt;a href=&quot;https://www.w3cschool.cn/solr_doc/solr_doc-t3642fkr.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Solr中国官方文档&lt;/a&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="全文搜索" scheme="https://www.greateman.top/categories/%E5%85%A8%E6%96%87%E6%90%9C%E7%B4%A2/"/>
    
    
      <category term="Solr" scheme="https://www.greateman.top/tags/Solr/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】CentOS7下搭建Redis集群详细过程</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html"/>
    <id>https://www.greateman.top/【Linux】CentOS7下搭建Redis集群详细过程.html</id>
    <published>2018-07-24T00:35:19.000Z</published>
    <updated>2018-07-24T00:35:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>Redis-cluster集群方案从redis3.0版本开始支持，本文仅做基本的集群搭建介绍。</p><a id="more"></a><h2 id="1、下载编译Reids"><a href="#1、下载编译Reids" class="headerlink" title="1、下载编译Reids"></a>1、下载编译Reids</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//创建安装包文件夹</span><br><span class="line">mkdir /usr/local/packages</span><br><span class="line">//创建redis安装目录</span><br><span class="line">mkdir /usr/local/redis</span><br><span class="line"></span><br><span class="line">//下载安装包</span><br><span class="line">cd /usr/local/packages</span><br><span class="line">wget http://download.redis.io/releases/redis-4.0.1.tar.gz</span><br><span class="line"></span><br><span class="line">//解压到安装目录</span><br><span class="line">tar -zxvf redis-4.0.1.tar.gz -C /usr/local/redis</span><br><span class="line"></span><br><span class="line">//编译</span><br><span class="line">cd /usr/local/redis/redis-4.0.1</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><p>注意：在执行make的是时候确保包含了编译所需的工具包。阿里云Centos7.0 编译没有问题直接通过</p><p>安装成功后，在/usr/local/redis/redis-4.0.1/src目录下会有编译后的文件，并且在/usr/local/bin目录下生成redis有关的指令文件。</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/Linux/makeRedis.png" alt="此处输入图片的描述"></p><h2 id="2、节点规划"><a href="#2、节点规划" class="headerlink" title="2、节点规划"></a>2、节点规划</h2><p>规划创建6个redis实例，3主3从，简单起见，均在同一机器上，规划端口为6380 ~ 6385。</p><p>在 /usr/local  下创建/redis/redis-cluster文件夹，并在其中创建6380-6385 6个文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# mkdir 6380</span><br><span class="line">[root@localhost redis-cluster]# mkdir 6381</span><br><span class="line">[root@localhost redis-cluster]# mkdir 6382</span><br><span class="line">[root@localhost redis-cluster]# mkdir 6383</span><br><span class="line">[root@localhost redis-cluster]# mkdir 6384</span><br><span class="line">[root@localhost redis-cluster]# mkdir 6385</span><br></pre></td></tr></table></figure><h2 id="3、配置修改"><a href="#3、配置修改" class="headerlink" title="3、配置修改"></a>3、配置修改</h2><p>拷贝一份配置文件到当前目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# cp ../redis-4.0.1/redis.conf ./</span><br></pre></td></tr></table></figure><p>修改属性，cope6份分别放在6个文件夹中，注意更改端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">port 6380   //端口</span><br><span class="line">daemonize yes   //后台启动模式</span><br><span class="line">pidfile /var/run/redis-6380pid //开启daemonize需要配置</span><br><span class="line">cluster-enabled yes     //cluster模式</span><br><span class="line">cluster-config-file nodes-6380.conf     //日志文件名</span><br><span class="line">cluster-node-timeout 5000   //请求超时时间，5s</span><br><span class="line">appendonly  yes     //aof日志开启  有需要就开启，它会每次写操作都记录一条日志</span><br><span class="line"></span><br><span class="line">bind 192.168.86.130 //服务器ip</span><br></pre></td></tr></table></figure><h2 id="4、启动redis"><a href="#4、启动redis" class="headerlink" title="4、启动redis"></a>4、启动redis</h2><p>简便起见，创建集群启动脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]#vim start-all.sh</span><br></pre></td></tr></table></figure><p>输入一下内容并保存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6380/redis.conf</span><br><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6381/redis.conf</span><br><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6382/redis.conf</span><br><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6383/redis.conf</span><br><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6384/redis.conf</span><br><span class="line">redis-server /usr/local/redis/redis-cluster/redis-6385/redis.conf</span><br></pre></td></tr></table></figure><p>赋予该脚本可执行权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x start-all.sh</span><br></pre></td></tr></table></figure><p>同样，创建集群关闭脚本，并赋予相同权限，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]#vim stop-all.sh</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.86.130 -p 6380 shutdown</span><br><span class="line">redis-cli -h 192.168.86.130 -p 6381 shutdown</span><br><span class="line">redis-cli -h 192.168.86.130 -p 6382 shutdown</span><br><span class="line">redis-cli -h 192.168.86.130 -p 6383 shutdown</span><br><span class="line">redis-cli -h 192.168.86.130 -p 6384 shutdown</span><br><span class="line">redis-cli -h 192.168.86.130 -p 6385 shutdown</span><br></pre></td></tr></table></figure><p>启动redis,执行启动脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./start-all.sh</span><br></pre></td></tr></table></figure><p>查看redis启动情况：</p><pre><code>[root@localhost redis-cluster]# ps -ef | grep redisroot       3241      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6380 [cluster]root       3243      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6381 [cluster]root       3248      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6382 [cluster]root       3256      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6383 [cluster]root       3261      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6384 [cluster]root       3266      1  0 02:33 ?        00:00:00 redis-server 192.168.86.130:6385 [cluster]root       3271   2600  0 02:33 pts/0    00:00:00 grep --color=auto redis</code></pre><h2 id="5、Ruby环境"><a href="#5、Ruby环境" class="headerlink" title="5、Ruby环境"></a>5、Ruby环境</h2><p>redis集群管理工具redis-trib.rb依赖ruby环境，首先需要安装ruby环境。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install ruby</span><br><span class="line">yum install rubygems</span><br></pre></td></tr></table></figure><p>拷贝redis-3.0.0.gem至/usr/local下<br>执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gem install /usr/local/redis</span><br></pre></td></tr></table></figure><p>若报如下错误，则是ruby版本过低,需要安装一个高于2.2.2版本的ruby。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR:  Error installing redis:</span><br><span class="line">        redis requires Ruby version &gt;= 2.2.2.</span><br></pre></td></tr></table></figure><p>具体过程参考：</p><h2 id="6、启动集群"><a href="#6、启动集群" class="headerlink" title="6、启动集群"></a>6、启动集群</h2><p>拷贝redis-trib.rb到 redis目录下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp /usr/local/redis/redis-4.0.1/src/redis-trib.rb /usr/local/redis/redis-cluster</span><br></pre></td></tr></table></figure><p>进入redis-cluster目录下，执行集群脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./redis-trib.rb create --replicas 1 192.168.86.130:6380 192.168.86.130:6381 192.168.86.130:6382 192.168.86.130:6383 192.168.86.130:6384  192.168.86.130:6385</span><br></pre></td></tr></table></figure><p>简单解释一下这个命令：调用 ruby 命令来进行创建集群，<code>--replicas 1</code> 表示主从复制比例为 1:1，即一个主节点对应一个从节点；然后，默认给我们分配好了每个主节点和对应从节点服务，以及 solt 的大小，因为在 Redis 集群中有且仅有 16383 个 solt ，默认情况会给我们平均分配，当然你可以指定，后续的增减节点也可以重新分配。<br>随便找一个节点测试试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost redis-cluster]# redis-cli -h 192.168.86.130 -p 6382 -c</span><br><span class="line">192.168.86.130:6382&gt; set b 100</span><br><span class="line">-&gt; Redirected to slot [3300] located at 192.168.86.130:6380</span><br><span class="line">OK</span><br><span class="line">192.168.86.130:6380&gt;</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/zr520/p/5056972.html" target="_blank" rel="noopener">配置文件说明</a><br><a href="https://blog.csdn.net/hjm4702192/article/details/80518922" target="_blank" rel="noopener">redis详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Redis-cluster集群方案从redis3.0版本开始支持，本文仅做基本的集群搭建介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】CentOS7下安装Tomcat详细过程</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85Tomcat%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html"/>
    <id>https://www.greateman.top/【Linux】CentOS7下安装Tomcat详细过程.html</id>
    <published>2018-07-24T00:34:48.000Z</published>
    <updated>2018-07-24T00:34:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>安装步骤概述.<br><a id="more"></a></p><h2 id="1、安装-JDK"><a href="#1、安装-JDK" class="headerlink" title="1、安装 JDK"></a>1、安装 JDK</h2><p>具体步骤见  <a href="https://www.zybuluo.com/MrXiao/note/1219090" target="_blank" rel="noopener">【Linux】CentOS7下安装JDK详细过程</a></p><h2 id="2、安装-Tomcat"><a href="#2、安装-Tomcat" class="headerlink" title="2、安装 Tomcat"></a>2、安装 Tomcat</h2><h3 id="2-1-下载Tomcat"><a href="#2-1-下载Tomcat" class="headerlink" title="2.1 下载Tomcat"></a>2.1 下载Tomcat</h3><p>官方下载地址：<a href="https://tomcat.apache.org/download-90.cgi" target="_blank" rel="noopener">tomcat9官方下载地址</a></p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/Linux/dowlondTomcat.png" alt="tomcat9"></p><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.10/bin/apache-tomcat-9.0.10.tar.gz</span><br></pre></td></tr></table></figure><p>或者windows下载后，上传到Linux服务器</p><h3 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h3><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-tomcat-9.0.10.tar.gz</span><br></pre></td></tr></table></figure><h2 id="3、执行"><a href="#3、执行" class="headerlink" title="3、执行"></a>3、执行</h2><ol><li>进入bin目录 cd /usr/java/tomcat9/bin</li><li><p>启动 ./startup.sh</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost bin]# ./startup.sh </span><br><span class="line">Using CATALINA_BASE:   /usr/java/tomcat9</span><br><span class="line">Using CATALINA_HOME:   /usr/java/tomcat9</span><br><span class="line">Using CATALINA_TMPDIR: /usr/java/tomcat9/temp</span><br><span class="line">Using JRE_HOME:        /usr/java/jdk1.8.0_181/jre</span><br><span class="line">Using CLASSPATH:       /usr/java/tomcat9/bin/bootstrap.jar:/usr/java/tomcat9/bin/tomcat-juli.jar</span><br><span class="line">Tomcat started.</span><br></pre></td></tr></table></figure></li><li><p>访问服务器ip地址  服务器ip:8080</p></li></ol><h2 id="4、tomcat启动后外网无法访问"><a href="#4、tomcat启动后外网无法访问" class="headerlink" title="4、tomcat启动后外网无法访问"></a>4、tomcat启动后外网无法访问</h2><p>iptables防火墙设置参考文章地址：<br><a href="https://blog.csdn.net/u010071211/article/details/79244404" target="_blank" rel="noopener">CentOS7.4 关闭firewall防火墙，改用iptables</a><br><a href="https://blog.csdn.net/l1028386804/article/details/50779761" target="_blank" rel="noopener">CentOS之——CentOS7安装iptables防火墙</a></p><ol><li><p>查看防火墙状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables status</span><br></pre></td></tr></table></figure></li><li><p>添加8080端口允许外网访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT</span><br></pre></td></tr></table></figure></li><li><p>保存规则设定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables save</span><br></pre></td></tr></table></figure></li><li><p>重启防火墙</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service iptables restart</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;安装步骤概述.&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】CentOS7下安装JDK详细过程</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85JDK%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html"/>
    <id>https://www.greateman.top/【Linux】CentOS7下安装JDK详细过程.html</id>
    <published>2018-07-24T00:34:31.000Z</published>
    <updated>2018-07-24T00:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>Linux上一般会安装Open JDK,关于OpenJDK和JDK的区别：<a href="http://www.cnblogs.com/sxdcgaq8080/p/7487369.html" target="_blank" rel="noopener">【JDK和Open JDK】平常使用的JDK和Open JDK有什么区别</a>。</p><a id="more"></a><h2 id="1、卸载系统自带的OpenJDK以及相关的java文件"><a href="#1、卸载系统自带的OpenJDK以及相关的java文件" class="headerlink" title="1、卸载系统自带的OpenJDK以及相关的java文件"></a>1、卸载系统自带的OpenJDK以及相关的java文件</h2><h3 id="1-1-在命令窗口键入："><a href="#1-1-在命令窗口键入：" class="headerlink" title="1.1 在命令窗口键入："></a>1.1 在命令窗口键入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/978388/201709/978388-20170907223117179-1206697422.png" alt="java -version"></p><p>可以看到系统自带的OpenJDK版本信息。</p><h3 id="1-2-在命令窗口键入："><a href="#1-2-在命令窗口键入：" class="headerlink" title="1.2 在命令窗口键入："></a>1.2 在命令窗口键入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa | grep java</span><br></pre></td></tr></table></figure><pre><code>命令说明：rpm 　　管理套件    -qa 　　使用询问模式，查询所有套件grep　　查找文件里符合条件的字符串java 　　查找包含java字符串的文件</code></pre><p><img src="https://images2017.cnblogs.com/blog/978388/201709/978388-20170907223341444-542280232.png" alt="此处输入图片的描述"></p><p>以上文件中：下面这几个可以删除</p><pre><code>java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</code></pre><p>以下文件可以不用删除</p><pre><code>python-javapackages-3.4.1-11.el7.noarchtzdata-java-2016g-2.el7.noarchjavapackages-tools-3.4.1-11.el7.noarch</code></pre><h3 id="1-3-在命令窗口键入："><a href="#1-3-在命令窗口键入：" class="headerlink" title="1.3 在命令窗口键入："></a>1.3 在命令窗口键入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su</span><br></pre></td></tr></table></figure><p>输入密码，进入超级用户角色</p><h3 id="1-4-在命令窗口键入："><a href="#1-4-在命令窗口键入：" class="headerlink" title="1.4 在命令窗口键入："></a>1.4 在命令窗口键入：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64</span><br><span class="line">rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64</span><br></pre></td></tr></table></figure><pre><code>命令介绍：rpm 　　　　管理套件  -e　　　　　删除指定的套件--nodeps　　不验证套件档的相互关联性</code></pre><h3 id="1-5-检查是否已经删除成功"><a href="#1-5-检查是否已经删除成功" class="headerlink" title="1.5  检查是否已经删除成功"></a>1.5  检查是否已经删除成功</h3><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p><img src="https://images2017.cnblogs.com/blog/978388/201709/978388-20170907230232522-1003727369.png" alt="此处输入图片的描述"></p><p>代表已经删除成功了。</p><h2 id="2、安装-Sun-JDK"><a href="#2、安装-Sun-JDK" class="headerlink" title="2、安装 Sun JDK"></a>2、安装 Sun JDK</h2><p><strong>【注意】:JDK安装在哪个用户下，就是给哪个用户使用</strong></p><h3 id="2-1-下载"><a href="#2-1-下载" class="headerlink" title="2.1 下载"></a>2.1 下载</h3><p>当前最新版本下载地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>历史版本下载地址：　　<a href="http://www.oracle.com/technetwork/java/javase/archive-139210.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/archive-139210.html</a>　　</p><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz?AuthParam=1531986242_deb391e0a43953c12051f2d1eae8afad</span><br></pre></td></tr></table></figure><p>或者windows下载后，使用xftp工具上传到Linux服务器。</p><h3 id="2-2-解压"><a href="#2-2-解压" class="headerlink" title="2.2 解压"></a>2.2 解压</h3><p>将jdk-8u181-linux-x64.tar.gz文件拷贝一份到/usr/java</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp jdk-8u181-linux-x64.tar.gz /usr/java</span><br></pre></td></tr></table></figure><p>进入 /usr/java 目录，解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/java</span><br><span class="line">tar -zxvf jdk-8u181-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="2-3-配置环境变量"><a href="#2-3-配置环境变量" class="headerlink" title="2.3 配置环境变量"></a>2.3 配置环境变量</h3><p>使用vim /etc/profile 编辑profile文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profil</span><br></pre></td></tr></table></figure><p>向文件里面追加以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#set java environment</span><br><span class="line">JAVA_HOME=/usr/java/jdk1.8.0_181</span><br><span class="line">JRE_HOME=$JAVA_HOME/jre</span><br><span class="line">PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br><span class="line">CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br></pre></td></tr></table></figure><pre><code>注释：JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径，此路径下包括lib，bin，jre等文件夹（tomcat，Eclipse的运行都需要依靠此变量）。CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设：.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib。CLASSPATH变量值中的.表示当前目录PATH使得系统可以在任何路径下识别java命令，设为：$JAVA_HOME/bin:$JRE_HOME/bin。特别注意：环境变量值的结尾没有任何符号，不同值之间用:隔开（windows中用;）。</code></pre><h3 id="2-4-使配置文件生效"><a href="#2-4-使配置文件生效" class="headerlink" title="2.4 使配置文件生效"></a>2.4 使配置文件生效</h3><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="2-5-测试配置是否成功"><a href="#2-5-测试配置是否成功" class="headerlink" title="2.5 测试配置是否成功"></a>2.5 测试配置是否成功</h3><p>在命令窗口键入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>如下显示，则配置成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost java]# java -version</span><br><span class="line">java version &quot;1.8.0_181&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_181-b13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Linux上一般会安装Open JDK,关于OpenJDK和JDK的区别：&lt;a href=&quot;http://www.cnblogs.com/sxdcgaq8080/p/7487369.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;【JDK和Open JDK】平常使用的JDK和Open JDK有什么区别&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>【Blog】hexo博客关联域名，部署到coding</title>
    <link href="https://www.greateman.top/%E3%80%90Blog%E3%80%91hexo%E5%8D%9A%E5%AE%A2%E5%85%B3%E8%81%94%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%83%A8%E7%BD%B2%E5%88%B0coding.html"/>
    <id>https://www.greateman.top/【Blog】hexo博客关联域名，部署到coding.html</id>
    <published>2018-07-16T10:13:14.000Z</published>
    <updated>2018-11-30T08:13:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>使用了一段时间在github上搭建的hexo个人博客空间，使用markdown写博客既方便，展示出来的样式也还算满意，唯一的缺点就是域名 github.io 总觉得有点累赘，另外就是访问速度比较慢，今天就试着来解决这两个：把访问域名替换成自己的域名,访问站点指向国内的coding.net</p><a id="more"></a><h2 id="1、购买一个私人域名"><a href="#1、购买一个私人域名" class="headerlink" title="1、购买一个私人域名"></a>1、购买一个私人域名</h2><p><a href="https://wanwang.aliyun.com/?spm=5176.8709316.1146454.770.eb3d5f29ozu1GL" target="_blank" rel="noopener">阿里云域名推荐引擎</a>，根据自己的需求购买一个专属域名，以本人域名为例：greateman.top</p><h2 id="2、Coding上建库"><a href="#2、Coding上建库" class="headerlink" title="2、Coding上建库"></a>2、Coding上建库</h2><h3 id="2-1-注册Coding-net账号"><a href="#2-1-注册Coding-net账号" class="headerlink" title="2.1 注册Coding.net账号"></a>2.1 注册Coding.net账号</h3><p>打开<a href="https://coding.net/" target="_blank" rel="noopener">Coding.net官网</a>，注册一个个人账号</p><h3 id="2-2-新建项目"><a href="#2-2-新建项目" class="headerlink" title="2.2 新建项目"></a>2.2 新建项目</h3><p>注意项目名与注册用的账户名一致，这里我用的是 kevinXiao2016<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/createCodingReposity.png" alt="此处输入图片的描述"></p><h3 id="2-3-添加公钥"><a href="#2-3-添加公钥" class="headerlink" title="2.3 添加公钥"></a>2.3 添加公钥</h3><p>上面设置完毕之后点击创建项目，然后点击设置-&gt;部署公钥-&gt;新建部署公钥，之前部署到Github上的时候，本地目录 C\User(中文为用户)(电脑用户名).ssh 目录下会有 github.rsa.pub 公钥文件，打开然后复制里面的内容，直接贴在这里的公钥框中：<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/gongyao.png" alt="此处输入图片的描述"></p><pre><code>记得要勾选 授予推送权限 ，否则在后面运行hexo d时会提示错误：Coding.net Tips : [Deploy key is not allowed to push!]fatal: Could not read from remote repository.原因就是没有推送权限。</code></pre><p>打开Git命令窗口Git Bash，输入一下指令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@git.coding.NET</span><br></pre></td></tr></table></figure><p>假如出现以下输出结果，表示公钥绑定成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">xy@xy-PC MINGW64 ~</span><br><span class="line">$ ssh -T git@git.coding.NET</span><br><span class="line">Coding 提示: Hello kevinXiao2016, You&apos;ve connected to Coding.net via SSH. This is a deploy key.</span><br><span class="line">kevinXiao2016，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个部署公钥</span><br></pre></td></tr></table></figure><h3 id="2-4-解析域名"><a href="#2-4-解析域名" class="headerlink" title="2.4 解析域名"></a>2.4 解析域名</h3><p>登陆阿里云</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/jiexi.png" alt="此处输入图片的描述"></p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/addjiexi.png" alt="此处输入图片的描述"></p><h3 id="2-5-绑定个人域名"><a href="#2-5-绑定个人域名" class="headerlink" title="2.5 绑定个人域名"></a>2.5 绑定个人域名</h3><p>点击设置-&gt;Pages服务，绑定自己购买的域名。</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/specialDomain.png" alt="此处输入图片的描述"></p><h2 id="3、修改hexo配置"><a href="#3、修改hexo配置" class="headerlink" title="3、修改hexo配置"></a>3、修改hexo配置</h2><h3 id="3-1-关联coding仓库"><a href="#3-1-关联coding仓库" class="headerlink" title="3.1 关联coding仓库"></a>3.1 关联coding仓库</h3><p>打开hexo本地的配置文件 _config.yml，修改 deploy 的配置内容，这里设置了运行hexo d之后部署的目的地址，原本只有Github地址，现在添加多Coding.net的地址，其中kevinXiao2016是注册该平台的 用户名：</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/deployRepository.png" alt="此处输入图片的描述"></p><h3 id="3-2-创建Statifile"><a href="#3-2-创建Statifile" class="headerlink" title="3.2 创建Statifile"></a>3.2 创建Statifile</h3><p>在source目录下新建一个文件，命名为Statifile，不带文件后缀。</p><h3 id="3-3-部署博客"><a href="#3-3-部署博客" class="headerlink" title="3.3 部署博客"></a>3.3 部署博客</h3><p>打开命令行窗口，定位到当前hexo项目的根目录下，运行以下指令将本地博客部署到Github和Coding.net上：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d -g</span><br></pre></td></tr></table></figure><p>假如提交成功，在命令行会输出：</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/blog/deployResult.png" alt="此处输入图片的描述"></p><h2 id="4、访问"><a href="#4、访问" class="headerlink" title="4、访问"></a>4、访问</h2><p>一切准备完毕，此时便可以通过域名访问博客啦。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用了一段时间在github上搭建的hexo个人博客空间，使用markdown写博客既方便，展示出来的样式也还算满意，唯一的缺点就是域名 github.io 总觉得有点累赘，另外就是访问速度比较慢，今天就试着来解决这两个：把访问域名替换成自己的域名,访问站点指向国内的coding.net&lt;/p&gt;
    
    </summary>
    
      <category term="Blog" scheme="https://www.greateman.top/categories/Blog/"/>
    
    
      <category term="Blog" scheme="https://www.greateman.top/tags/Blog/"/>
    
  </entry>
  
  <entry>
    <title>【Linux】Centos7下安装Nginx</title>
    <link href="https://www.greateman.top/%E3%80%90Linux%E3%80%91Centos7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx.html"/>
    <id>https://www.greateman.top/【Linux】Centos7下安装Nginx.html</id>
    <published>2018-06-13T05:03:57.000Z</published>
    <updated>2018-06-13T05:03:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。</p><a id="more"></a><h2 id="1、配置环境"><a href="#1、配置环境" class="headerlink" title="1、配置环境"></a>1、配置环境</h2><p>Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。</p><ol><li><p>gcc 安装<br>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y gcc-c++</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>PCRE pcre-devel 安装<br>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure></li><li><p>zlib 安装<br>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure></li><li><p>OpenSSL 安装<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure></li></ol><h2 id="2、安装Nginx"><a href="#2、安装Nginx" class="headerlink" title="2、安装Nginx"></a>2、安装Nginx</h2><ol><li><p>下载.tar.gz</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c https://nginx.org/download/nginx-1.14.0.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.14.0.tar.gz </span><br><span class="line">cd nginx-1.14.0</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>配置</p><p>3.1 使用默认配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./configure</span><br></pre></td></tr></table></figure></li></ol><pre><code>3.2 自定义配置（推荐）    ./configure \    --prefix=/usr/local/nginx \    --conf-path=/usr/local/nginx/conf/nginx.conf \    --pid-path=/usr/local/nginx/conf/nginx.pid \    --lock-path=/var/lock/nginx.lock \    --error-log-path=/var/log/nginx/error.log \    --http-log-path=/var/log/nginx/access.log \    --with-http_gzip_static_module \    --http-client-body-temp-path=/var/temp/nginx/client \    --http-proxy-temp-path=/var/temp/nginx/proxy \    --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \    --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \    --http-scgi-temp-path=/var/temp/nginx/scgi&lt;font color=&quot;red&quot;&gt;注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录&lt;/font&gt;<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /var/temp/nginx</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>编译安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--编译--&gt;</span><br><span class="line">make</span><br><span class="line">&lt;!--安装--&gt;</span><br><span class="line">make install</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>开启pid-path</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--进入安装目录--&gt;</span><br><span class="line">cd /usr/local/nginx</span><br><span class="line"></span><br><span class="line">&lt;!--编辑nginx.conf--&gt;</span><br><span class="line">vi conf/nginx.conf</span><br><span class="line"></span><br><span class="line">&lt;!--开启pid，并设值--&gt;</span><br><span class="line">pid /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line">&lt;!--创建目录--&gt;</span><br><span class="line">mkdir /usr/local/nginx/logs</span><br></pre></td></tr></table></figure></li></ol><h2 id="3、启动Nginx"><a href="#3、启动Nginx" class="headerlink" title="3、启动Nginx"></a>3、启动Nginx</h2><ol><li><p>启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/nginx/nginx_start.png" alt="此处输入图片的描述"></p></li><li><p>停止</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s stop</span><br></pre></td></tr></table></figure></li></ol><pre><code>推荐下面这条命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s quit</span><br></pre></td></tr></table></figure></code></pre><ol><li><p>重启</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -s reload</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>配置文件位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -t</span><br></pre></td></tr></table></figure></li></ol><h2 id="4、开机启动"><a href="#4、开机启动" class="headerlink" title="4、开机启动"></a>4、开机启动</h2><p>参照这篇文章：<a href="https://blog.csdn.net/qq_36441027/article/details/80636526" target="_blank" rel="noopener">CentOS7+Nginx设置Systemctl restart nginx.service服务</a></p><pre><code>启动nginx服务systemctl start nginx.service　设置开机自启动systemctl enable nginx.service停止开机自启动systemctl disable nginx.service查看服务当前状态systemctl status nginx.service重新启动服务systemctl restart nginx.service　查看所有已启动的服务systemctl list-units --type=service</code></pre><h2 id="5、问题汇总"><a href="#5、问题汇总" class="headerlink" title="5、问题汇总"></a>5、问题汇总</h2><ol><li><p>window无法访问虚拟机的nginx服务</p><p>首先确认windows是否能ping通linux，确认可以的情况下，很有可能是linux的防火墙开启且屏蔽了80端口。参照 <a href="https://greateman.top/%E3%80%90Linux%E3%80%91Centos7%E5%85%B3%E9%97%ADfirewall%E9%98%B2%E7%81%AB%E5%A2%99%EF%BC%8C%E6%94%B9%E7%94%A8iptables.html" target="_blank" rel="noopener">CentOS7.4 关闭firewall防火墙，改用iptables</a> 这篇文章设置，改用iptables，并放开80端口。</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://www.greateman.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://www.greateman.top/tags/Linux/"/>
    
      <category term="Nginx" scheme="https://www.greateman.top/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>IDEA永久破解</title>
    <link href="https://www.greateman.top/IDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3.html"/>
    <id>https://www.greateman.top/IDEA永久破解.html</id>
    <published>2018-06-08T02:17:16.000Z</published>
    <updated>2018-06-08T02:17:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>此方法永久破解，有效期到2099年12月31日。</p><a id="more"></a><ol><li><p>从 <a href="http://idea.lanyus.com/" target="_blank" rel="noopener">http://idea.lanyus.com/</a> 下载最新的破解补丁。</p><p>类似这个链接：<a href="http://idea.lanyus.com/jar/JetbrainsCrack-2.8-release-enc.jar" target="_blank" rel="noopener">http://idea.lanyus.com/jar/JetbrainsCrack-2.8-release-enc.jar</a> </p></li><li><p>将下载好的jar文件，拷贝到idea安装目录的bin目录下</p></li><li>添加启动参数： -javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2017.3.2\bin\JetbrainsCrack-2.6.10-release-enc.jar</li><li><p>启动idea，填写acrivation code</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ThisCrackLicenseId-&#123; </span><br><span class="line">“licenseId”:”ThisCrackLicenseId”, </span><br><span class="line">“licenseeName”:”授权用户名”, </span><br><span class="line">“assigneeName”:”“, </span><br><span class="line">“assigneeEmail”:”签名邮箱@163.com”, </span><br><span class="line">“licenseRestriction”:”For This Crack, Only Test! Please support genuine!!!”, </span><br><span class="line">“checkConcurrentUse”:false, </span><br><span class="line">“products”:[ </span><br><span class="line">&#123;“code”:”II”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”DM”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”AC”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”RS0”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”WS”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”DPN”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”RC”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”PS”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”DC”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”RM”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”CL”,”paidUpTo”:”2099-12-31”&#125;, </span><br><span class="line">&#123;“code”:”PC”,”paidUpTo”:”2099-12-31”&#125; </span><br><span class="line">], </span><br><span class="line">“hash”:”2911276/0”, </span><br><span class="line">“gracePeriodDays”:7, </span><br><span class="line">“autoProlongated”:false&#125;</span><br></pre></td></tr></table></figure></li></ol><p>参考：<a href="https://blog.csdn.net/everest_man/article/details/78985879" target="_blank" rel="noopener">IntelliJ IDEA 2017.3.2永久破解版</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;此方法永久破解，有效期到2099年12月31日。&lt;/p&gt;
    
    </summary>
    
      <category term="乱七八糟" scheme="https://www.greateman.top/categories/%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F/"/>
    
    
      <category term="idea" scheme="https://www.greateman.top/tags/idea/"/>
    
  </entry>
  
  <entry>
    <title>Quartz学习</title>
    <link href="https://www.greateman.top/Quartz%E5%AD%A6%E4%B9%A0.html"/>
    <id>https://www.greateman.top/Quartz学习.html</id>
    <published>2018-05-24T11:39:48.000Z</published>
    <updated>2018-05-24T11:39:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>Quartz是一个开源的作业调度框架，可以让计划的任务在一个预先设计好的日期和时间运行。Quartz可以用来创建简单或复杂的日程安排执行几十，几百，甚至是十万的作业数，支持集群。</p><a id="more"></a><h2 id="1、核心类简介"><a href="#1、核心类简介" class="headerlink" title="1、核心类简介"></a>1、核心类简介</h2><p><strong>调度器</strong>：Scheduler </p><p>quartz的核心大脑，调度中心，包含两个重要的组件：JobStore、ThreadPool</p><p>JobStore:存储器，用来存储运行时的信息，包括Trigger、JobDetail、Schduler、业务锁等，有以下几种实现：</p><ol><li>RAMJob（内存实现）</li><li>JobStoreTX(JDBC实现，事务由quartz管理)</li><li>JobStoreCMT(JDBC实现，事务由容器管理)</li><li>ClusteredJobStore(集群实现)</li><li>TerracottaJobStore(什么是Terractta)</li></ol><p><strong>任务</strong>：JobDetail &amp; Job</p><p>JobDetail是任务的定义，而Job是任务的执行逻辑。在JobDetail里会引用一个Job Class定义，还有一个JobDetailMap存储结构。</p><p>Job是具体的任务执行逻辑，JobDetailMap是同一个JobDetail实例化的Job共享的存储器。</p><p><strong>触发器</strong>：Trigger</p><p>定义Job何时执行，理解为定时触发，有以下几种实现：</p><ol><li>SimpleTrigger:指定从某一个时间开始，以一定的时间间隔（单位是毫秒）执行的任务。</li><li>CalendarIntervalTrigger:类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务。 但是不同的是SimpleTrigger指定的时间间隔为毫秒，没办法指定每隔一个月执行一次（每月的时间间隔不是固定值），而CalendarIntervalTrigger支持的间隔单位有秒，分钟，小时，天，月，年，星期。</li><li>DailyTimeIntervalTrigger:指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。</li><li>CronTrigger:适合于更复杂的任务，它支持类型于Linux Cron的语法（并且更强大）。基本上它覆盖了以上三个Trigger的绝大部分能力（但不是全部）—— 当然，也更难理解。</li></ol><h2 id="2、RAMJob方式的简单应用"><a href="#2、RAMJob方式的简单应用" class="headerlink" title="2、RAMJob方式的简单应用"></a>2、RAMJob方式的简单应用</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.topvision.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.JobDetail;</span><br><span class="line"><span class="keyword">import</span> org.quartz.Scheduler;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SchedulerException;</span><br><span class="line"><span class="keyword">import</span> org.quartz.SimpleTrigger;</span><br><span class="line"><span class="keyword">import</span> org.quartz.impl.StdSchedulerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.JobBuilder.newJob;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.SimpleScheduleBuilder.simpleSchedule;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.quartz.TriggerBuilder.newTrigger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcStoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(JdbcStoreTest.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> SchedulerException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*创建调度器*/</span></span><br><span class="line">        Scheduler scheduler = <span class="keyword">new</span> StdSchedulerFactory(<span class="string">"quartz.properties"</span>).getScheduler();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">/*创建JobDetail*/</span></span><br><span class="line">        JobDetail jobDetail = newJob(MyJob.class).withIdentity(<span class="string">"jobkey1"</span>, <span class="string">"jobgroup"</span>).build();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*创建触发器*/</span></span><br><span class="line">        SimpleTrigger trigger = newTrigger().withIdentity(<span class="string">"trikey2"</span>, <span class="string">"trigroup"</span>)</span><br><span class="line">                .startNow()</span><br><span class="line">                .withSchedule(simpleSchedule().withIntervalInSeconds(<span class="number">3</span>).withRepeatCount(<span class="number">3</span>))</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*绑定*/</span></span><br><span class="line">        scheduler.scheduleJob(jobDetail, trigger);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*开启*/</span></span><br><span class="line">        scheduler.start();</span><br><span class="line">        logger.info(<span class="string">"启动时间："</span> + <span class="keyword">new</span> Date());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">6</span>*<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        scheduler.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.topvision.quartz;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.quartz.Job;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionContext;</span><br><span class="line"><span class="keyword">import</span> org.quartz.JobExecutionException;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyJob</span> <span class="keyword">implements</span> <span class="title">Job</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(MyJob.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(JobExecutionContext jobExecutionContext)</span> <span class="keyword">throws</span> JobExecutionException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"MyJob  is start .................."</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Hello quzrtz  "</span> +</span><br><span class="line">                <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss "</span>).format(<span class="keyword">new</span> Date()));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"MyJob  is end ....................."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="详细用法参考"><a href="#详细用法参考" class="headerlink" title="详细用法参考"></a>详细用法参考</h2><ol><li><a href="https://blog.csdn.net/u010648555/article/details/54863144" target="_blank" rel="noopener">Quartz学习——Quartz大致介绍——阿飞(dufyun)的博客</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Quartz是一个开源的作业调度框架，可以让计划的任务在一个预先设计好的日期和时间运行。Quartz可以用来创建简单或复杂的日程安排执行几十，几百，甚至是十万的作业数，支持集群。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://www.greateman.top/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="quartz" scheme="https://www.greateman.top/tags/quartz/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://www.greateman.top/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.greateman.top/单例模式.html</id>
    <published>2018-05-10T03:24:45.000Z</published>
    <updated>2018-05-10T03:24:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqrmA4Qiac4QWjgUAXuZPQgsLxNf7CiaP7kJfNTwG2Ok1ShdbAoQibEJXdPoPmicuAiaXFSic4nSZL6VxPw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="此处输入图片的描述"></p><a id="more"></a><h2 id="1、懒汉式"><a href="#1、懒汉式" class="headerlink" title="1、懒汉式"></a>1、懒汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo1 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo1 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Demo1();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、饿汉式"><a href="#2、饿汉式" class="headerlink" title="2、饿汉式"></a>2、饿汉式</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Demo2 instance = <span class="keyword">new</span> Demo2();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo2 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：</p><ol><li>要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Demo1的构造方法是私有的</li><li>instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。</li><li>getInstance是获取单例对象的方法。</li></ol><p>如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。</p><p>如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。</p><h2 id="3、双重验证"><a href="#3、双重验证" class="headerlink" title="3、双重验证"></a>3、双重验证</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Demo3 instance = <span class="keyword">null</span>; <span class="comment">// volatile 禁止了指令重排</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Demo3 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Demo3.class) &#123; <span class="comment">// 同步锁</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Demo3();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为什么这样写呢？我们来解释几个关键点：</p><ol><li>为了防止new Demo3被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。</li><li>进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。</li><li>volatile 禁止了指令重排</li></ol><h2 id="4、静态内部内"><a href="#4、静态内部内" class="headerlink" title="4、静态内部内"></a>4、静态内部内</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo4</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LazyHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Demo4 INSTANCE = <span class="keyword">new</span> Demo4();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Demo4 <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.demo4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有几个需要注意的点：</p><ol><li>从外部无法访问静态内部类LazyHolder，只有当调用Demo4.getInstance方法的时候，才能得到单例对象INSTANCE。</li><li>INSTANCE对象初始化的时机并不是在单例类Demo4被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。</li><li>可能被反射打破单例的约束</li></ol><h2 id="5、枚举"><a href="#5、枚举" class="headerlink" title="5、枚举"></a>5、枚举</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Demo5 &#123;</span><br><span class="line">    demo5;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Demo5</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> Object();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。</p><p>对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGqrmA4Qiac4QWjgUAXuZPQgsLxNf7CiaP7kJfNTwG2Ok1ShdbAoQibEJXdPoPmicuAiaXFSic4nSZL6VxPw/640?wx_fmt=png&amp;amp;tp=webp&amp;amp;wxfrom=5&amp;amp;wx_lazy=1&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.greateman.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.greateman.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>volatile的实现原理</title>
    <link href="https://www.greateman.top/volatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>https://www.greateman.top/volatile的实现原理.html</id>
    <published>2018-05-04T08:27:21.000Z</published>
    <updated>2018-05-04T08:27:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、特性"><a href="#1、特性" class="headerlink" title="1、特性"></a>1、特性</h2><ol><li>保证变量在线程之间的可见性</li><li>通过内存屏障来阻止指令重排，是happens-before规范的具体的一种实现</li><li>解决了long类型和double类型数据的8字节赋值问题</li></ol><a id="more"></a><h2 id="2、可见性"><a href="#2、可见性" class="headerlink" title="2、可见性"></a>2、可见性</h2><p>JMM(Java Memeory Model)是JVM定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异。</p><p><img src="http://mmbiz.qpic.cn/mmbiz_png/NtO5sialJZGricHmm50IzXNiaAMroheficIiaoP0yvpTjvtYXECkp5GNib77GCbu7s5ticlhJ7wP6icxHRbgVLmhKj1vAg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" alt="此处输入图片的描述"></p><ul><li>主内存：简单理解为计算机当中的内存，但并不完全等同。被所有线程共享，存储着共享变量的“本尊”。</li><li>工作内存：简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。</li></ul><p>线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。</p><p>当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。<br>当然，synchronize和锁都可以保证可见性。</p><h2 id="3、有序性"><a href="#3、有序性" class="headerlink" title="3、有序性"></a>3、有序性</h2><p>在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。</p><p>Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。</p><p><strong>happen-before</strong></p><ol><li>同一个线程中的，前面的操作happen-before后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。</li><li>监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）</li><li>对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）</li><li>线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）</li><li>线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。</li><li>如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。</li></ol><p>重点关注第3条，使用volatile修饰的变量，在指令重排时，会产生额外的lock前缀指令，也就是内存屏障。</p><p><img src="http://images2015.cnblogs.com/blog/381060/201702/381060-20170208174537963-1251333114.jpg" alt="此处输入图片的描述"></p><h2 id="4、局限性及使用场景"><a href="#4、局限性及使用场景" class="headerlink" title="4、局限性及使用场景"></a>4、局限性及使用场景</h2><ul><li>局限性<br> 不能保证原子性</li><li>场景<br> 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值<br> 不参与多个volatile变量的不变约束。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.cnblogs.com/chenssy/p/6379280.html" target="_blank" rel="noopener">【死磕Java并发】—–深入分析volatile的实现原理</a></li><li><a href="https://mp.weixin.qq.com/s/DZkGRTan2qSzJoDAx7QJag" target="_blank" rel="noopener">漫画：什么是volatile关键字？（整合版）</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1、特性&quot;&gt;&lt;a href=&quot;#1、特性&quot; class=&quot;headerlink&quot; title=&quot;1、特性&quot;&gt;&lt;/a&gt;1、特性&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;保证变量在线程之间的可见性&lt;/li&gt;
&lt;li&gt;通过内存屏障来阻止指令重排，是happens-before规范的具体的一种实现&lt;/li&gt;
&lt;li&gt;解决了long类型和double类型数据的8字节赋值问题&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="并发" scheme="https://www.greateman.top/categories/%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java" scheme="https://www.greateman.top/tags/Java/"/>
    
      <category term="并发" scheme="https://www.greateman.top/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>代理模式</title>
    <link href="https://www.greateman.top/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html"/>
    <id>https://www.greateman.top/代理模式.html</id>
    <published>2018-04-25T06:03:07.000Z</published>
    <updated>2018-07-27T00:48:19.222Z</updated>
    
    <content type="html"><![CDATA[<p>Java本身给我们提供了静态代理和动态代理两种代理方式，spring提供了基于类的代理方式：cglib.</p><p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。<br>在代理模式中，我们创建<strong>具有现有对象的对象</strong>，以便向外界提供功能接口。</p><a id="more"></a><h2 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h2><p><strong>意图</strong>：为其他对象提供一种代理，从而控制对这个对象的访问。</p><p><strong>主要解决</strong>：在直接访问对象时带来的问题。</p><p><strong>关键代码</strong>：实现与被代理类的组合。</p><p><strong>优点</strong>： </p><ol><li>职责清晰，高扩展性，智能化。 </li><li>建立一套触发机制。</li></ol><p><strong>缺点</strong>：</p><ol><li>增加了代理对象，某些情况下会造成请求的处理速度变慢</li><li>需要额外的编码，某些情况实现很复杂</li></ol><p><strong>注意事项</strong></p><ol><li>与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>与装饰着模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ol><h2 id="2、静态代理"><a href="#2、静态代理" class="headerlink" title="2、静态代理"></a>2、静态代理</h2><p>静态代理：代理类在程序运行前就已存在，即人为的编写代理类代码。代理类与委托类实现同一接口或派生自相同的父类。</p><p>以下是静态代理的简单实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseImpl</span> <span class="keyword">implements</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"welcome to my house!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyHouse</span> <span class="keyword">implements</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> House house;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyHouse</span><span class="params">(House house)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.house = house;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm proxy"</span>);</span><br><span class="line">        house.sayHi();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    House h = <span class="keyword">new</span> HouseImpl();</span><br><span class="line">    h.sayHi();</span><br><span class="line">    </span><br><span class="line">    h = <span class="keyword">new</span> ProxyHouse(h);</span><br><span class="line">    h.sayHi();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以实现客户与委托类之间的解耦，在不修改委托类的前提下能够做一些额外的处理。<br>静态代理的局限在于运行前必须编写好代理类，且针对每个需要代理方法都必须单独实现。</p><h2 id="3、动态代理"><a href="#3、动态代理" class="headerlink" title="3、动态代理"></a>3、动态代理</h2><p>动态代理：在程序运行时创建的代理方式，即代理类是动态生成的，而不是提前编写的。<br>相比于静态代理，动态代理可以很方便的对代理类进行统一处理，而不用修改每个代理类的函数，常用于权限控制、日志记录等场景。</p><p><strong>约束：</strong>委托类必须实现接口。</p><p>以下是动态代理的简单实现：在对某个类的一个方法的调用前和调用后都要做一下日志操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个普通的接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">House</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//委托类，需要增加日志的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HouseImpl</span> <span class="keyword">implements</span> <span class="title">House</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"welcome to my house!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态代理的中介类，关键</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxy</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//目标对象的引用，这里设计成Object类型，更具通用性 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxy</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">        Object res = method.invoke(obj, args);<span class="comment">//调用目标对象的方法 </span></span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        House h = <span class="keyword">new</span> HouseImpl();</span><br><span class="line">        <span class="comment">//创建中介类,代理了委托类</span></span><br><span class="line">        DynamicProxy dynamicProxy = <span class="keyword">new</span> DynamicProxy(h);</span><br><span class="line">        <span class="comment">//获取代理类实例，代理了中介类</span></span><br><span class="line">        House instance = (House)Proxy.newProxyInstance(House.class.getClassLoader(), <span class="keyword">new</span> Class[]&#123;House.class&#125;, dynamicProxy);</span><br><span class="line">        <span class="comment">//代理对象调用方法</span></span><br><span class="line">        instance.sayHi();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Java的动态代理，实际上是两次静态代理的组合。动态代理的重点是中介类的实现，需要实现java.lang.reflect.InvocationHandler接口。</p><p><strong>动态代理与静态代理的区别：</strong></p><ol><li>Proxy类的代码被固定下来，不会因为业务的逐渐庞大而庞大；</li><li>可以实现AOP编程，这是静态代理无法实现的；</li><li>解耦，如果用在web业务下，可以实现数据层和业务层的分离；</li><li>动态代理的优势就是实现无侵入式的代码扩展。静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题</li></ol><h2 id="4、CGLIB"><a href="#4、CGLIB" class="headerlink" title="4、CGLIB"></a>4、CGLIB</h2><p>在Spring AOP中，通常会用它来生成AopProxy对象。不仅如此，在Hibernate中PO(Persistant Object 持久化对象)字节码的生成工作也要靠它来完成。</p><p>以下是简单实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一个普通类，委托类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm helloServiceImpl"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现MethodInterceptor接口，回调函数，是增强方法的具体实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibCallBack</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before"</span>);</span><br><span class="line">        Object invokeSuper = proxy.invokeSuper(obj, args);</span><br><span class="line">        System.out.println(<span class="string">"after"</span>);</span><br><span class="line">        <span class="keyword">return</span> invokeSuper;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置委托类</span></span><br><span class="line">        enhancer.setSuperclass(HelloServiceImpl.class);</span><br><span class="line">        <span class="comment">//设置回调，即增强实现的类</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> CglibCallBack());</span><br><span class="line">        <span class="comment">//创建代理类</span></span><br><span class="line">        HelloServiceImpl helloService = (HelloServiceImpl)enhancer.create();</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">        helloService.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>生成的代理类 <strong>HelloServiceImpl\$\$EnhancerByCGLIB$$1a4d04e8@32e6e9c3</strong> 继承委托类 <strong>HelloServiceImpl</strong>。注意：如果委托类被final修饰，那么该类不可被继承，也就不能被代理；同样，如果方法被final修饰，该方法也不可被代理。</li><li><p>代理类会为委托类的委托方法生成两个方法，一个是重写的sayHello()方法，另一个是CGLIB\$sayHello$()方法，直接调用父类的方法。执行代理方法时，先判断是否存在实现MethodInterceptor接口的回调类对象，如果存在，则调用MethodInterceptor中的intercept方法，否则调用父类方法（不代理）。</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/designPatterns/cglib_method.png" alt="此处输入图片的描述"></p></li><li><p>cglib中的方法调用不是通过反射实现的，而是直接的方法调用。有一个数组存放着方法的引用。</p></li></ol><h2 id="5、三者对比"><a href="#5、三者对比" class="headerlink" title="5、三者对比"></a>5、三者对比</h2><table><thead><tr><th style="text-align:center">代理方式</th><th style="text-align:center">实现</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">特点</th></tr></thead><tbody><tr><td style="text-align:center">JDK静态代理</td><td style="text-align:center">代理类与委托类实现同一接口，并且在代理类中需要硬编码接口</td><td style="text-align:center">实现简单，容易理解</td><td style="text-align:center">代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低</td><td style="text-align:center">好像没啥特点</td></tr><tr><td style="text-align:center">JDK动态代理</td><td style="text-align:center">代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理</td><td style="text-align:center">不需要硬编码接口，代码复用率高</td><td style="text-align:center">只能够代理实现了接口的委托类</td><td style="text-align:center">底层使用反射机制进行方法的调用</td></tr><tr><td style="text-align:center">CGLIB动态代理</td><td style="text-align:center">代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理</td><td style="text-align:center">可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口</td><td style="text-align:center">不能对final类以及final方法进行代理</td><td style="text-align:center">底层将方法全部存入一个数组中，通过数组索引直接进行方法调用</td></tr></tbody></table><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://www.jianshu.com/p/9a61af393e41?from=timeline&amp;isappinstalled=0" target="_blank" rel="noopener">深入理解CGLIB动态代理机制</a></li><li><a href="https://www.jianshu.com/p/471c80a7e831" target="_blank" rel="noopener">深入理解JDK动态代理机制</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java本身给我们提供了静态代理和动态代理两种代理方式，spring提供了基于类的代理方式：cglib.&lt;/p&gt;
&lt;p&gt;在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。&lt;br&gt;在代理模式中，我们创建&lt;strong&gt;具有现有对象的对象&lt;/strong&gt;，以便向外界提供功能接口。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="https://www.greateman.top/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://www.greateman.top/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机：类加载器</title>
    <link href="https://www.greateman.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html"/>
    <id>https://www.greateman.top/Java虚拟机：类加载器.html</id>
    <published>2018-04-23T09:11:37.000Z</published>
    <updated>2018-07-27T00:48:19.139Z</updated>
    
    <content type="html"><![CDATA[<p>虚拟机把描述类的数据从Class字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><a id="more"></a><h2 id="1、类加载的时机"><a href="#1、类加载的时机" class="headerlink" title="1、类加载的时机"></a>1、类加载的时机</h2><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证、准备、解析、初始化、使用、卸载7个阶段，其中验证、准备、解析3个部分统称为连接，发生顺序如下图所示：<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/ClassLife.jpg" alt="类的生命周期"></p><p>加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，而解析则不一定：它在某些情况下可以在初始化之后再开始，这是为了支持Java的运行时绑定(也成动态绑定或晚期绑定)。</p><p>那么何时开始第一阶段加载呢？虚拟机规范没有强制约束，由虚拟机具体实现自由把握。<br>但初始化阶段，有且仅有5种情况必须立即初始化：</p><ol><li>遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条指令的最常见的Java代码场景:使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用时，如果类没有初始化，则需先触发其初始化。</li><li>当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化，则需要先触发其初始化。</li></ol><h2 id="2、类加载器"><a href="#2、类加载器" class="headerlink" title="2、类加载器"></a>2、类加载器</h2><p>虚拟机团队吧类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><p>类加载器虽然只用于实现类的加载动作，但它的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的命名空间。也就是说：比较两个类是否“相等”，只有在这两个类由同一个类加载器加载的前提下才有意义，否则，即使是来源于同一个Class文件，被同一个JVM加载，只要加载它们的类加载器不同，那么这两个类就必不相等。</p><p><strong>类加载器的分类：</strong></p><ol><li>启动类加载器(Bootstrap ClassLoader):负责加载<java_home>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的能被识别的类库。</java_home></li><li>扩展类加载器(Extension ClassLoader):负责加载<java_home>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该加载器。</java_home></li><li>应用程序加载器(Application ClassLoader):由ClassLoader中的getSystemClassLoader()方法获得，负责加载用户路径(classpath)上的类库。若果没有自定义加载器，一般情况下这就是程序的默认类加载器。</li></ol><p><strong>双亲委派机制：</strong></p><p> <img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/ParentsDelegationModel.jpg" alt="此处输入图片的描述"></p><p>除启动类加载器外，器与类加载器都应有自己的父类。</p><p>若果一个类收到类加载的请求，它首先不会自己去加载，而是委派给父类加载器去完成，依次往上，因此所有的加载请求最终都会传递到顶层的启动类加载器。只有当父类反馈自己无法加载，子类才会尝试去加载。</p><p>这样做的好处：<br>    使类加载器具备了优先级的层次关系，保证了同一个类始终是由同一个类加载器完成加载。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;虚拟机把描述类的数据从Class字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://www.greateman.top/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java虚拟机" scheme="https://www.greateman.top/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java虚拟机：内存模型</title>
    <link href="https://www.greateman.top/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html"/>
    <id>https://www.greateman.top/Java虚拟机：内存模型.html</id>
    <published>2018-04-20T10:34:03.000Z</published>
    <updated>2018-07-27T00:48:19.138Z</updated>
    
    <content type="html"><![CDATA[<p>Java虚拟机是Java程序运行的真实环境，要深入理解Java是如何运行的，理解Java虚拟机是必不可少的。典型的例子：内存溢出。当我们理解java虚拟机之后，我们就会明白为何会出现这个问题，我们又当如何去定位并解决这个问题。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/JavaProcess.png" alt="Java执行过程"></p><h2 id="1、JVM内存分布"><a href="#1、JVM内存分布" class="headerlink" title="1、JVM内存分布"></a>1、JVM内存分布</h2><p>通常我们说的JVM内存分布即指<strong>运行时数据区</strong>。下图为分布概念图：</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/RunningArea.png" alt="运行时数据区"></p><h3 id="1-1-堆-Heap"><a href="#1-1-堆-Heap" class="headerlink" title="1.1 堆(Heap)"></a>1.1 堆(Heap)</h3><ul><li>被所有线程共享的一块内存区域，在虚拟机启动时创建</li><li>用来存贮对象实例</li><li>可以通过-Xmx和-Xms控制堆的大小</li><li><p>OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时</p><p> Java堆是垃圾回收器的主要工作区域。由于现在垃圾收集器采用的基本都是<strong>分代收集算法</strong>，所以堆还可以细分为<strong>新生代(New/Young)</strong>和<strong>老年代(Old/Tenured)</strong>，再细致一点还有<strong>Eden</strong>区、<strong>From Survivior</strong>区、<strong>To Survivor</strong>区。</p><p> <strong>新生代：</strong>新建的对象都由新生代分配内存。常常又被划分为Eden区和Survivor区，Eden空间不足时会把存活的对象转移到Survivor。新生代的大小可有-Xmn控制，也可用-XX:SurvivorRatio控制Eden和Survivor的比例。<br> <strong>老年代：</strong>存放经过多次垃圾回收仍然存活的对象。</p></li></ul><h3 id="1-2-方法区-Method-Area"><a href="#1-2-方法区-Method-Area" class="headerlink" title="1.2 方法区(Method Area)"></a>1.2 方法区(Method Area)</h3><ul><li>线程间共享</li><li>用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器变异后的代码等数据</li><li>OutOfMemoryError异常：当方法区无法满足内存的分配需求时</li></ul><p><strong>运行时常量池</strong>：</p><ul><li>方法区的一部分</li><li>用于存放编译期生成的各种字面量和符号引用，如String类型常量就存放在常量池</li><li>OutOfMemoryError异常：当常量池无法再申请到内存时</li></ul><h3 id="1-3-程序计数器-Program-Counter-Register"><a href="#1-3-程序计数器-Program-Counter-Register" class="headerlink" title="1.3 程序计数器(Program Counter Register)"></a>1.3 程序计数器(Program Counter Register)</h3><ul><li>当前线程所执行的字节码的行号指示器</li><li>当前线程私有</li><li>不会出现OutOfMemoryError</li><li>如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空</li></ul><h3 id="1-4-虚拟机栈-VM-Stack"><a href="#1-4-虚拟机栈-VM-Stack" class="headerlink" title="1.4 虚拟机栈(VM Stack)"></a>1.4 虚拟机栈(VM Stack)</h3><ul><li>线程私有，生命周期与线程相同</li><li>存储方法的局部变量表(局部变量、对象引用和返回地址等)、操作数栈、动态链接、方法出口等信息</li><li>Java方法执行的呢内存模型，每个方法执行的同时都会创建一个栈帧，每一个方法被调用直至完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</li><li>StackOverflowError异常:当线程请求的栈深度大于虚拟机所允许的深度</li><li><p>OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存</p><p> JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈。</p><p> 这里解释一下局部变量表，局部变量表存储方法相关的局部变量，包括基本数据，对象引用和返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。</p></li></ul><h3 id="1-5-本地方法栈-Native-Method-Stack"><a href="#1-5-本地方法栈-Native-Method-Stack" class="headerlink" title="1.5 本地方法栈(Native Method Stack)"></a>1.5 本地方法栈(Native Method Stack)</h3><p>与虚拟机栈类似，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的。</p><font color="red"><strong>在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一</strong></font><h3 id="1-6-直接内存-Direct-Memory"><a href="#1-6-直接内存-Direct-Memory" class="headerlink" title="1.6 直接内存(Direct Memory)"></a>1.6 直接内存(Direct Memory)</h3><ul><li>直接内存并不是虚拟机运行的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用.</li><li>NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作</li><li>大小不受Java堆大小的限制，受本机(服务器)内存限制</li><li>OutOfMemoryError异常：系统内存不足时</li></ul><h3 id="1-7-永久代-PermGen-的发展"><a href="#1-7-永久代-PermGen-的发展" class="headerlink" title="1.7 永久代(PermGen)的发展"></a>1.7 永久代(PermGen)的发展</h3><p>方法区是JVM的规范，是一个逻辑存储区域。永久代是JVM规范的一种实现，并且永久代是HotSpot特有的。</p><ul><li>JDK 1.6<br> 永久代即方法区，存储着类信息、常量、静态变量、JIT编译的代码等</li><li>JDK 1.7<br> 符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap</li><li>JDK 1.8<br> 不存在永久代，取而代之的是元空间(MetaSpace)。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。</li></ul><p>那么，为什么要做出这些转变呢？有以下几点原因：</p><ol><li>字符串存在永久代中，容易出现性能问题和内存溢出。</li><li>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</li><li>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</li><li>Oracle 可能会将HotSpot 与 JRockit 合二为一。</li></ol><p>关于PermGen和Metaspace，可以看下<a href="http://www.cnblogs.com/paddix/p/5309550.html" target="_blank" rel="noopener">liuxiaopeng的博客</a>。</p><h3 id="1-8-小结"><a href="#1-8-小结" class="headerlink" title="1.8 小结"></a>1.8 小结</h3><p>Java对象实例存放在堆中；常量存放在方法区的常量池；虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区；以上区域是所有线程共享的。栈是线程私有的，存放该方法的局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息。</p><p>一个Java程序对应一个JVM，一个方法（线程）对应一个Java栈。</p><h2 id="2、对象访问方式"><a href="#2、对象访问方式" class="headerlink" title="2、对象访问方式"></a>2、对象访问方式</h2><p>Java对象这里指的是引用类型的对象，这里用Student stu=new Student()为例子访问，Student stu作为引用对象，存在与Java虚拟机栈上，new Student()保存在Java堆中，堆中记录Student类型的信息包括方法，接口，对象类型等地址，这些类型的执行的数据存储在方法区中。</p><h3 id="2-1-句柄访问"><a href="#2-1-句柄访问" class="headerlink" title="2.1 句柄访问"></a>2.1 句柄访问</h3><p>Java堆中分配一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象示例数据和对象类型数据的地址。<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/HandleAccess.png" alt="句柄访问"></p><h3 id="2-2-直接指针访问"><a href="#2-2-直接指针访问" class="headerlink" title="2.2 直接指针访问"></a>2.2 直接指针访问</h3><p>对象中存贮着对象实例数据和类数据的地址，Java栈的引用指向堆中的对象。</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/DirectPointerAccess.png" alt="直接指针访问"></p><h3 id="2-3-小结"><a href="#2-3-小结" class="headerlink" title="2.3 小结"></a>2.3 小结</h3><p>这两种访问方式各有优势。</p><p><strong>句柄访问：</strong> reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身是不需要修改的。</p><p><strong>直接指针访问：</strong>最大的好处是速度快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常的频繁，因此这类开销积少成多也是非常可观的执行成本。</p><p>就HotSpot虚拟机来说，它采用的是直接指针访问。但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也是十分常见的。</p><h2 id="3、哪些对象需要回收？"><a href="#3、哪些对象需要回收？" class="headerlink" title="3、哪些对象需要回收？"></a>3、哪些对象需要回收？</h2><p>Java运行时数据区的几大板块中，程序计数器、虚拟机栈、本地方法栈3个区域随着线程而生，随着线程而灭，因此这几个区域的内存分配和回收都具备确定性，在这3个区域不需要过多的考虑GC问题。而堆和方法区则不一样，我们只有在程序运行期间才能知道会创建哪些对象、占用多少内存，这部分内存的分配和回收都是动态的，垃圾收集器关注的也正是这部分内存。</p><p>堆中存放着几乎所有的对象实例，在垃圾收集之前，需要判断哪些对象需要被除了，即哪些对象“存活”着，哪些对象已经“死去”。</p><h3 id="3-1-引用计数算法"><a href="#3-1-引用计数算法" class="headerlink" title="3.1 引用计数算法"></a>3.1 引用计数算法</h3><p>给对象中添加一个引用计数器，每当有一个地方引用该对象，计数器值就加1，当引用失效时,引用就减1。任何时刻计数器为0的对象就是不可能再被使用的。</p><p>缺陷：很难解决象之间互相循环引用的问题。</p><h3 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h3><p>主流语言(Java、C#)的主流实现，都是通过可达性算法判断对象是否存活。</p><p>基本思路：通过一系列成为”GC Roots”的对象作为起始点，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可达，所以它们就会被判定为可回收对象。<br><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/ReachabilityAnalysis.png" alt="可达性算法"></p><p>在Java中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈JNI（即一般说的Native方法）引用的对象</li></ul><h3 id="3-3-再谈引用"><a href="#3-3-再谈引用" class="headerlink" title="3.3 再谈引用"></a>3.3 再谈引用</h3><p>在JDK1.2以前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表着另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但很狭隘，在这种定义下，对象只存在被引用和没有被引用两种状态。我们希望描述这样一类对象：当空间内存足够时，则保留在内存中；如果内存在GC后还非常紧张，则可以抛弃这些对象。很多系统的缓存都符合这种引用场景。</p><p>在JDK1.之后，Java对引用概念进行了扩充，分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，强度依次递减。</p><ul><li>强引用：类似Object obj = new Object()，只要强引用还在，则不会被GC</li><li>软引用：描述一些还有用但非必须的对象。在系统将要发生内存溢出异常前，将会把这些软引用对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</li><li>弱引用：也是描述一些非必须对象，但强度比软引用更弱一些。这些对象只能存活到下一次GC之前。当开始GC时，无论内存是否足够，这些对象都会被回收。</li><li>虚引用：不影响GC，唯一目的是被虚引用关联的对象被GC时能收到一个系统通知。</li></ul><h3 id="3-4-生存还是死亡"><a href="#3-4-生存还是死亡" class="headerlink" title="3.4 生存还是死亡"></a>3.4 生存还是死亡</h3><p>即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候他们处于缓刑状态，要真正宣布一个对象死亡，至少需要经过两次标记过程：</p><ol><li><p>可达性分析后没有与GC Roots相连的引用链，它会被第一次标记并且进行一次筛选。</p><p>筛选条件是是否有必要执行finalize()方法。如果没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，这两种情况都被视为“没有必要执行”。<br>如果判定为有必要执行finalize()方法，该对象被放置在一个F-Queue的队列中，并稍后由虚拟机建立的低优先级Finalizer线程去执行他，也就是触发对象的finalize()方法。finalize()是对象逃脱死亡的最后一次机会。</p></li><li><p>稍后GC将对F-Queue中的对象进行第二次小规模标记</p><p>如果对象在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那么第二次标记时它将被移出“即将回收”的集合；如果第二次标记时还没有逃脱，那它基本上就真的会被回收了。</p></li></ol><h3 id="3-5-回收方法区"><a href="#3-5-回收方法区" class="headerlink" title="3.5 回收方法区"></a>3.5 回收方法区</h3><p>方法区（或者HotSpot中的永久代）主要回收两部分：废弃常量和无用的类。</p><ol><li><p>废弃常量</p><p>如果没有任何一个地方引用常量，在GC时如果有必要的话，该常量会被清理出常量池。常量池中的类（接口）、方法、字段的符号引用也是类似的。</p></li><li><p>无用的类</p><p>卸载类就很麻烦了，必须同时满足3个条件：</p><ul><li>该类所有实例都已被回收</li><li>加载该类的ClassLoader已经被会后</li><li>该类对应的Class对象没有在任何地方呗引用，无法通过反射访问该类的方法</li></ul><p>满足以上条件也只是可以被回收，是否被回收，HotSpot还有其他方法来控制。</p></li></ol><h2 id="4、何时回收？"><a href="#4、何时回收？" class="headerlink" title="4、何时回收？"></a>4、何时回收？</h2><p>GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。</p><ol><li>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，Minor GC非常频繁，而且速度也很快；</li><li>Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。</li><li>JDK 6 Update 24之后,HandlePromotionFailure无效。只要老年代剩余连续空间大于新生代对象总和或者历次晋升的平均大小就会进行Minor GC，否则Full GC。<br><del>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看是否允许担保失败(HandlePromotionFailure=true/false)，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。</del></li></ol><h2 id="5、如何回收？"><a href="#5、如何回收？" class="headerlink" title="5、如何回收？"></a>5、如何回收？</h2><p>简单描述几种算法的思路及演变过程</p><h3 id="5-1-标记——清除算法"><a href="#5-1-标记——清除算法" class="headerlink" title="5.1 标记——清除算法"></a>5.1 标记——清除算法</h3><p>分为“标记”和“清除”两个阶段：</p><ul><li>标记：即前面提到过的，GC时两次标记的过程。</li><li>清除：统一回收被标记的对象</li></ul><p>缺点：</p><ul><li>效率不高：标记和清除的过程效率都不高</li><li>产生大量内存碎片：导致以后分配较大内存对象时，由于没有足够大的连续内存从而提前触发一次GC动作。</li></ul><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/mark-sweep.png" alt="标记——清除算法"></p><h3 id="5-2-复制算法"><a href="#5-2-复制算法" class="headerlink" title="5.2 复制算法"></a>5.2 复制算法</h3><p>为了解决效率问题，出现了复制算法。将可用内存分为大小相等的两块，每次只是用其中一块。当这一块用完，将还存活的复制到另一块，然后再把使用过的内存空间一次清理掉，循环往复。</p><ul><li>优点：不用考虑内存碎片，实现简单，运行高效</li><li>缺点：<ul><li>内存缩小为原来的一半，代价太大；</li><li>需要额外的老年代空间进行分配担保</li></ul></li></ul><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/copy.png" alt="复制算法"></p><h3 id="5-3-标记——整理算法"><a href="#5-3-标记——整理算法" class="headerlink" title="5.3 标记——整理算法"></a>5.3 标记——整理算法</h3><p>分为“标记”和“整理”两个阶段：</p><ul><li>标记：即前面提到过的，GC时两次标记的过程。</li><li>整理：让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</li></ul><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/mark-compact.png" alt="此处输入图片的描述"></p><h3 id="5-4-分代收集算法"><a href="#5-4-分代收集算法" class="headerlink" title="5.4 分代收集算法"></a>5.4 分代收集算法</h3><p>当前商业虚拟机的垃圾收集都采用“分代收集算法”。</p><p>对于HotSpot虚拟机，堆内存分布如下图所示：</p><p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/JVM/generationalCollection.png" alt="分代收集算法下的堆内存分布">  </p><p>新生代中使用 <strong>复制算法</strong>，老年代使用 <strong>标记——整理算法</strong></p><p>默认情况下，eden与survivor的大小比例是8:1,可由 -XX：SurvivorRatio=8 设置。所以可用新生代大小为新生代的90%。</p><p>以下是算法的基本思路：</p><ol><li>对象新建时，首先会在Eden区创建，年龄为0，直到GC时，若没有消亡，则放入servivor区，年龄为1</li><li>进入survivor区也不是安全的，当下一次Minor GC来的时候，会检查Eden区和使用的Survivor区，若有对象存活，则放入另一个Survivor区，年龄加1</li><li>当两个Survivor区切换几次后，对象年龄增长到15(默认，-XX:MaxTenuringThreshold=15)，则进入老年代。</li><li>进入老年代也不是安全的，当老年代空间不足时，触发Major GC，已经消亡的对象还是会被干掉。</li></ol><p>推荐一个这个写的很逗可以看下：<a href="http://blog.csdn.net/sd4015700/article/details/50109939" target="_blank" rel="noopener">http://blog.csdn.net/sd4015700/article/details/50109939</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java虚拟机是Java程序运行的真实环境，要深入理解Java是如何运行的，理解Java虚拟机是必不可少的。典型的例子：内存溢出。当我们理解java虚拟机之后，我们就会明白为何会出现这个问题，我们又当如何去定位并解决这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Java虚拟机" scheme="https://www.greateman.top/categories/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
    
      <category term="Java虚拟机" scheme="https://www.greateman.top/tags/Java%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>web.xml不同版本之间的差异</title>
    <link href="https://www.greateman.top/web-xml%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82.html"/>
    <id>https://www.greateman.top/web-xml不同版本之间的差异.html</id>
    <published>2018-04-13T09:31:13.000Z</published>
    <updated>2018-07-27T00:48:19.185Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/web/servletVersion.png" alt="此处输入图片的描述"></p><a id="more"></a><p>Apache官方对各版本的解释：<a href="http://tomcat.apache.org/whichversion.html" target="_blank" rel="noopener">http://tomcat.apache.org/whichversion.html</a></p><p>The web.xml is a configuration file to describe how a web application should be deployed. Here’re 5 web.xml examples, just for self-reference.</p><ol><li><p>Servlet 4.0</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">    http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">version</span>=<span class="string">"4.0"</span> <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Servlet 3.1</p><p>Java EE 7 XML schema, namespace is <a href="http://xmlns.jcp.org/xml/ns/javaee/" target="_blank" rel="noopener">http://xmlns.jcp.org/xml/ns/javaee/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span><br><span class="line">      xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">      xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee </span><br><span class="line">http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot;</span><br><span class="line">      version=&quot;3.1&quot;&gt;</span><br><span class="line"> &lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Servlet 3.0</p><p>Java EE 6 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee</a><br>Servlet3.0随J2EE6一起发布，web.xml配置文件中包含：<br>默认页配置、session超时配置和错误提示页配置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot;</span><br><span class="line">   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">   xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee </span><br><span class="line">   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span><br><span class="line">   version=&quot;3.0&quot;&gt;</span><br><span class="line">&lt;/web-app&gt;</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Servlet 2.5</p><p>Java EE 5 XML schema, namespace is <a href="http://java.sun.com/xml/ns/javaee" target="_blank" rel="noopener">http://java.sun.com/xml/ns/javaee</a><br>2.5以上版本即可解决多个url不能映射到同一个servlet的问题。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/javaee </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">version</span>=<span class="string">"2.5"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Servlet 2.4</p><p>J2EE 1.4 XML schema, namespace is <a href="http://java.sun.com/xml/ns/j2ee" target="_blank" rel="noopener">http://java.sun.com/xml/ns/j2ee</a><br>2.4以上版本即可解决上面问题。<br>但是2.4及以下版本会有一个问题：（多个url不能映射到同一个servlet）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://java.sun.com/xml/ns/j2ee </span></span></span><br><span class="line"><span class="tag"><span class="string">   http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span></span></span><br><span class="line"><span class="tag">   <span class="attr">version</span>=<span class="string">"2.4"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.4 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ol><li><p>Servlet 2.3</p><p>J2EE 1.3 DTD模式。这个xml文件太旧了，强烈推荐你升级。<br>这个有个缺点：web-app里的标签有一定的顺序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE web-app PUBLIC</span></span><br><span class="line"><span class="meta"> "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"</span></span><br><span class="line"><span class="meta"> "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Servlet 2.3 Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/kevinXiao2016/kevinXiao2016.github.io/hexo/imageStorage/web/servletVersion.png&quot; alt=&quot;此处输入图片的描述&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Web" scheme="https://www.greateman.top/categories/Web/"/>
    
    
      <category term="Web" scheme="https://www.greateman.top/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Mysql事务的隔离级别</title>
    <link href="https://www.greateman.top/Mysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html"/>
    <id>https://www.greateman.top/Mysql事务的隔离级别.html</id>
    <published>2018-04-11T06:02:50.000Z</published>
    <updated>2018-07-27T00:48:19.147Z</updated>
    
    <content type="html"><![CDATA[<table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:left">read-unconmitted</td><td style="text-align:center">√</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:left">read-conmitted</td><td style="text-align:center">×</td><td style="text-align:center">√</td><td style="text-align:center">√</td></tr><tr><td style="text-align:left">repeatable-read</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">√</td></tr><tr><td style="text-align:left">serializable</td><td style="text-align:center">×</td><td style="text-align:center">×</td><td style="text-align:center">×</td></tr></tbody></table><a id="more"></a><h2 id="1、事务的基本要素-ACID"><a href="#1、事务的基本要素-ACID" class="headerlink" title="1、事务的基本要素(ACID)"></a>1、事务的基本要素(ACID)</h2><ul><li>原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。</li><li>一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。</li><li>隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</li><li>持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。</li></ul><h2 id="2、隔离级别"><a href="#2、隔离级别" class="headerlink" title="2、隔离级别"></a>2、隔离级别</h2><ul><li><p>read-unconmitted</p><p> 可以读到其他事务未提交的数据，是最低级别的事务隔离级别。</p><p> 例如：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是错误的，称之为<strong>脏数据</strong>。</p></li><li><p>read-conmitted</p><p> 为了解决脏读，就需要保证读取被事务提交的数据，也就是<strong>read-conmitted</strong>。</p><p> <strong>看一个例子</strong>：</p><pre><code>事务A读一个数据，读到100.此时另外一个线程执行事务B将数据改为200，并提交事务。接下来事务A再次读该数据，读到200.</code></pre><p> 这种在一个事务中两次读取到数据不一致的情况，我们称之为<strong>不可重复读</strong>。</p></li><li><p>repeatable-read</p><p> 为了解决不可重复读，就需要保证一个事务在操作一份数据时，不允许其他事务操作该数据。此时反应到数据库上，就是需要对行加锁。这种隔离级别称之为<strong>repeatable-read</strong>。</p><p> <strong>看一个例子</strong>：</p><pre><code>事务A统计当天营业额（遍历表，计和），为1000.事务B插入一条销售记录，200。事务A再统计当天营业额，为1200.</code></pre><p> 这种一个事务中前后两次统计不一致的情况，称之为<strong>幻读</strong>。</p></li><li><p>serializable</p><p> 为了解决幻读，只能严格要求所有线程的所有事务都按照顺序依次执行，也就是 表锁。</p><p> 但是此种级别并发性太差，且一般也没有必要。</p></li></ul><h2 id="3、总结"><a href="#3、总结" class="headerlink" title="3、总结"></a>3、总结</h2><p>我们需要区分事务的隔离级别和现象。<br>隔离级别是指导原则，现象是产生的问题，而数据库锁则是解决手段。</p><p>Mysql默认隔离级别是 <strong>repeatable-read</strong>。<br>Oracle默认隔离级别是 <strong>read-conmitted</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:left&quot;&gt;隔离级别&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;脏读&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;不可重复读&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;幻读&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;read-unconmitted&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;read-conmitted&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;repeatable-read&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;√&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:left&quot;&gt;serializable&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;×&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://www.greateman.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://www.greateman.top/tags/Mysql/"/>
    
      <category term="数据库" scheme="https://www.greateman.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Mysql索引的简单使用</title>
    <link href="https://www.greateman.top/Mysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html"/>
    <id>https://www.greateman.top/Mysql索引的简单使用.html</id>
    <published>2018-04-10T13:11:36.000Z</published>
    <updated>2018-07-27T00:48:19.149Z</updated>
    
    <content type="html"><![CDATA[<p>这篇记录了mysql中索引的简单使用方法，基本上满足大部分的开发需求。</p><a id="more"></a><h2 id="1、索引是什么"><a href="#1、索引是什么" class="headerlink" title="1、索引是什么"></a>1、索引是什么</h2><p>索引（Index）是帮助Mysql高效查询数据的一种数据结构，其本质：数据结构。</p><h2 id="2、优势"><a href="#2、优势" class="headerlink" title="2、优势"></a>2、优势</h2><p>好比图书馆建立的书目索引，提高数据检索效率，降低数据库的IO成本。<br>通过索引对数据库进行排序，降低数据排序的成本，降低CPU的消耗。</p><h2 id="3、劣势"><a href="#3、劣势" class="headerlink" title="3、劣势"></a>3、劣势</h2><p>索引也是一张表，该表保存了主键与索引片段，并指向实体表的记录，所以索引也是需要占用空间的。<br>同时会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。</p><h2 id="4、分类"><a href="#4、分类" class="headerlink" title="4、分类"></a>4、分类</h2><ol><li>单列索引：即一个索引只包含一个列，一张表可以有多个单列索引。</li><li>唯一索引(UNIQUE)：索引列的值必须唯一，允许为空值。</li><li>全文索引(FULLTEXT)：仅用于MyISAM表。</li><li>组合索引(最左前缀): 多个列构成一个索引，适用于查询条件较复杂的情况。</li></ol><blockquote><p>最左前缀：</p></blockquote><p>mysql查询时只能使用一个索引。建立组合索引时，本质上同时建立了好几个索引，下面以实例讲解：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> people <span class="keyword">ADD</span> <span class="keyword">INDEX</span> lname_fname_age (lame,fname,age);</span><br></pre></td></tr></table></figure><p>创建一个组合索引，相当于同时创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p><p><strong>注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。</strong></p><p>虽然索引对顺序敏感，但是mysql优化器会自动调整where后面的条件顺序，来匹配合适的索引。</p><h2 id="5、基本语法"><a href="#5、基本语法" class="headerlink" title="5、基本语法"></a>5、基本语法</h2><ol><li><p>创建索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">UNIQUE</span>] <span class="keyword">INDEX</span> indexName <span class="keyword">ON</span> tableName(columnName(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure><p>如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。</p></li></ol><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> tableName <span class="keyword">ADD</span> <span class="keyword">INDEX</span> indexName(columnName(<span class="keyword">length</span>))</span><br></pre></td></tr></table></figure>修改表结构添加索引<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> mytable (</span><br><span class="line"><span class="keyword">ID</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">username <span class="built_in">VARCHAR</span> (<span class="number">16</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="keyword">INDEX</span> [ indexName ] (username(<span class="keyword">length</span>))</span><br><span class="line">);</span><br></pre></td></tr></table></figure>创建表的时候直接指定。&gt; 使用ALTER 命令添加和删除索引： - ALTER TABLE tbl_name ADD PRIMARY KEY (column_list):    该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 - ALTER TABLE tbl_name ADD UNIQUE index_name (column_list):    这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 - ALTER TABLE tbl_name ADD INDEX index_name (column_list):     添加普通索引，索引值可出现多次。 - ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):    该语句指定了索引为 FULLTEXT ，用于全文索引。</code></pre><ol><li><p>删除索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">INDEX</span> [indexName] <span class="keyword">ON</span> tableName</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">INDEX</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure></li></ol><h2 id="6、Mysql索引结构"><a href="#6、Mysql索引结构" class="headerlink" title="6、Mysql索引结构"></a>6、Mysql索引结构</h2><ul><li><p>BTree：</p><ul><li>可以用于使用 =, &gt;, &gt;=, &lt;, &lt;= 或者 BETWEEN 运算符的列比较</li><li>如果 LIKE 的参数是一个没有以通配符起始的常量字符串的话也可以使用这种索引</li></ul></li><li><p>Hash：</p><ul><li>只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快)</li><li>优化器不能够使用 hash 索引来加速 ORDER BY 操作</li><li>无法使用 hash 索引估计两个值之间有多少行</li></ul></li><li><p>full-text：MyISAM的一个特殊索引类型，主要用于全文检索。</p></li><li>R-Tree：MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。</li></ul><h2 id="7、哪些情况需要创建索引"><a href="#7、哪些情况需要创建索引" class="headerlink" title="7、哪些情况需要创建索引"></a>7、哪些情况需要创建索引</h2><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中与其他表关联的字段，外键关系建立索引</li><li>单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引)</li><li>查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度</li><li>查询中统计或者分组字段</li></ol><h2 id="8、哪些情况不需要创建索引"><a href="#8、哪些情况不需要创建索引" class="headerlink" title="8、哪些情况不需要创建索引"></a>8、哪些情况不需要创建索引</h2><ol><li>表记录太少</li><li>经常增删改的表<br>　　　　提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。<br>　　　　因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。<br>　　　　数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。</li><li>注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。</li><li>频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引</li><li>WHERE条件里用不到的字段不创建索引</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇记录了mysql中索引的简单使用方法，基本上满足大部分的开发需求。&lt;/p&gt;
    
    </summary>
    
      <category term="Mysql" scheme="https://www.greateman.top/categories/Mysql/"/>
    
    
      <category term="Mysql" scheme="https://www.greateman.top/tags/Mysql/"/>
    
      <category term="数据库" scheme="https://www.greateman.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
</feed>
