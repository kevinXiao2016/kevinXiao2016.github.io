<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[【Linux】CentOS7下搭建Redis集群详细过程]]></title>
    <url>%2F%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E6%90%AD%E5%BB%BARedis%E9%9B%86%E7%BE%A4%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[Redis-cluster集群方案从redis3.0版本开始支持，本文仅做基本的集群搭建介绍。 1、下载编译Reids12345678910111213141516//创建安装包文件夹mkdir /usr/local/packages//创建redis安装目录mkdir /usr/local/redis//下载安装包cd /usr/local/packageswget http://download.redis.io/releases/redis-4.0.1.tar.gz//解压到安装目录tar -zxvf redis-4.0.1.tar.gz -C /usr/local/redis//编译cd /usr/local/redis/redis-4.0.1makemake install 注意：在执行make的是时候确保包含了编译所需的工具包。阿里云Centos7.0 编译没有问题直接通过 安装成功后，在/usr/local/redis/redis-4.0.1/src目录下会有编译后的文件，并且在/usr/local/bin目录下生成redis有关的指令文件。 2、节点规划规划创建6个redis实例，3主3从，简单起见，均在同一机器上，规划端口为6380 ~ 6385。 在 /usr/local 下创建/redis/redis-cluster文件夹，并在其中创建6380-6385 6个文件夹 123456[root@localhost redis-cluster]# mkdir 6380[root@localhost redis-cluster]# mkdir 6381[root@localhost redis-cluster]# mkdir 6382[root@localhost redis-cluster]# mkdir 6383[root@localhost redis-cluster]# mkdir 6384[root@localhost redis-cluster]# mkdir 6385 3、配置修改拷贝一份配置文件到当前目录 1[root@localhost redis-cluster]# cp ../redis-4.0.1/redis.conf ./ 修改属性，cope6份分别放在6个文件夹中，注意更改端口号 123456789port 6380 //端口daemonize yes //后台启动模式pidfile /var/run/redis-6380pid //开启daemonize需要配置cluster-enabled yes //cluster模式cluster-config-file nodes-6380.conf //日志文件名cluster-node-timeout 5000 //请求超时时间，5sappendonly yes //aof日志开启 有需要就开启，它会每次写操作都记录一条日志bind 192.168.86.130 //服务器ip 4、启动redis简便起见，创建集群启动脚本 1[root@localhost redis-cluster]#vim start-all.sh 输入一下内容并保存 123456redis-server /usr/local/redis/redis-cluster/redis-6380/redis.confredis-server /usr/local/redis/redis-cluster/redis-6381/redis.confredis-server /usr/local/redis/redis-cluster/redis-6382/redis.confredis-server /usr/local/redis/redis-cluster/redis-6383/redis.confredis-server /usr/local/redis/redis-cluster/redis-6384/redis.confredis-server /usr/local/redis/redis-cluster/redis-6385/redis.conf 赋予该脚本可执行权限： 1chmod +x start-all.sh 同样，创建集群关闭脚本，并赋予相同权限，内容如下 1[root@localhost redis-cluster]#vim stop-all.sh 123456redis-cli -h 192.168.86.130 -p 6380 shutdownredis-cli -h 192.168.86.130 -p 6381 shutdownredis-cli -h 192.168.86.130 -p 6382 shutdownredis-cli -h 192.168.86.130 -p 6383 shutdownredis-cli -h 192.168.86.130 -p 6384 shutdownredis-cli -h 192.168.86.130 -p 6385 shutdown 启动redis,执行启动脚本： 1./start-all.sh 查看redis启动情况： [root@localhost redis-cluster]# ps -ef | grep redis root 3241 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6380 [cluster] root 3243 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6381 [cluster] root 3248 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6382 [cluster] root 3256 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6383 [cluster] root 3261 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6384 [cluster] root 3266 1 0 02:33 ? 00:00:00 redis-server 192.168.86.130:6385 [cluster] root 3271 2600 0 02:33 pts/0 00:00:00 grep --color=auto redis 5、Ruby环境redis集群管理工具redis-trib.rb依赖ruby环境，首先需要安装ruby环境。 12yum install rubyyum install rubygems 拷贝redis-3.0.0.gem至/usr/local下执行： 1gem install /usr/local/redis 若报如下错误，则是ruby版本过低,需要安装一个高于2.2.2版本的ruby。 12ERROR: Error installing redis: redis requires Ruby version &gt;= 2.2.2. 具体过程参考： 6、启动集群拷贝redis-trib.rb到 redis目录下 1cp /usr/local/redis/redis-4.0.1/src/redis-trib.rb /usr/local/redis/redis-cluster 进入redis-cluster目录下，执行集群脚本： 1./redis-trib.rb create --replicas 1 192.168.86.130:6380 192.168.86.130:6381 192.168.86.130:6382 192.168.86.130:6383 192.168.86.130:6384 192.168.86.130:6385 简单解释一下这个命令：调用 ruby 命令来进行创建集群，--replicas 1 表示主从复制比例为 1:1，即一个主节点对应一个从节点；然后，默认给我们分配好了每个主节点和对应从节点服务，以及 solt 的大小，因为在 Redis 集群中有且仅有 16383 个 solt ，默认情况会给我们平均分配，当然你可以指定，后续的增减节点也可以重新分配。随便找一个节点测试试 12345[root@localhost redis-cluster]# redis-cli -h 192.168.86.130 -p 6382 -c192.168.86.130:6382&gt; set b 100-&gt; Redirected to slot [3300] located at 192.168.86.130:6380OK192.168.86.130:6380&gt; 参考配置文件说明redis详解]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】CentOS7下安装Tomcat详细过程]]></title>
    <url>%2F%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85Tomcat%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[安装步骤概述. 1、安装 JDK具体步骤见 【Linux】CentOS7下安装JDK详细过程 2、安装 Tomcat2.1 下载Tomcat官方下载地址：tomcat9官方下载地址 在命令窗口键入： 1wget http://mirror.bit.edu.cn/apache/tomcat/tomcat-9/v9.0.10/bin/apache-tomcat-9.0.10.tar.gz 或者windows下载后，上传到Linux服务器 2.2 解压在命令窗口键入： 1tar -zxvf apache-tomcat-9.0.10.tar.gz 3、执行 进入bin目录 cd /usr/java/tomcat9/bin 启动 ./startup.sh 1234567[root@localhost bin]# ./startup.sh Using CATALINA_BASE: /usr/java/tomcat9Using CATALINA_HOME: /usr/java/tomcat9Using CATALINA_TMPDIR: /usr/java/tomcat9/tempUsing JRE_HOME: /usr/java/jdk1.8.0_181/jreUsing CLASSPATH: /usr/java/tomcat9/bin/bootstrap.jar:/usr/java/tomcat9/bin/tomcat-juli.jarTomcat started. 访问服务器ip地址 服务器ip:8080 4、tomcat启动后外网无法访问iptables防火墙设置参考文章地址：CentOS7.4 关闭firewall防火墙，改用iptablesCentOS之——CentOS7安装iptables防火墙 查看防火墙状态 1service iptables status 添加8080端口允许外网访问 1/sbin/iptables -I INPUT -p tcp --dport 8080 -j ACCEPT 保存规则设定 1service iptables save 重启防火墙 1service iptables restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】CentOS7下安装JDK详细过程]]></title>
    <url>%2F%E3%80%90Linux%E3%80%91CentOS7%E4%B8%8B%E5%AE%89%E8%A3%85JDK%E8%AF%A6%E7%BB%86%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[Linux上一般会安装Open JDK,关于OpenJDK和JDK的区别：【JDK和Open JDK】平常使用的JDK和Open JDK有什么区别。 1、卸载系统自带的OpenJDK以及相关的java文件1.1 在命令窗口键入：1java -version 可以看到系统自带的OpenJDK版本信息。 1.2 在命令窗口键入：1rpm -qa | grep java 命令说明： rpm 管理套件 -qa 使用询问模式，查询所有套件 grep 查找文件里符合条件的字符串 java 查找包含java字符串的文件 以上文件中：下面这几个可以删除 java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64 java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64 java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64 java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64 以下文件可以不用删除 python-javapackages-3.4.1-11.el7.noarch tzdata-java-2016g-2.el7.noarch javapackages-tools-3.4.1-11.el7.noarch 1.3 在命令窗口键入：1su 输入密码，进入超级用户角色 1.4 在命令窗口键入：1234rpm -e --nodeps java-1.7.0-openjdk-1.7.0.111-2.6.7.8.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.8.0-openjdk-headless-1.8.0.102-4.b14.el7.x86_64rpm -e --nodeps java-1.7.0-openjdk-headless-1.7.0.111-2.6.7.8.el7.x86_64 命令介绍： rpm 管理套件 -e 删除指定的套件 --nodeps 不验证套件档的相互关联性 1.5 检查是否已经删除成功在命令窗口键入： 1java -version 代表已经删除成功了。 2、安装 Sun JDK【注意】:JDK安装在哪个用户下，就是给哪个用户使用 2.1 下载当前最新版本下载地址：http://www.oracle.com/technetwork/java/javase/downloads/index.html历史版本下载地址： http://www.oracle.com/technetwork/java/javase/archive-139210.html 在命令窗口键入： 1wget http://download.oracle.com/otn-pub/java/jdk/8u181-b13/96a7b8442fe848ef90c96a2fad6ed6d1/jdk-8u181-linux-x64.tar.gz?AuthParam=1531986242_deb391e0a43953c12051f2d1eae8afad 或者windows下载后，使用xftp工具上传到Linux服务器。 2.2 解压将jdk-8u181-linux-x64.tar.gz文件拷贝一份到/usr/java 1cp jdk-8u181-linux-x64.tar.gz /usr/java 进入 /usr/java 目录，解压 12cd /usr/javatar -zxvf jdk-8u181-linux-x64.tar.gz 2.3 配置环境变量使用vim /etc/profile 编辑profile文件 1vim /etc/profil 向文件里面追加以下内容： 123456#set java environmentJAVA_HOME=/usr/java/jdk1.8.0_181JRE_HOME=$JAVA_HOME/jrePATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binCLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/libexport JAVA_HOME JRE_HOME PATH CLASSPATH 注释： JAVA_HOME指明JDK安装路径，就是刚才安装时所选择的路径，此路径下包括lib，bin，jre等文件夹（tomcat，Eclipse的运行都需要依靠此变量）。 CLASSPATH为java加载类(class or lib)路径，只有类在classpath中，java命令才能识别，设：.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib。CLASSPATH变量值中的.表示当前目录 PATH使得系统可以在任何路径下识别java命令，设为：$JAVA_HOME/bin:$JRE_HOME/bin。 特别注意：环境变量值的结尾没有任何符号，不同值之间用:隔开（windows中用;）。 2.4 使配置文件生效在命令窗口键入： 1source /etc/profile 2.5 测试配置是否成功在命令窗口键入： 1java -version 如下显示，则配置成功 1234[root@localhost java]# java -versionjava version &quot;1.8.0_181&quot;Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo博客关联域名，部署到coding]]></title>
    <url>%2Fhexo%E5%8D%9A%E5%AE%A2%E5%85%B3%E8%81%94%E5%9F%9F%E5%90%8D%EF%BC%8C%E9%83%A8%E7%BD%B2%E5%88%B0coding.html</url>
    <content type="text"><![CDATA[使用了一段时间在github上搭建的hexo个人博客空间，使用markdown写博客既方便，展示出来的样式也还算满意，唯一的缺点就是域名 github.io 总觉得有点累赘，另外就是访问速度比较慢，今天就试着来解决这两个：把访问域名替换成自己的域名,访问站点指向国内的coding.net 1、购买一个私人域名阿里云域名推荐引擎，根据自己的需求购买一个专属域名，以本人域名为例：greateman.top 2、Coding上建库2.1 注册Coding.net账号打开Coding.net官网，注册一个个人账号 2.2 新建项目注意项目名与注册用的账户名一致，这里我用的是 kevinXiao2016 2.3 添加公钥上面设置完毕之后点击创建项目，然后点击设置-&gt;部署公钥-&gt;新建部署公钥，之前部署到Github上的时候，本地目录 C\User(中文为用户)(电脑用户名).ssh 目录下会有 github.rsa.pub 公钥文件，打开然后复制里面的内容，直接贴在这里的公钥框中： 记得要勾选 授予推送权限 ，否则在后面运行hexo d时会提示错误： Coding.net Tips : [Deploy key is not allowed to push!] fatal: Could not read from remote repository. 原因就是没有推送权限。 打开Git命令窗口Git Bash，输入一下指令： 1ssh -T git@git.coding.NET 假如出现以下输出结果，表示公钥绑定成功： 1234xy@xy-PC MINGW64 ~$ ssh -T git@git.coding.NETCoding 提示: Hello kevinXiao2016, You&apos;ve connected to Coding.net via SSH. This is a deploy key.kevinXiao2016，你好，你已经通过 SSH 协议认证 Coding.net 服务，这是一个部署公钥 2.4 绑定个人域名点击设置-&gt;Pages服务，绑定自己购买的域名。 2.5 解析域名登陆阿里云 如红框中所示，添加两条记录，记录值处的ip为 coding上仓库的ip，可以ping 仓库地址得到，仓库地址为 用户名.coding.me 3、修改hexo配置3.1 关联coding仓库打开hexo本地的配置文件 _config.yml，修改 deploy 的配置内容，这里设置了运行hexo d之后部署的目的地址，原本只有Github地址，现在添加多Coding.net的地址，其中kevinXiao2016是注册该平台的 用户名： 3.2 创建Statifile在source目录下新建一个文件，命名为Statifile，不带文件后缀。 3.3 部署博客打开命令行窗口，定位到当前hexo项目的根目录下，运行以下指令将本地博客部署到Github和Coding.net上： 1hexo clean &amp;&amp; hexo d -g 假如提交成功，在命令行会输出： 4、访问一切准备完毕，此时便可以通过域名访问博客啦。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Linux】Centos7下安装Nginx]]></title>
    <url>%2F%E3%80%90Linux%E3%80%91Centos7%E4%B8%8B%E5%AE%89%E8%A3%85Nginx.html</url>
    <content type="text"><![CDATA[Nginx 是 C语言 开发，建议在 Linux 上运行，当然，也可以安装 Windows 版本，本篇则使用 CentOS 7 作为安装环境。 1、配置环境 gcc 安装安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装： 1yum install -y gcc-c++ PCRE pcre-devel 安装PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令： 1yum install -y pcre pcre-devel zlib 安装zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。 1yum install -y zlib zlib-devel OpenSSL 安装OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。 1yum install -y openssl openssl-devel 2、安装Nginx 下载.tar.gz 1wget -c https://nginx.org/download/nginx-1.14.0.tar.gz 解压 12tar -zxvf nginx-1.14.0.tar.gz cd nginx-1.14.0 配置 3.1 使用默认配置 1./configure 3.2 自定义配置（推荐） ./configure \ --prefix=/usr/local/nginx \ --conf-path=/usr/local/nginx/conf/nginx.conf \ --pid-path=/usr/local/nginx/conf/nginx.pid \ --lock-path=/var/lock/nginx.lock \ --error-log-path=/var/log/nginx/error.log \ --http-log-path=/var/log/nginx/access.log \ --with-http_gzip_static_module \ --http-client-body-temp-path=/var/temp/nginx/client \ --http-proxy-temp-path=/var/temp/nginx/proxy \ --http-fastcgi-temp-path=/var/temp/nginx/fastcgi \ --http-uwsgi-temp-path=/var/temp/nginx/uwsgi \ --http-scgi-temp-path=/var/temp/nginx/scgi &lt;font color=&quot;red&quot;&gt;注意：上边将临时文件目录指定为/var/temp/nginx，需要在/var下创建temp及nginx目录&lt;/font&gt; 1mkdir -p /var/temp/nginx 编译安装 1234&lt;!--编译--&gt;make&lt;!--安装--&gt;make install 开启pid-path 1234567891011&lt;!--进入安装目录--&gt;cd /usr/local/nginx&lt;!--编辑nginx.conf--&gt;vi conf/nginx.conf&lt;!--开启pid，并设值--&gt;pid /usr/local/nginx/logs/nginx.pid;&lt;!--创建目录--&gt;mkdir /usr/local/nginx/logs 3、启动Nginx 启动 1/usr/local/nginx/sbin/nginx 停止 1/usr/local/nginx/sbin/nginx -s stop 推荐下面这条命令： 1/usr/local/nginx/sbin/nginx -s quit 重启 1/usr/local/nginx/sbin/nginx -s reload 配置文件位置 1/usr/local/nginx/sbin/nginx -t 4、开机启动参照这篇文章：CentOS7+Nginx设置Systemctl restart nginx.service服务 启动nginx服务 systemctl start nginx.service 设置开机自启动 systemctl enable nginx.service 停止开机自启动 systemctl disable nginx.service 查看服务当前状态 systemctl status nginx.service 重新启动服务 systemctl restart nginx.service 查看所有已启动的服务 systemctl list-units --type=service 5、问题汇总 window无法访问虚拟机的nginx服务 首先确认windows是否能ping通linux，确认可以的情况下，很有可能是linux的防火墙开启且屏蔽了80端口。参照 CentOS7.4 关闭firewall防火墙，改用iptables 这篇文章设置，改用iptables，并放开80端口。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IDEA永久破解]]></title>
    <url>%2FIDEA%E6%B0%B8%E4%B9%85%E7%A0%B4%E8%A7%A3.html</url>
    <content type="text"><![CDATA[此方法永久破解，有效期到2099年12月31日。 从 http://idea.lanyus.com/ 下载最新的破解补丁。 类似这个链接：http://idea.lanyus.com/jar/JetbrainsCrack-2.8-release-enc.jar 将下载好的jar文件，拷贝到idea安装目录的bin目录下 添加启动参数： -javaagent:D:\Program Files\JetBrains\IntelliJ IDEA 2017.3.2\bin\JetbrainsCrack-2.6.10-release-enc.jar 启动idea，填写acrivation code 123456789101112131415161718192021222324ThisCrackLicenseId-&#123; “licenseId”:”ThisCrackLicenseId”, “licenseeName”:”授权用户名”, “assigneeName”:”“, “assigneeEmail”:”签名邮箱@163.com”, “licenseRestriction”:”For This Crack, Only Test! Please support genuine!!!”, “checkConcurrentUse”:false, “products”:[ &#123;“code”:”II”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”DM”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”AC”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”RS0”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”WS”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”DPN”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”RC”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”PS”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”DC”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”RM”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”CL”,”paidUpTo”:”2099-12-31”&#125;, &#123;“code”:”PC”,”paidUpTo”:”2099-12-31”&#125; ], “hash”:”2911276/0”, “gracePeriodDays”:7, “autoProlongated”:false&#125; 参考：IntelliJ IDEA 2017.3.2永久破解版]]></content>
      <categories>
        <category>乱七八糟</category>
      </categories>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Quartz学习]]></title>
    <url>%2FQuartz%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[Quartz是一个开源的作业调度框架，可以让计划的任务在一个预先设计好的日期和时间运行。Quartz可以用来创建简单或复杂的日程安排执行几十，几百，甚至是十万的作业数，支持集群。 1、核心类简介调度器：Scheduler quartz的核心大脑，调度中心，包含两个重要的组件：JobStore、ThreadPool JobStore:存储器，用来存储运行时的信息，包括Trigger、JobDetail、Schduler、业务锁等，有以下几种实现： RAMJob（内存实现） JobStoreTX(JDBC实现，事务由quartz管理) JobStoreCMT(JDBC实现，事务由容器管理) ClusteredJobStore(集群实现) TerracottaJobStore(什么是Terractta) 任务：JobDetail &amp; Job JobDetail是任务的定义，而Job是任务的执行逻辑。在JobDetail里会引用一个Job Class定义，还有一个JobDetailMap存储结构。 Job是具体的任务执行逻辑，JobDetailMap是同一个JobDetail实例化的Job共享的存储器。 触发器：Trigger 定义Job何时执行，理解为定时触发，有以下几种实现： SimpleTrigger:指定从某一个时间开始，以一定的时间间隔（单位是毫秒）执行的任务。 CalendarIntervalTrigger:类似于SimpleTrigger，指定从某一个时间开始，以一定的时间间隔执行的任务。 但是不同的是SimpleTrigger指定的时间间隔为毫秒，没办法指定每隔一个月执行一次（每月的时间间隔不是固定值），而CalendarIntervalTrigger支持的间隔单位有秒，分钟，小时，天，月，年，星期。 DailyTimeIntervalTrigger:指定每天的某个时间段内，以一定的时间间隔执行任务。并且它可以支持指定星期。 CronTrigger:适合于更复杂的任务，它支持类型于Linux Cron的语法（并且更强大）。基本上它覆盖了以上三个Trigger的绝大部分能力（但不是全部）—— 当然，也更难理解。 2、RAMJob方式的简单应用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.topvision.quartz;import org.quartz.JobDetail;import org.quartz.Scheduler;import org.quartz.SchedulerException;import org.quartz.SimpleTrigger;import org.quartz.impl.StdSchedulerFactory;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.util.Date;import static org.quartz.JobBuilder.newJob;import static org.quartz.SimpleScheduleBuilder.simpleSchedule;import static org.quartz.TriggerBuilder.newTrigger;public class JdbcStoreTest &#123; private static Logger logger = LoggerFactory.getLogger(JdbcStoreTest.class); public static void main(String[] args) throws SchedulerException &#123; /*创建调度器*/ Scheduler scheduler = new StdSchedulerFactory("quartz.properties").getScheduler(); /*创建JobDetail*/ JobDetail jobDetail = newJob(MyJob.class).withIdentity("jobkey1", "jobgroup").build(); /*创建触发器*/ SimpleTrigger trigger = newTrigger().withIdentity("trikey2", "trigroup") .startNow() .withSchedule(simpleSchedule().withIntervalInSeconds(3).withRepeatCount(3)) .build(); /*绑定*/ scheduler.scheduleJob(jobDetail, trigger); /*开启*/ scheduler.start(); logger.info("启动时间：" + new Date()); try &#123; Thread.sleep(6*1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; scheduler.shutdown(); &#125;&#125; 1234567891011121314151617181920212223242526package com.topvision.quartz;import org.quartz.Job;import org.quartz.JobExecutionContext;import org.quartz.JobExecutionException;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.SimpleDateFormat;import java.util.Date;public class MyJob implements Job &#123; private Logger logger = LoggerFactory.getLogger(MyJob.class); public void execute(JobExecutionContext jobExecutionContext) throws JobExecutionException &#123; System.out.println("MyJob is start .................."); System.out.println("Hello quzrtz " + new SimpleDateFormat("yyyy-MM-dd HH:mm:ss ").format(new Date())); System.out.println("MyJob is end ....................."); &#125;&#125; 详细用法参考 Quartz学习——Quartz大致介绍——阿飞(dufyun)的博客]]></content>
      <categories>
        <category>框架</category>
      </categories>
      <tags>
        <tag>quartz</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[1、懒汉式123456789101112131415public class Demo1 &#123; private Demo1() &#123; super(); &#125; private static Demo1 instance = null; public static Demo1 getSingleton() &#123; if (null == instance) &#123; instance = new Demo1(); &#125; return instance; &#125;&#125; 2、饿汉式1234567891011121314public class Demo2 &#123; private Demo2() &#123; super(); &#125; private static Demo2 instance = new Demo2(); public static Demo2 getSingleton() &#123; return instance; &#125;&#125; 为什么这样写呢？我们来解释几个关键点： 要想让一个类只能构建一个对象，自然不能让它随便去做new操作，因此Demo1的构造方法是私有的 instance是Singleton类的静态成员，也是我们的单例对象。它的初始值可以写成Null，也可以写成new Singleton()。至于其中的区别后来会做解释。 getInstance是获取单例对象的方法。 如果单例初始值是null，还未构建，则构建单例对象并返回。这个写法属于单例模式当中的懒汉模式。 如果单例对象一开始就被new Singleton()主动构建，则不再需要判空操作，这种写法属于饿汉模式。 3、双重验证1234567891011121314151617181920public class Demo3 &#123; public Demo3() &#123; super(); &#125; private volatile static Demo3 instance = null; // volatile 禁止了指令重排 public Demo3 getSingleton() &#123; if (null == instance) &#123; synchronized (Demo3.class) &#123; // 同步锁 if (null == instance) &#123; instance = new Demo3(); &#125; &#125; &#125; return instance; &#125;&#125; 为什么这样写呢？我们来解释几个关键点： 为了防止new Demo3被执行多次，因此在new操作之前加上Synchronized 同步锁，锁住整个类（注意，这里不能使用对象锁）。 进入Synchronized 临界区以后，还要再做一次判空。因为当两个线程同时访问的时候，线程A构建完对象，线程B也已经通过了最初的判空验证，不做第二次判空的话，线程B还是会再次构建instance对象。 volatile 禁止了指令重排 4、静态内部内123456789101112131415public class Demo4 &#123; private Demo4() &#123; super(); &#125; private static class LazyHolder &#123; private static final Demo4 INSTANCE = new Demo4(); &#125; public static Demo4 getSingleton() &#123; return LazyHolder.demo4; &#125;&#125; 这里有几个需要注意的点： 从外部无法访问静态内部类LazyHolder，只有当调用Demo4.getInstance方法的时候，才能得到单例对象INSTANCE。 INSTANCE对象初始化的时机并不是在单例类Demo4被加载的时候，而是在调用getInstance方法，使得静态内部类LazyHolder被加载的时候。因此这种实现方式是利用classloader的加载机制来实现懒加载，并保证构建单例的线程安全。 可能被反射打破单例的约束 5、枚举1234567891011121314public enum Demo5 &#123; demo5; private Object obj = null; private Demo5() &#123; obj = new Object(); &#125; public Object getSingleton() &#123; return obj; &#125;&#125; 使用枚举实现的单例模式，不但可以防止利用反射强行构建单例对象，而且可以在枚举类对象被反序列化的时候，保证反序列的返回结果是同一对象。 对于其他方式实现的单例模式，如果既想要做到可序列化，又想要反序列化为同一对象，则必须实现readResolve方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile的实现原理]]></title>
    <url>%2Fvolatile%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html</url>
    <content type="text"><![CDATA[1、特性 保证变量在线程之间的可见性 通过内存屏障来阻止指令重排，是happens-before规范的具体的一种实现 解决了long类型和double类型数据的8字节赋值问题 2、可见性JMM(Java Memeory Model)是JVM定义的一种抽象规范，用来屏蔽不同硬件和操作系统的内存访问差异。 主内存：简单理解为计算机当中的内存，但并不完全等同。被所有线程共享，存储着共享变量的“本尊”。 工作内存：简单理解为计算机当中的CPU高速缓存，但又不完全等同。每一个线程拥有自己的工作内存，对于一个共享变量来说，工作内存当中存储了它的“副本”。 线程对共享变量的所有操作都必须在工作内存进行，不能直接读写主内存中的变量。不同线程之间也无法访问彼此的工作内存，变量值的传递只能通过主内存来进行。 当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，当其他线程读取共享变量时，它会直接从主内存中读取。当然，synchronize和锁都可以保证可见性。 3、有序性在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序它不会影响单线程的运行结果，但是对多线程会有影响。 Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。 happen-before 同一个线程中的，前面的操作happen-before后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。 监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则） 对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则） 线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则） 线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。 如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。 重点关注第3条，使用volatile修饰的变量，在指令重排时，会产生额外的lock前缀指令，也就是内存屏障。 4、局限性及使用场景 局限性 不能保证原子性 场景 运行结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 不参与多个volatile变量的不变约束。 参考 【死磕Java并发】—–深入分析volatile的实现原理 漫画：什么是volatile关键字？（整合版）]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Java本身给我们提供了静态代理和动态代理两种代理方式，spring提供了基于类的代理方式：cglib. 在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。这种类型的设计模式属于结构型模式。在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。 1、介绍意图：为其他对象提供一种代理，从而控制对这个对象的访问。 主要解决：在直接访问对象时带来的问题。 关键代码：实现与被代理类的组合。 优点： 职责清晰，高扩展性，智能化。 建立一套触发机制。 缺点： 增加了代理对象，某些情况下会造成请求的处理速度变慢 需要额外的编码，某些情况实现很复杂 注意事项 与适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 与装饰着模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。 2、静态代理静态代理：代理类在程序运行前就已存在，即人为的编写代理类代码。代理类与委托类实现同一接口或派生自相同的父类。 以下是静态代理的简单实现：123public interface House &#123; void sayHi();&#125; 12345678public class HouseImpl implements House &#123; @Override public void sayHi() &#123; System.out.println("welcome to my house!"); &#125;&#125; 123456789101112131415public class ProxyHouse implements House &#123; private House house; public ProxyHouse(House house) &#123; this.house = house; &#125; @Override public void sayHi() &#123; System.out.println("I'm proxy"); house.sayHi(); &#125;&#125; 1234567public static void main(String[] args) &#123; House h = new HouseImpl(); h.sayHi(); h = new ProxyHouse(h); h.sayHi();&#125; 可以实现客户与委托类之间的解耦，在不修改委托类的前提下能够做一些额外的处理。静态代理的局限在于运行前必须编写好代理类，且针对每个需要代理方法都必须单独实现。 3、动态代理动态代理：在程序运行时创建的代理方式，即代理类是动态生成的，而不是提前编写的。相比于静态代理，动态代理可以很方便的对代理类进行统一处理，而不用修改每个代理类的函数，常用于权限控制、日志记录等场景。 约束：委托类必须实现接口。 以下是动态代理的简单实现：在对某个类的一个方法的调用前和调用后都要做一下日志操作 1234//一个普通的接口public interface House &#123; void sayHi();&#125; 123456789//委托类，需要增加日志的类public class HouseImpl implements House &#123; @Override public void sayHi() &#123; System.out.println("welcome to my house!"); &#125;&#125; 123456789101112131415161718//动态代理的中介类，关键public class DynamicProxy implements InvocationHandler &#123; private Object obj;//目标对象的引用，这里设计成Object类型，更具通用性 public DynamicProxy(Object obj) &#123; this.obj = obj; &#125; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println("方法执行前"); Object res = method.invoke(obj, args);//调用目标对象的方法 System.out.println("方法执行后"); return res; &#125;&#125; 12345678910public static void main(String[] args) &#123; House h = new HouseImpl(); //创建中介类,代理了委托类 DynamicProxy dynamicProxy = new DynamicProxy(h); //获取代理类实例，代理了中介类 House instance = (House)Proxy.newProxyInstance(House.class.getClassLoader(), new Class[]&#123;House.class&#125;, dynamicProxy); //代理对象调用方法 instance.sayHi(); &#125; Java的动态代理，实际上是两次静态代理的组合。动态代理的重点是中介类的实现，需要实现java.lang.reflect.InvocationHandler接口。 动态代理与静态代理的区别： Proxy类的代码被固定下来，不会因为业务的逐渐庞大而庞大； 可以实现AOP编程，这是静态代理无法实现的； 解耦，如果用在web业务下，可以实现数据层和业务层的分离； 动态代理的优势就是实现无侵入式的代码扩展。静态代理这个模式本身有个大问题，如果类方法数量越来越多的时候，代理类的代码量是十分庞大的。所以引入动态代理来解决此类问题 4、CGLIB在Spring AOP中，通常会用它来生成AopProxy对象。不仅如此，在Hibernate中PO(Persistant Object 持久化对象)字节码的生成工作也要靠它来完成。 以下是简单实现： 1234567//一个普通类，委托类public class HelloServiceImpl &#123; void sayHello() &#123; System.out.println("I'm helloServiceImpl"); &#125;&#125; 123456789101112//实现MethodInterceptor接口，回调函数，是增强方法的具体实现public class CglibCallBack implements MethodInterceptor &#123; @Override public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable &#123; System.out.println("before"); Object invokeSuper = proxy.invokeSuper(obj, args); System.out.println("after"); return invokeSuper; &#125;&#125; 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; Enhancer enhancer = new Enhancer(); //设置委托类 enhancer.setSuperclass(HelloServiceImpl.class); //设置回调，即增强实现的类 enhancer.setCallback(new CglibCallBack()); //创建代理类 HelloServiceImpl helloService = (HelloServiceImpl)enhancer.create(); //执行方法 helloService.sayHello(); &#125;&#125; 小结： 生成的代理类 HelloServiceImpl\$\$EnhancerByCGLIB$$1a4d04e8@32e6e9c3 继承委托类 HelloServiceImpl。注意：如果委托类被final修饰，那么该类不可被继承，也就不能被代理；同样，如果方法被final修饰，该方法也不可被代理。 代理类会为委托类的委托方法生成两个方法，一个是重写的sayHello()方法，另一个是CGLIB\$sayHello$()方法，直接调用父类的方法。执行代理方法时，先判断是否存在实现MethodInterceptor接口的回调类对象，如果存在，则调用MethodInterceptor中的intercept方法，否则调用父类方法（不代理）。 cglib中的方法调用不是通过反射实现的，而是直接的方法调用。有一个数组存放着方法的引用。 5、三者对比 代理方式 实现 优点 缺点 特点 JDK静态代理 代理类与委托类实现同一接口，并且在代理类中需要硬编码接口 实现简单，容易理解 代理类需要硬编码接口，在实际应用中可能会导致重复编码，浪费存储空间并且效率很低 好像没啥特点 JDK动态代理 代理类与委托类实现同一接口，主要是通过代理类实现InvocationHandler并重写invoke方法来进行动态代理的，在invoke方法中将对方法进行增强处理 不需要硬编码接口，代码复用率高 只能够代理实现了接口的委托类 底层使用反射机制进行方法的调用 CGLIB动态代理 代理类将委托类作为自己的父类并为其中的非final委托方法创建两个方法，一个是与委托方法签名相同的方法，它在方法中会通过super调用委托方法；另一个是代理类独有的方法。在代理方法中，它会判断是否存在实现了MethodInterceptor接口的对象，若存在则将调用intercept方法对委托方法进行代理 可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口 不能对final类以及final方法进行代理 底层将方法全部存入一个数组中，通过数组索引直接进行方法调用 参考 深入理解CGLIB动态代理机制 深入理解JDK动态代理机制]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机：类加载器]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8.html</url>
    <content type="text"><![CDATA[虚拟机把描述类的数据从Class字节码文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。 1、类加载的时机类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载(Loading)、验证、准备、解析、初始化、使用、卸载7个阶段，其中验证、准备、解析3个部分统称为连接，发生顺序如下图所示： 加载、验证、准备、初始化、卸载这5个阶段的顺序是固定的，而解析则不一定：它在某些情况下可以在初始化之后再开始，这是为了支持Java的运行时绑定(也成动态绑定或晚期绑定)。 那么何时开始第一阶段加载呢？虚拟机规范没有强制约束，由虚拟机具体实现自由把握。但初始化阶段，有且仅有5种情况必须立即初始化： 遇到new、getstatic、putstatic、invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这四条指令的最常见的Java代码场景:使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用时，如果类没有初始化，则需先触发其初始化。 当初始化一个类时，若其父类还没有进行初始化，则需要先触发其父类初始化。 当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个主类。 当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果是REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄对应的类没有初始化，则需要先触发其初始化。 2、类加载器虚拟机团队吧类加载阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。 类加载器虽然只用于实现类的加载动作，但它的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都有一个独立的命名空间。也就是说：比较两个类是否“相等”，只有在这两个类由同一个类加载器加载的前提下才有意义，否则，即使是来源于同一个Class文件，被同一个JVM加载，只要加载它们的类加载器不同，那么这两个类就必不相等。 类加载器的分类： 启动类加载器(Bootstrap ClassLoader):负责加载\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的能被识别的类库。 扩展类加载器(Extension ClassLoader):负责加载\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用该加载器。 应用程序加载器(Application ClassLoader):由ClassLoader中的getSystemClassLoader()方法获得，负责加载用户路径(classpath)上的类库。若果没有自定义加载器，一般情况下这就是程序的默认类加载器。 双亲委派机制： 除启动类加载器外，器与类加载器都应有自己的父类。 若果一个类收到类加载的请求，它首先不会自己去加载，而是委派给父类加载器去完成，依次往上，因此所有的加载请求最终都会传递到顶层的启动类加载器。只有当父类反馈自己无法加载，子类才会尝试去加载。 这样做的好处： 使类加载器具备了优先级的层次关系，保证了同一个类始终是由同一个类加载器完成加载。]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java虚拟机：内存模型]]></title>
    <url>%2FJava%E8%99%9A%E6%8B%9F%E6%9C%BA%EF%BC%9A%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[Java虚拟机是Java程序运行的真实环境，要深入理解Java是如何运行的，理解Java虚拟机是必不可少的。典型的例子：内存溢出。当我们理解java虚拟机之后，我们就会明白为何会出现这个问题，我们又当如何去定位并解决这个问题。 1、JVM内存分布通常我们说的JVM内存分布即指运行时数据区。下图为分布概念图： 1.1 堆(Heap) 被所有线程共享的一块内存区域，在虚拟机启动时创建 用来存贮对象实例 可以通过-Xmx和-Xms控制堆的大小 OutOfMemoryError异常：当在堆中没有内存完成实例分配，且堆也无法再扩展时 Java堆是垃圾回收器的主要工作区域。由于现在垃圾收集器采用的基本都是分代收集算法，所以堆还可以细分为新生代(New/Young)和老年代(Old/Tenured)，再细致一点还有Eden区、From Survivior区、To Survivor区。 新生代：新建的对象都由新生代分配内存。常常又被划分为Eden区和Survivor区，Eden空间不足时会把存活的对象转移到Survivor。新生代的大小可有-Xmn控制，也可用-XX:SurvivorRatio控制Eden和Survivor的比例。 老年代：存放经过多次垃圾回收仍然存活的对象。 1.2 方法区(Method Area) 线程间共享 用来存储已被虚拟机加载的类信息、常量、静态变量、即时编译器变异后的代码等数据 OutOfMemoryError异常：当方法区无法满足内存的分配需求时 运行时常量池： 方法区的一部分 用于存放编译期生成的各种字面量和符号引用，如String类型常量就存放在常量池 OutOfMemoryError异常：当常量池无法再申请到内存时 1.3 程序计数器(Program Counter Register) 当前线程所执行的字节码的行号指示器 当前线程私有 不会出现OutOfMemoryError 如果线程执行是一个Java方法的时候，计数器记录的是虚拟机字节码指令的地址；当执行的是Native的方法的时候，计数器指令为空 1.4 虚拟机栈(VM Stack) 线程私有，生命周期与线程相同 存储方法的局部变量表(局部变量、对象引用和返回地址等)、操作数栈、动态链接、方法出口等信息 Java方法执行的呢内存模型，每个方法执行的同时都会创建一个栈帧，每一个方法被调用直至完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。 StackOverflowError异常:当线程请求的栈深度大于虚拟机所允许的深度 OutOfMemoryError异常：如果栈的扩展时无法申请到足够的内存 JVM栈是线程私有的，每个线程创建的同时都会创建JVM栈。 这里解释一下局部变量表，局部变量表存储方法相关的局部变量，包括基本数据，对象引用和返回地址等。在局部变量表中，只有long和double类型会占用2个局部变量空间（Slot，对于32位机器，一个Slot就是32个bit），其它都是1个Slot。需要注意的是，局部变量表是在编译时就已经确定好的，方法运行所需要分配的空间在栈帧中是完全确定的，在方法的生命周期内都不会改变。 1.5 本地方法栈(Native Method Stack)与虚拟机栈类似，唯一的区别就是虚拟机栈是执行Java方法的，本地方法栈是执行native方法的。 在HotSpot虚拟机中直接把本地方法栈与虚拟机栈二合一 1.6 直接内存(Direct Memory) 直接内存并不是虚拟机运行的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁使用. NIO可以使用Native函数库直接分配堆外内存，堆中的DirectByteBuffer对象作为这块内存的引用进行操作 大小不受Java堆大小的限制，受本机(服务器)内存限制 OutOfMemoryError异常：系统内存不足时 1.7 永久代(PermGen)的发展方法区是JVM的规范，是一个逻辑存储区域。永久代是JVM规范的一种实现，并且永久代是HotSpot特有的。 JDK 1.6 永久代即方法区，存储着类信息、常量、静态变量、JIT编译的代码等 JDK 1.7 符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap JDK 1.8 不存在永久代，取而代之的是元空间(MetaSpace)。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制。 那么，为什么要做出这些转变呢？有以下几点原因： 字符串存在永久代中，容易出现性能问题和内存溢出。 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。 Oracle 可能会将HotSpot 与 JRockit 合二为一。 关于PermGen和Metaspace，可以看下liuxiaopeng的博客。 1.8 小结Java对象实例存放在堆中；常量存放在方法区的常量池；虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据放在方法区；以上区域是所有线程共享的。栈是线程私有的，存放该方法的局部变量表(基本类型、对象引用)、操作数栈、动态链接、方法出口等信息。 一个Java程序对应一个JVM，一个方法（线程）对应一个Java栈。 2、对象访问方式Java对象这里指的是引用类型的对象，这里用Student stu=new Student()为例子访问，Student stu作为引用对象，存在与Java虚拟机栈上，new Student()保存在Java堆中，堆中记录Student类型的信息包括方法，接口，对象类型等地址，这些类型的执行的数据存储在方法区中。 2.1 句柄访问Java堆中分配一块句柄池，虚拟机栈中存放句柄池中的地址，句柄池中包括对象示例数据和对象类型数据的地址。 2.2 直接指针访问对象中存贮着对象实例数据和类数据的地址，Java栈的引用指向堆中的对象。 2.3 小结这两种访问方式各有优势。 句柄访问： reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身是不需要修改的。 直接指针访问：最大的好处是速度快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常的频繁，因此这类开销积少成多也是非常可观的执行成本。 就HotSpot虚拟机来说，它采用的是直接指针访问。但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也是十分常见的。 3、哪些对象需要回收？Java运行时数据区的几大板块中，程序计数器、虚拟机栈、本地方法栈3个区域随着线程而生，随着线程而灭，因此这几个区域的内存分配和回收都具备确定性，在这3个区域不需要过多的考虑GC问题。而堆和方法区则不一样，我们只有在程序运行期间才能知道会创建哪些对象、占用多少内存，这部分内存的分配和回收都是动态的，垃圾收集器关注的也正是这部分内存。 堆中存放着几乎所有的对象实例，在垃圾收集之前，需要判断哪些对象需要被除了，即哪些对象“存活”着，哪些对象已经“死去”。 3.1 引用计数算法给对象中添加一个引用计数器，每当有一个地方引用该对象，计数器值就加1，当引用失效时,引用就减1。任何时刻计数器为0的对象就是不可能再被使用的。 缺陷：很难解决象之间互相循环引用的问题。 3.2 可达性算法主流语言(Java、C#)的主流实现，都是通过可达性算法判断对象是否存活。 基本思路：通过一系列成为”GC Roots”的对象作为起始点，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可达，所以它们就会被判定为可回收对象。 在Java中，可作为GC Roots的对象包括下面几种： 虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈JNI（即一般说的Native方法）引用的对象 3.3 再谈引用在JDK1.2以前，Java中的引用定义很传统：如果reference类型的数据中存储的数值代表着另一块内存的起始地址，就称这块内存代表着一个引用。这种定义很纯粹，但很狭隘，在这种定义下，对象只存在被引用和没有被引用两种状态。我们希望描述这样一类对象：当空间内存足够时，则保留在内存中；如果内存在GC后还非常紧张，则可以抛弃这些对象。很多系统的缓存都符合这种引用场景。 在JDK1.之后，Java对引用概念进行了扩充，分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)，强度依次递减。 强引用：类似Object obj = new Object()，只要强引用还在，则不会被GC 软引用：描述一些还有用但非必须的对象。在系统将要发生内存溢出异常前，将会把这些软引用对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。 弱引用：也是描述一些非必须对象，但强度比软引用更弱一些。这些对象只能存活到下一次GC之前。当开始GC时，无论内存是否足够，这些对象都会被回收。 虚引用：不影响GC，唯一目的是被虚引用关联的对象被GC时能收到一个系统通知。 3.4 生存还是死亡即使在可达性分析算法中不可达的对象，也并不是“非死不可”，这时候他们处于缓刑状态，要真正宣布一个对象死亡，至少需要经过两次标记过程： 可达性分析后没有与GC Roots相连的引用链，它会被第一次标记并且进行一次筛选。 筛选条件是是否有必要执行finalize()方法。如果没有覆盖finalize()方法，或者finalize()已经被虚拟机调用过，这两种情况都被视为“没有必要执行”。如果判定为有必要执行finalize()方法，该对象被放置在一个F-Queue的队列中，并稍后由虚拟机建立的低优先级Finalizer线程去执行他，也就是触发对象的finalize()方法。finalize()是对象逃脱死亡的最后一次机会。 稍后GC将对F-Queue中的对象进行第二次小规模标记 如果对象在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，那么第二次标记时它将被移出“即将回收”的集合；如果第二次标记时还没有逃脱，那它基本上就真的会被回收了。 3.5 回收方法区方法区（或者HotSpot中的永久代）主要回收两部分：废弃常量和无用的类。 废弃常量 如果没有任何一个地方引用常量，在GC时如果有必要的话，该常量会被清理出常量池。常量池中的类（接口）、方法、字段的符号引用也是类似的。 无用的类 卸载类就很麻烦了，必须同时满足3个条件： 该类所有实例都已被回收 加载该类的ClassLoader已经被会后 该类对应的Class对象没有在任何地方呗引用，无法通过反射访问该类的方法 满足以上条件也只是可以被回收，是否被回收，HotSpot还有其他方法来控制。 4、何时回收？GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代，新生代还分为一个Eden区和两个Survivor区。 对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，Minor GC非常频繁，而且速度也很快； Full GC，发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。 JDK 6 Update 24之后,HandlePromotionFailure无效。只要老年代剩余连续空间大于新生代对象总和或者历次晋升的平均大小就会进行Minor GC，否则Full GC。发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小，如果大于，则进行一次Full GC，如果小于，则查看是否允许担保失败(HandlePromotionFailure=true/false)，如果允许，那只会进行一次Minor GC，如果不允许，则改为进行一次Full GC。 5、如何回收？简单描述几种算法的思路及演变过程 5.1 标记——清除算法分为“标记”和“清除”两个阶段： 标记：即前面提到过的，GC时两次标记的过程。 清除：统一回收被标记的对象 缺点： 效率不高：标记和清除的过程效率都不高 产生大量内存碎片：导致以后分配较大内存对象时，由于没有足够大的连续内存从而提前触发一次GC动作。 5.2 复制算法为了解决效率问题，出现了复制算法。将可用内存分为大小相等的两块，每次只是用其中一块。当这一块用完，将还存活的复制到另一块，然后再把使用过的内存空间一次清理掉，循环往复。 优点：不用考虑内存碎片，实现简单，运行高效 缺点： 内存缩小为原来的一半，代价太大； 需要额外的老年代空间进行分配担保 5.3 标记——整理算法分为“标记”和“整理”两个阶段： 标记：即前面提到过的，GC时两次标记的过程。 整理：让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。 5.4 分代收集算法当前商业虚拟机的垃圾收集都采用“分代收集算法”。 对于HotSpot虚拟机，堆内存分布如下图所示： 新生代中使用 复制算法，老年代使用 标记——整理算法 默认情况下，eden与survivor的大小比例是8:1,可由 -XX：SurvivorRatio=8 设置。所以可用新生代大小为新生代的90%。 以下是算法的基本思路： 对象新建时，首先会在Eden区创建，年龄为0，直到GC时，若没有消亡，则放入servivor区，年龄为1 进入survivor区也不是安全的，当下一次Minor GC来的时候，会检查Eden区和使用的Survivor区，若有对象存活，则放入另一个Survivor区，年龄加1 当两个Survivor区切换几次后，对象年龄增长到15(默认，-XX:MaxTenuringThreshold=15)，则进入老年代。 进入老年代也不是安全的，当老年代空间不足时，触发Major GC，已经消亡的对象还是会被干掉。 推荐一个这个写的很逗可以看下：http://blog.csdn.net/sd4015700/article/details/50109939]]></content>
      <categories>
        <category>Java虚拟机</category>
      </categories>
      <tags>
        <tag>Java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web.xml不同版本之间的差异]]></title>
    <url>%2Fweb-xml%E4%B8%8D%E5%90%8C%E7%89%88%E6%9C%AC%E4%B9%8B%E9%97%B4%E7%9A%84%E5%B7%AE%E5%BC%82.html</url>
    <content type="text"><![CDATA[Apache官方对各版本的解释：http://tomcat.apache.org/whichversion.html The web.xml is a configuration file to describe how a web application should be deployed. Here’re 5 web.xml examples, just for self-reference. Servlet 4.0 123456&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd" version="4.0" metadata-complete="true"&gt;&lt;/web-app&gt; Servlet 3.1 Java EE 7 XML schema, namespace is http://xmlns.jcp.org/xml/ns/javaee/ 123456 &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; version=&quot;3.1&quot;&gt; &lt;/web-app&gt; Servlet 3.0 Java EE 6 XML schema, namespace is http://java.sun.com/xml/ns/javaeeServlet3.0随J2EE6一起发布，web.xml配置文件中包含：默认页配置、session超时配置和错误提示页配置。 123456&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt;&lt;/web-app&gt; Servlet 2.5 Java EE 5 XML schema, namespace is http://java.sun.com/xml/ns/javaee2.5以上版本即可解决多个url不能映射到同一个servlet的问题。 123456&lt;web-app xmlns="http://java.sun.com/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" version="2.5"&gt;&lt;/web-app&gt; Servlet 2.4 J2EE 1.4 XML schema, namespace is http://java.sun.com/xml/ns/j2ee2.4以上版本即可解决上面问题。但是2.4及以下版本会有一个问题：（多个url不能映射到同一个servlet） 12345678&lt;web-app xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd" version="2.4"&gt;&lt;display-name&gt;Servlet 2.4 Web Application&lt;/display-name&gt;&lt;/web-app&gt; Servlet 2.3 J2EE 1.3 DTD模式。这个xml文件太旧了，强烈推荐你升级。这个有个缺点：web-app里的标签有一定的顺序。 1234567&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Servlet 2.3 Web Application&lt;/display-name&gt;&lt;/web-app&gt;]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql事务的隔离级别]]></title>
    <url>%2FMysql%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB.html</url>
    <content type="text"><![CDATA[隔离级别 脏读 不可重复读 幻读 read-unconmitted √ √ √ read-conmitted × √ √ repeatable-read × × √ serializable × × × 1、事务的基本要素(ACID) 原子性（Atomicity）：事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。 一致性（Consistency）：事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。 隔离性（Isolation）：同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。 持久性（Durability）：事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。 2、隔离级别 read-unconmitted 可以读到其他事务未提交的数据，是最低级别的事务隔离级别。 例如：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是错误的，称之为脏数据。 read-conmitted 为了解决脏读，就需要保证读取被事务提交的数据，也就是read-conmitted。 看一个例子： 事务A读一个数据，读到100. 此时另外一个线程执行事务B将数据改为200，并提交事务。 接下来事务A再次读该数据，读到200. 这种在一个事务中两次读取到数据不一致的情况，我们称之为不可重复读。 repeatable-read 为了解决不可重复读，就需要保证一个事务在操作一份数据时，不允许其他事务操作该数据。此时反应到数据库上，就是需要对行加锁。这种隔离级别称之为repeatable-read。 看一个例子： 事务A统计当天营业额（遍历表，计和），为1000. 事务B插入一条销售记录，200。 事务A再统计当天营业额，为1200. 这种一个事务中前后两次统计不一致的情况，称之为幻读。 serializable 为了解决幻读，只能严格要求所有线程的所有事务都按照顺序依次执行，也就是 表锁。 但是此种级别并发性太差，且一般也没有必要。 3、总结我们需要区分事务的隔离级别和现象。隔离级别是指导原则，现象是产生的问题，而数据库锁则是解决手段。 Mysql默认隔离级别是 repeatable-read。Oracle默认隔离级别是 read-conmitted。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql索引的简单使用]]></title>
    <url>%2FMysql%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[这篇记录了mysql中索引的简单使用方法，基本上满足大部分的开发需求。 1、索引是什么索引（Index）是帮助Mysql高效查询数据的一种数据结构，其本质：数据结构。 2、优势好比图书馆建立的书目索引，提高数据检索效率，降低数据库的IO成本。通过索引对数据库进行排序，降低数据排序的成本，降低CPU的消耗。 3、劣势索引也是一张表，该表保存了主键与索引片段，并指向实体表的记录，所以索引也是需要占用空间的。同时会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 4、分类 单列索引：即一个索引只包含一个列，一张表可以有多个单列索引。 唯一索引(UNIQUE)：索引列的值必须唯一，允许为空值。 全文索引(FULLTEXT)：仅用于MyISAM表。 组合索引(最左前缀): 多个列构成一个索引，适用于查询条件较复杂的情况。 最左前缀： mysql查询时只能使用一个索引。建立组合索引时，本质上同时建立了好几个索引，下面以实例讲解： 1ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age); 创建一个组合索引，相当于同时创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。 注：在创建多列索引时，要根据业务需求，where子句中使用最频繁的一列放在最左边。 虽然索引对顺序敏感，但是mysql优化器会自动调整where后面的条件顺序，来匹配合适的索引。 5、基本语法 创建索引 1CREATE [UNIQUE] INDEX indexName ON tableName(columnName(length)) 如果是CHAR，VARCHAR类型，length可以小于字段实际长度；如果是BLOB和TEXT类型，必须指定 length。 1ALTER TABLE tableName ADD INDEX indexName(columnName(length)) 修改表结构添加索引 12345CREATE TABLE mytable ( ID INT NOT NULL, username VARCHAR (16) NOT NULL, INDEX [ indexName ] (username(length))); 创建表的时候直接指定。 &gt; 使用ALTER 命令添加和删除索引： - ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): 该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。 - ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): 这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。 - ALTER TABLE tbl_name ADD INDEX index_name (column_list): 添加普通索引，索引值可出现多次。 - ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list): 该语句指定了索引为 FULLTEXT ，用于全文索引。 删除索引 1DROP INDEX [indexName] ON tableName 查看索引 1SHOW INDEX FROM table_name; 6、Mysql索引结构 BTree： 可以用于使用 =, &gt;, &gt;=, &lt;, &lt;= 或者 BETWEEN 运算符的列比较 如果 LIKE 的参数是一个没有以通配符起始的常量字符串的话也可以使用这种索引 Hash： 只能够用于使用 = 或者 &lt;=&gt; 运算符的相等比较(但是速度更快) 优化器不能够使用 hash 索引来加速 ORDER BY 操作 无法使用 hash 索引估计两个值之间有多少行 full-text：MyISAM的一个特殊索引类型，主要用于全文检索。 R-Tree：MyISAM支持空间索引，主要用于地理空间数据类型，例如GEOMETRY。 7、哪些情况需要创建索引 主键自动建立唯一索引 频繁作为查询条件的字段应该创建索引 查询中与其他表关联的字段，外键关系建立索引 单键/组合索引的选择问题，who?(在高并发下倾向创建组合索引) 查询中排序的字段，排序的字段若通过索引去访问将大大提高排序速度 查询中统计或者分组字段 8、哪些情况不需要创建索引 表记录太少 经常增删改的表 提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE、和DELETE。 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件。 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据建立索引。 注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 频繁更新的字段不适合建立索引，因为每次更新不单单是更新了记录还会更新索引 WHERE条件里用不到的字段不创建索引]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql视图的简单使用]]></title>
    <url>%2FMysql%E8%A7%86%E5%9B%BE%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[视图是指计算机数据库中的视图，是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。——百度百科 1、创建要在MySQL中创建一个新视图，可以使用CREATE VIEW语句。 在MySQL中创建视图的语法如下： 12345CREATE [ALGORITHM = &#123;MERGE | TEMPTABLE | UNDEFINED&#125;]VIEW [database_name].[view_name] AS[SELECT statement] 下面我们来详细的查看上面的语法。 1.1、查看处理算法:算法属性允许您控制MySQL在创建视图时使用的机制，MySQL提供了三种算法：MERGE，TEMPTABLE和UNDEFINED。 使用MERGE算法，MySQL首先将输入查询与定义视图的SELECT语句组合成单个查询。 然后MySQL执行组合查询返回结果集。 如果SELECT语句包含集合函数(如MIN，MAX，SUM，COUNT，AVG等)或DISTINCT，GROUP BY，HAVING，LIMIT，UNION，UNION ALL，子查询，则不允许使用MERGE算法。 如果SELECT语句无引用表，则也不允许使用MERGE算法。 如果不允许MERGE算法，MySQL将算法更改为UNDEFINED。请注意，将视图定义中的输入查询和查询组合成一个查询称为视图分辨率。 使用TEMPTABLE算法，MySQL首先根据定义视图的SELECT语句创建一个临时表，然后针对该临时表执行输入查询。因为MySQL必须创建临时表来存储结果集并将数据从基表移动到临时表，所以TEMPTABLE算法的效率比MERGE算法效率低。 另外，使用TEMPTABLE算法的视图是不可更新的。 当您创建视图而不指定显式算法时，UNDEFINED是默认算法。UNDEFINED算法使MySQL可以选择使用MERGE或TEMPTABLE算法。MySQL优先使用MERGE算法进行TEMPTABLE算法，因为MERGE算法效率更高。 1.2、查看名称在数据库中，视图和表共享相同的命名空间，因此视图和表不能具有相同的名称。 另外，视图的名称必须遵循表的命名规则。 1.3、SELECT语句在SELECT语句中，可以从数据库中存在的任何表或视图查询数据。SELECT语句必须遵循以下几个规则： SELECT语句可以在WHERE子句中包含子查询，但FROM子句中的不能包含子查询。 SELECT语句不能引用任何变量，包括局部变量，用户变量和会话变量。 SELECT语句不能引用准备语句的参数。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NexT主题深度优化]]></title>
    <url>%2FNexT%E4%B8%BB%E9%A2%98%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[本文主要对next主题导入后的基本及深度优化行为做了记录。其中基本配置直接贴出了配置文件，里面写上了中文注释。深度优化方面，既有总结，也有大量的链接推荐。 1.开始搭建博客2.优化：基本功能配置接下来是配置和增强功能，如阅读统计、评论、插件之类的，这些基本配置建议在写文章之前配置好。 基本功能配置大部分是修改两个文件，都叫_config.yml。一个是站点的，一个是主题的。 与其将各个功能分散开来讲，不如直接贴出配置文件，打上注释，从头到尾看一遍就知道如何配置了。 2.1 选择主题我选择的是NexT,是在Github上被Star最多【2018.3.30】的一个Hexo主题。从V6.0.0开始next主仓库已从 iissnan 名下 迁移至 theme-next 。组织 想要什么样的主题，去Hexo Themes上慢慢找。 至于更换主题，很简单，用NexT主题举个例子。 首先，去主题所在仓库拷贝仓库地址，如下图： 然后，到博客站点根目录下,打开 git bash 12// next是自定义的主题名字，可以随意更改git clone https://github.com/theme-next/hexo-theme-next.git themes/next 最后，修改站点配置文件_config.yml 12## Themes: https://hexo.io/themes/theme: next 2.2 站点配置文件请先查看 Hexo官方文档 ，再查看下面我贴出的，如果这样后你还是对有些地方比较懵，可以自行 Google。 注意：文件中所有的 : 都是英文字符，且后面都有一个空格。 【2018.3.30更新】文件位置： ~/blog/_config.yml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: 温故而知新subtitle: description: 天下事有难易乎？&lt;br/&gt;为之，则难者亦易矣；&lt;br/&gt;不为，则易者亦难矣。author: 肖悦language: zh-CNtimezone: # URL## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;url: http://kevinXiao2016.github.ioroot: /# 博客文章的 URL 结构，请务必写文章之前就想好！# 详细参数请查看：https://hexo.io/docs/permalinks.htmlpermalink: :year/:month/:day/:title/permalink_defaults:# Directorysource_dir: sourcepublic_dir: publictag_dir: tagsarchive_dir: archivescategory_dir: categoriescode_dir: downloads/codei18n_dir: :langskip_render:# Writingnew_post_name: :title.md # File name of new postsdefault_layout: posttitlecase: false # Transform title into titlecaseexternal_link: true # Open external links in new tabfilename_case: 0render_drafts: falsepost_asset_folder: falserelative_link: falsefuture: true# 代码高亮设置highlight: enable: true line_number: true auto_detect: false tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:tag_map:# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DDtime_format: HH:mm:ss# ---------------------------------------------------------------# 扩展设置# ---------------------------------------------------------------# 集成Local Search 支持站内搜索search: path: search.xml field: post format: html limit: 10000# Pagination## Set per_page to 0 to disable paginationper_page: 10pagination_dir: pageindex_generator: per_page: 10 ##首页默认10篇文章标题 如果值为0不分页## 修改归档页面、某一分类页面、某一标签页面的显示篇数## 参考：http://theme-next.iissnan.com/faqs.html#setting-page-sizearchive_generator: per_page: 10 ##归档页面默认10篇文章标题 yearly: true ##生成年视图 monthly: true ##生成月视图tag_generator: per_page: 10 ##标签分类页面默认10篇文章category_generator: per_page: 10 ###分类页面默认10篇文章# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git # 没有做cdn映射前，请使用下面注释掉的配置 repo: github: git@github.com:kevinXiao2016/kevinXiao2016.github.io.git,master coding: git@git.coding.net:kevinXiao2016/kevinXiao2016.git,master #repository: https://github.com/kevinXiao2016/kevinXiao2016.github.io.git #branch: master 2.3 主题配置文件如果使用的主题不是Next，那么请另 Google。建议先查看 NexT 官方文档。 【2018.3.30更新】文件位置： ~/blog/themes/next/_config.yml 1234567891011121314# ---------------------------------------------------------------# Theme Core Configuration Settings# ---------------------------------------------------------------# 更新相关，参考：https://github.com/iissnan/hexo-theme-next/issues/328# 简单说：从V6.0.0开始支持以下功能，不更改主题设置，在站点中设置主题# 1.在~/blog/source 目录下新建source目录，在里面新建 next.yml文件# 2.将主题配置文件全部拷贝过去# 3.设置此处override为true,表明此文件配置可被next.yml中的配置覆盖override: true# Allow to cache content generation. Introduced in NexT v6.0.0.cache: enable: true 【2018.3.30更新】文件位置： ~/blog/source/_data/next.yml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656657658659660661662663664665666667668669670671672673674675676677678679680681682683684685686687688689690691692693694695696697698699700701702703704705706707708709710711712713714715716717718719720721722723724725726727728729730731732733734735736737738739740741742743744745746747748749750751752753754755756757758759760761762763764765766767768769770771772773774775776777778779780781782783784785786787788789790791792793794795796797798799800801802803804805806807808809810811812813814815816817818819820821822823824825826827828829830831832833834835836837838839840841842843844845846847848849850851852853854855856857858859860861862863864865866867868869870871872873874875876877878879880881882883884885886887888889890891892893894895896897898899900901902903904905906907908909910911912913914915916917918919920921922923924925926927928929930931932933934935936937938939940941942943944945946947948949950951952953954955956957958959960961962963964965966967968969970971972973# ---------------------------------------------------------------# Site Information Settings# ---------------------------------------------------------------# 站点图标啦，直接去 https://realfavicongenerator.net# 选项弄好后，下载压缩包，解压复制粘贴# 建议放在 hexo-site/source/images/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦# 最后记得要稍微改下文件名，与下面的保持一致favicon: small: /images/favicon-16x16 medium: /images/favicon-32x32 #apple_touch_icon: /images/apple-touch-icon-next.png #safari_pinned_tab: /images/logo.svg #android_manifest: /images/manifest.json #ms_browserconfig: /images/browserconfig.xml# Set rss to false to disable feed link.# Leave rss as empty to use site&apos;s feed link.# Set rss to specific value if you have burned your feed already.rss:# 页脚配置footer: # Specify the date when the site was setup. # If not defined, current year will be used. # 建站年份 since: 2017 # Icon between year and copyright info. # 年份后面的图标，为 Font Awesome 图标 icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. # 设置true时开启动画效果 animated: true # Change the color of icon, using Hex Code. color: &quot;#ff0000&quot; # If not defined, will be used `author` from Hexo main config. # 如果不定义，默认用站点配置文件的 author 名 copyright: # ------------------------------------------------------------- # Hexo link (Powered by Hexo). # Hexo 的链接 powered: true theme: # Theme &amp; scheme info link (Theme - NexT.scheme). # 是否支持主题 enable: true # Version info of NexT after scheme info (vX.X.X). # 是否显示next的版本 version: true # ------------------------------------------------------------- # Any custom text can be defined here. # 自定义内容 #custom_text: Hosted by &lt;a target=&quot;_blank&quot; rel=&quot;external nofollow&quot; href=&quot;https://pages.coding.me&quot;&gt;&lt;b&gt;Coding Pages&lt;/b&gt;&lt;/a&gt;# ---------------------------------------------------------------# SEO Settings# ---------------------------------------------------------------# Canonical, set a canonical link tag in your hexo, you could use it for your SEO of blog.# See: https://support.google.com/webmasters/answer/139066# Tips: Before you open this tag, remember set up your URL in hexo _config.yml ( ex. url: http://yourdomain.com )canonical: true# Change headers hierarchy on site-subtitle (will be main site description) and on all post/pages titles for better SEO-optimization.seo: false# If true, will add site-subtitle to index page, added in main hexo config.# subtitle: Subtitleindex_with_subtitle: false# ---------------------------------------------------------------# Menu Settings# ---------------------------------------------------------------# When running the site in a subdirectory (e.g. domain.tld/blog), remove the leading slash from link value (/archives -&gt; archives).# Usage: `Key: /link/ || icon`# Key is the name of menu item. If translate for this menu will find in languages - this translate will be loaded; if not - Key name will be used. Key is case-senstive.# Value before `||` delimeter is the target link.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, question icon will be loaded.# 菜单设置 || 菜单图标设置# 编辑 ~/blog/themes/next/languages 下的相应文件# 比如添加一个“留言”菜单，站点配置文件的 language 是 zh-Hans# 则编辑 zh-Hans.yml，在 menu: 项内添加一行 留言: 留言# 注意空格，且符号 : 为英文字符！menu: home: / || home about: /about/ || user tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archive #schedule: /schedule/ || calendar #sitemap: /sitemap.xml || sitemap #commonweal: /404/ || heartbeat# Enable/Disable menu icons / item badges.# 是否开启菜单图标menu_settings: icons: true badges: false# ---------------------------------------------------------------# Scheme Settings# ---------------------------------------------------------------# Schemes# 设计板式，都长啥样，去 README 里面的链接里看看#scheme: Musescheme: Mist#scheme: Pisces#scheme: Gemini# ---------------------------------------------------------------# Sidebar Settings# ---------------------------------------------------------------# Posts / Categories / Tags in sidebar.site_state: true# 侧栏社交链接设置，与上面菜单差不多，要生效记得把前面的 # 去掉# Social Links.# Usage: `Key: permalink || icon`# Key is the link label showing to end users.# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the name of FontAwesome icon. If icon (with or without delimeter) is not specified, globe icon will be loaded.social: #GitHub: https://github.com/kevinXiao2016 || github #E-Mail: mailto:yourname@gmail.com || envelope #Google: https://plus.google.com/yourname || google #Twitter: https://twitter.com/yourname || twitter #FB Page: https://www.facebook.com/yourname || facebook #VK Group: https://vk.com/yourname || vk #StackOverflow: https://stackoverflow.com/yourname || stack-overflow #YouTube: https://youtube.com/yourname || youtube #Instagram: https://instagram.com/yourname || instagram #Skype: skype:yourname?call|chat || skype# 侧栏社交链接图标设置social_icons: enable: true icons_only: false transition: false # Dependencies: exturl: true in Tags Settings section below. # To encrypt links above use https://www.base64encode.org # Example encoded link: `GitHub: aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQ= || github` exturl: false# Follow me on GitHub banner in right-top corner.# Usage: `permalink || title`# Value before `||` delimeter is the target permalink.# Value after `||` delimeter is the title and aria-label name.github_banner: https://github.com/kevinXiao2016 || Follow me on GitHub# Blog rolls# 侧栏友链设置links_icon: globelinks_title: 神奇的链接links_layout: block#links_layout: inlinelinks: EMS规范: http://ems.top-vision.cn:8110/dm/dm.html #网易云音乐 : https://music.163.com/#/user/home?id=86590096 #Coldplay Official Website: http://coldplay.com/ #获取 Elon Musk 的新闻: https://elonmusknews.org/ #尼古拉·特斯拉：发明了现代世界的人: http://www.bilibili.com/video/av6211226/ #关于此博客: https://reuixiy.github.io/about/# Sidebar Avatar# in theme directory(source/images): /images/avatar.gif# in site directory(source/uploads): /uploads/avatar.gif# 侧栏头像设置# 建议放在 hexo-site/source/uploads/ 里（没有自己建）# 这样可以避免更新 NexT 主题的时候遇到麻烦avatar: /images/avatar.png# Table Of Contents in the Sidebar# 侧栏文章目录设置（前提是 Markdown 书写正确）toc: enable: true # Automatically add list number to toc. # 自动加数字序号 number: false # If true, all words will placed on next lines if header width longer then sidebar width. # 如果标题太长，则放到下一行继续显示 wrap: false# Creative Commons 4.0 International License.# http://creativecommons.org/# Available: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | zero#creative_commons: by-nc-sa#creative_commons:sidebar: # Sidebar Position, available value: left | right (only for Pisces | Gemini). # 侧栏位置设置，可用值：左 | 右（只对 Pisces 和 Gemini 设计版式有效！） position: left #position: right # 侧栏显示方式 # Sidebar Display, available value (only for Muse | Mist): # - post expand on posts automatically. Default. # - always expand for all pages automatically # - hide expand only when click on the sidebar toggle icon. # - remove Totally remove sidebar including sidebar toggle. display: post #display: always #display: hide #display: remove # Sidebar offset from top menubar in pixels (only for Pisces | Gemini). # 只对 Pisces 和 Gemini 设计版式有效！ offset: 12 # Back to top in sidebar (only for Pisces | Gemini). # 只对 Pisces 和 Gemini 设计版式有效！ b2t: false # Scroll percent label in b2t button. scrollpercent: true # Enable sidebar on narrow view (only for Muse | Mist). # 移动端显示侧栏，只对 Muse 和 Mist 设计版式有效！ onmobile: true# ---------------------------------------------------------------# Post Settings# ---------------------------------------------------------------# Automatically scroll page to section which is under &lt;!-- more --&gt; mark.# 点击 [Read More]，页面自动滚动到 &lt;!-- more --&gt; 标记处scroll_to_more: false# Automatically saving scroll position on each post/page in cookies.# 用 cookies 保存浏览的位置信息，意味着重新打开这个页面后# 页面就会自动滚动到上次的位置，除非读者清理浏览器 cookiessave_scroll: false# Automatically excerpt description in homepage as preamble text.# 将每篇文章 Front-matter 里 description 的文字作为页面显示的文章摘要excerpt_description: true# Automatically Excerpt. Not recommend.# Please use &lt;!-- more --&gt; in the post to control excerpt accurately.# 按字数自动加入 [Read More]，不建议！# 建议在文章中加入 &lt;!-- more --&gt;# 自定义 [Read More] 按钮之前要显示的内容！auto_excerpt: enable: false length: 150# Post meta display settings# 文章顶部显示的文章元数据设置post_meta: item_text: true created_at: true updated_at: false # Only show &apos;updated&apos; if different from &apos;created&apos;. updated_diff: false categories: true# Post wordcount display settings# Dependencies: https://github.com/theme-next/hexo-symbols-count-time# 显示统计字数和估计阅读时长# 注意：这个要安装插件，先进入站点文件夹根目录# 然后：npm install hexo-symbols-count-time --savesymbols_count_time: separated_meta: true item_text_post: true item_text_total: false awl: 5 wpm: 200# Manual define the border radius in codeblock# Leave it empty for the default 1codeblock: border_radius: # Wechat Subscriber#wechat_subscriber: #enabled: true #qcode: /path/to/your/wechatqcode ex. /uploads/wechat-qcode.jpg #description: ex. subscribe to my blog by scanning my public wechat account# Rewardreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechat-reward-image.jpgalipay: /images/alipay-reward-image.jpg#bitcoin: /images/bitcoin.png# Related popular posts# Dependencies: https://github.com/tea3/hexo-related-popular-postsrelated_posts: enable: false title: # custom header, leave empty to use the default one display_in_home: false params: maxCount: 5 #PPMixingRate: 0.0 #isDate: false #isImage: false #isExcerpt: false# Declare license on postspost_copyright: enable: false license: &lt;a href=&quot;https://creativecommons.org/licenses/by-nc-sa/4.0/&quot; rel=&quot;external nofollow&quot; target=&quot;_blank&quot;&gt;CC BY-NC-SA 4.0&lt;/a&gt;# ---------------------------------------------------------------# Misc Theme Settings# ---------------------------------------------------------------# Reduce padding / margin indents on devices with narrow width.# 移动端把页面两边留白去除，个人不建议mobile_layout_economy: false# Android Chrome header panel color ($brand-bg / $headband-bg =&gt; $black-deep).# Android 上 Chrome 浏览器顶部颜色设置android_chrome_color: &quot;#222&quot;# Custom Logo.# !!Only available for Default Scheme currently.# Options:# enabled: [true/false] - Replace with specific image# image: url-of-image - Images&apos;s urlcustom_logo: enabled: false image:# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-theme# 代码高亮主题设置# 都长啥样自己点开上面的链接查看highlight_theme: normal# Enable &quot;cheers&quot; for archive page.cheers_enabled: true# Manual define the max content width# !!Only available for Gemini Scheme currently# Leave it empty for the default 75% (suggest not less than 1000px)#max_content_width: 1000px# Manual define the sidebar width# !!Only available for Gemini Scheme currently# Leave it empty for the default 240sidebar_width:# ---------------------------------------------------------------# Font Settings# - Find fonts on Google Fonts (https://www.google.com/fonts)# - All fonts set here will have the following styles:# light, light italic, normal, normal italic, bold, bold italic# - Be aware that setting too much fonts will cause site running slowly# - Introduce in 5.0.1# ---------------------------------------------------------------# CAUTION! Safari Version 10.1.2 bug: https://github.com/iissnan/hexo-theme-next/issues/1844# To avoid space between header and sidebar in Pisces / Gemini themes recommended to use Web Safe fonts for `global` (and `logo`):# Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS# ---------------------------------------------------------------# 字体设置font: enable: false # Uri of fonts host. E.g. //fonts.googleapis.com (Default). host: # Font options: # `external: true` will load this font family from `host` above. # `family: Times New Roman`. Without any quotes. # `size: xx`. Use `px` as unit. # Global font settings used for all elements in &lt;body&gt;. global: external: true family: Lato size: # Font settings for Headlines (H1, H2, H3, H4, H5, H6). # Fallback to `global` font settings. headings: external: true family: size: # Font settings for posts. # Fallback to `global` font settings. posts: external: true family: # Font settings for Logo. # Fallback to `global` font settings. logo: external: true family: size: # Font settings for &lt;code&gt; and code blocks. codes: external: true family: size:# ---------------------------------------------------------------# Third Party Services Settings# ---------------------------------------------------------------# Math Equations Render Supportmath: enable: false # Default(true) will load mathjax/katex script on demand # That is it only render those page who has &apos;mathjax: true&apos; in Front Matter. # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE. per_page: true engine: mathjax #engine: katex # hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support. mathjax: # Use 2.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML # For newMathJax CDN (cdnjs.cloudflare.com) with fallback to oldMathJax (cdn.mathjax.org). #cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML # For direct link to MathJax.js with CloudFlare CDN (cdnjs.cloudflare.com). #cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML # For automatic detect latest version link to MathJax.js and get from Bootcss. #cdn: //cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin) # needed to full Katex support. katex: # Use 0.7.1 as default, jsdelivr as default CDN, works everywhere even in China cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China #cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css # Bootcss, works great in China, but not so well in other region #cdn: //cdn.bootcss.com/KaTeX/0.7.1/katex.min.css# Han Support# Dependencies: https://github.com/theme-next/theme-next-han# 汉字标准格式，没用过暂时不了解han: false# Pangu Support# Dependencies: https://github.com/theme-next/theme-next-pangu# For more information: https://github.com/vinta/pangu.jspangu: false# Swiftype Search API Key#swiftype_key:# Baidu Analytics ID#baidu_analytics:# Disqusdisqus: enable: false shortname: count: true lazyload: false# Hypercomments#hypercomments_id:# changyanchangyan: enable: false appid: appkey:# leanCloud支持的评论插件# Valine. # You can get your appid and appkey from https://leancloud.cn# more info please open https://valine.js.orgvaline: enable: false appid: P08Jh3wwb2zPhfm9puCevcUa-******* appkey: CnhNSWBKT3kwj52v******** notify: false # mail notifier , https://github.com/xCss/Valine/wiki verify: false # Verification code placeholder: Just go go # comment box placeholder avatar: mm # gravatar style guest_info: nick,mail,link # custom comment header pageSize: 10 # pagination size# Support for youyan comments system.# You can get your uid from http://www.uyan.cc#youyan_uid: your uid# Support for LiveRe comments system.# You can get your uid from https://livere.com/insight/myCode (General web site)livere_uid: MTAyMC8yODQwNi******# Gitment# Introduction: https://imsun.net/posts/gitment-introduction/gitment: enable: false mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide &apos;Powered by ...&apos; on footer, and more language: # Force language, or auto switch by theme github_user: # MUST HAVE, Your Github Username github_repo: # MUST HAVE, The name of the repo you use to store Gitment comments client_id: # MUST HAVE, Github client id for the Gitment client_secret: # EITHER this or proxy_gateway, Github access secret token for the Gitment proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled# Baidu Share# Available value:# button | slide# Warning: Baidu Share does not support https.#baidushare:## type: button# Share# This plugin is more useful in China, make sure you known how to use it.# And you can find the use guide at official webiste: http://www.jiathis.com/.# Warning: JiaThis does not support https.#jiathis: ##uid: Get this uid from http://www.jiathis.com/#add_this_id:# NeedMoreShare2# Dependencies: https://github.com/theme-next/theme-next-needmoreshare2# See: https://github.com/revir/need-more-share2# Also see: https://github.com/DzmVasileusky/needShareButton# iconStyle: default | box# boxForm: horizontal | vertical# position: top / middle / bottom + Left / Center / Right# networks: Weibo,Wechat,Douban,QQZone,Twitter,Linkedin,Mailto,Reddit,# Delicious,StumbleUpon,Pinterest,Facebook,GooglePlus,Slashdot,# Technorati,Posterous,Tumblr,GoogleBookmarks,Newsvine,# Evernote,Friendfeed,Vkontakte,Odnoklassniki,Mailruneedmoreshare2: enable: false postbottom: enable: false options: iconStyle: box boxForm: horizontal position: bottomCenter networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook float: enable: false options: iconStyle: box boxForm: horizontal position: middleRight networks: Weibo,Wechat,Douban,QQZone,Twitter,Facebook# Google Webmaster tools verification setting# See: https://www.google.com/webmasters/#google_site_verification:# Google Analytics#google_analytics:# Bing Webmaster tools verification setting# See: https://www.bing.com/webmaster/#bing_site_verification:# Yandex Webmaster tools verification setting# See: https://webmaster.yandex.ru/#yandex_site_verification:# CNZZ count#cnzz_siteid:# Application Insights# See https://azure.microsoft.com/en-us/services/application-insights/# application_insights:# Post widgets &amp; FB/VK comments settings.# ---------------------------------------------------------------# Facebook SDK Support.# https://github.com/iissnan/hexo-theme-next/pull/410facebook_sdk: enable: false app_id: #&lt;app_id&gt; fb_admin: #&lt;user_id&gt; like_button: #true webmaster: #true# Facebook comments plugin# This plugin depends on Facebook SDK.# If facebook_sdk.enable is false, Facebook comments plugin is unavailable.facebook_comments_plugin: enable: false num_of_posts: 10 # min posts num is 1 width: 100% # default width is 550px scheme: light # default scheme is light (light or dark)# VKontakte API Support.# To get your AppID visit https://vk.com/editapp?act=createvkontakte_api: enable: false app_id: #&lt;app_id&gt; like: true comments: true num_of_posts: 10# Star rating support to each article.# To get your ID visit https://widgetpack.comrating: enable: false id: #&lt;app_id&gt; color: fc6423# ---------------------------------------------------------------# Show number of visitors to each article.# You can visit https://leancloud.cn get AppID and AppKey.leancloud_visitors: enable: false app_id: P08Jh3wwb2zPhfm9puCevcUa-gzGzoHsz app_key: CnhNSWBKT3kwj52vyJ36armb # Dependencies: https://github.com/theme-next/hexo-leancloud-counter-security # If you don&apos;t care about security in lc counter and just want to use it directly # (without hexo-leancloud-counter-security plugin), set the `security` to `false`. security: true betterPerformance: false# Another tool to show number of visitors to each article.# visit https://console.firebase.google.com/u/0/ to get apiKey and projectId# visit https://firebase.google.com/docs/firestore/ to get more information about firestorefirestore: enable: false collection: articles #required, a string collection name to access firestore database apiKey: #required projectId: #required bluebird: false #enable this if you want to include bluebird 3.5.1(core version) Promise polyfill# Show Views/Visitors of the website/page with busuanzi.# Get more information on http://ibruce.info/2015/04/04/busuanzi/busuanzi_count: enable: true total_visitors: true total_visitors_icon: user total_views: true total_views_icon: eye post_views: true post_views_icon: eye# Tencent analytics ID# tencent_analytics:# Tencent MTA ID# tencent_mta:# Enable baidu push so that the blog will push the url to baidu automatically which is very helpful for SEObaidu_push: false# Google Calendar# Share your recent schedule to others via calendar page## API Documentation:# https://developers.google.com/google-apps/calendar/v3/reference/events/listcalendar: enable: false calendar_id: &lt;required&gt; api_key: &lt;required&gt; orderBy: startTime offsetMax: 24 offsetMin: 4 timeZone: showDeleted: false singleEvents: true maxResults: 250# Algolia Search# See: https://github.com/theme-next/hexo-theme-next/blob/master/docs/ALGOLIA-SEARCH.md# Dependencies: https://github.com/theme-next/theme-next-algolia-instant-searchalgolia_search: enable: false hits: per_page: 10 labels: input_placeholder: Search for Posts hits_empty: &quot;We didn&apos;t find any results for the search: $&#123;query&#125;&quot; hits_stats: &quot;$&#123;hits&#125; results found in $&#123;time&#125; ms&quot;# Local search# Dependencies: https://github.com/theme-next/hexo-generator-searchdb# 要安装插件才能使用，先进入站点文件夹根目录# 然后：npm install hexo-generator-searchdb --savelocal_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false# Bookmark Support# Dependencies: https://github.com/theme-next/theme-next-bookmarkbookmark: enable: false # if auto # - save the reading position when closing the page # - or clicking the bookmark-icon # if manual, only save it by clicking the bookmark-icon save: auto# ---------------------------------------------------------------# Tags Settings# ---------------------------------------------------------------# External URL with BASE64 encrypt &amp; decrypt.# Usage: &#123;% exturl text url &quot;title&quot; %&#125;# Alias: &#123;% extlink text url &quot;title&quot; %&#125;# 用法见：# https://github.com/iissnan/hexo-theme-next/pull/1438exturl: false# 主题的标签样式，有 note、label、tabs 三种# Note tag (bs-callout).note: # Note tag style values: # - simple bs-callout old alert style. Default. # - modern bs-callout new (v2-v3) alert style. # - flat flat callout style with background, like on Mozilla or StackOverflow. # - disabled disable all CSS styles import of note tag. style: simple icons: false border_radius: 3 # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6). # Offset also applied to label tag variables. This option can work with disabled note tag. light_bg_offset: 0# Label tag.label: true# Tabs tag.tabs: enable: true transition: tabs: false labels: true border_radius: 0# Reading progress bar# Dependencies: https://github.com/theme-next/theme-next-reading-progressreading_progress: enable: false color: &quot;#37c6c0&quot; height: 2px#! ---------------------------------------------------------------#! DO NOT EDIT THE FOLLOWING SETTINGS#! UNLESS YOU KNOW WHAT YOU ARE DOING#! ---------------------------------------------------------------# 动画# Use velocity to animate everything.motion: enable: true async: false transition: # Transition variants: # fadeIn | fadeOut | flipXIn | flipXOut | flipYIn | flipYOut | flipBounceXIn | flipBounceXOut | flipBounceYIn | flipBounceYOut # swoopIn | swoopOut | whirlIn | whirlOut | shrinkIn | shrinkOut | expandIn | expandOut # bounceIn | bounceOut | bounceUpIn | bounceUpOut | bounceDownIn | bounceDownOut | bounceLeftIn | bounceLeftOut | bounceRightIn | bounceRightOut # slideUpIn | slideUpOut | slideDownIn | slideDownOut | slideLeftIn | slideLeftOut | slideRightIn | slideRightOut # slideUpBigIn | slideUpBigOut | slideDownBigIn | slideDownBigOut | slideLeftBigIn | slideLeftBigOut | slideRightBigIn | slideRightBigOut # perspectiveUpIn | perspectiveUpOut | perspectiveDownIn | perspectiveDownOut | perspectiveLeftIn | perspectiveLeftOut | perspectiveRightIn | perspectiveRightOut post_block: fadeIn post_header: slideDownIn post_body: slideDownIn coll_header: slideLeftIn # Only for Pisces | Gemini. sidebar: slideUpIn# Fancybox. There is support for old version 2 and new version 3.# Please, choose only any one variant, do not need to install both.# For install 2.x: https://github.com/theme-next/theme-next-fancybox# For install 3.x: https://github.com/theme-next/theme-next-fancybox3# 查看图片的fancybox: false# Added switch option for separated repo in 6.0.0.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: false# Added switch option for separated repo in 6.0.0.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: false# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: false# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal# Canvas-nest# Dependencies: https://github.com/theme-next/theme-next-canvas-nestcanvas_nest: true# JavaScript 3D library.# Dependencies: https://github.com/theme-next/theme-next-three# three_wavesthree_waves: false# canvas_linescanvas_lines: false# canvas_spherecanvas_sphere: false# Only fit scheme Pisces# Dependencies: https://github.com/theme-next/theme-next-canvas-ribbon# Canvas-ribbon# size: The width of the ribbon.# alpha: The transparency of the ribbon.# zIndex: The display level of the ribbon.canvas_ribbon: enable: false size: 300 alpha: 0.6 zIndex: -1# Script Vendors.# Set a CDN address for the vendor you want to customize.# For example# jquery: https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js# Be aware that you should use the same version as internal ones to avoid potential problems.# Please use the https protocol of CDN files when you enable https on your site.# 相关内容用 CDN 地址取代，加速网站访问，注意版本尽可能要一致vendors: # Internal path prefix. Please do not edit it. _internal: lib # Internal version: 2.1.3 jquery: # Internal version: 2.1.5 # See: http://fancyapps.com/fancybox/ fancybox: fancybox_css: # Internal version: 1.0.6 # See: https://github.com/ftlabs/fastclick fastclick: # Internal version: 1.9.7 # See: https://github.com/tuupola/jquery_lazyload lazyload: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity: # Internal version: 1.2.1 # See: http://VelocityJS.org velocity_ui: # Internal version: 0.7.9 # See: https://faisalman.github.io/ua-parser-js/ ua_parser: # Internal version: 4.6.2 # See: http://fontawesome.io/ fontawesome: # Internal version: 1 # https://www.algolia.com algolia_instant_js: algolia_instant_css: # Internal version: 1.0.2 # See: https://github.com/HubSpot/pace # Or use direct links below: # pace: //cdn.bootcss.com/pace/1.0.2/pace.min.js # pace_css: //cdn.bootcss.com/pace/1.0.2/themes/blue/pace-theme-flash.min.css pace: pace_css: # Internal version: 1.0.0 # https://github.com/hustcc/canvas-nest.js canvas_nest: # three three: # three_waves # https://github.com/jjandxa/three_waves three_waves: # three_waves # https://github.com/jjandxa/canvas_lines canvas_lines: # three_waves # https://github.com/jjandxa/canvas_sphere canvas_sphere: # Internal version: 1.0.0 # https://github.com/zproo/canvas-ribbon canvas_ribbon: # Internal version: 3.3.0 # https://github.com/ethantw/Han han: # Internal version: 3.3.0 # https://github.com/vinta/pangu.js pangu: # needMoreShare2 # https://github.com/revir/need-more-share2 needmoreshare2_js: needmoreshare2_css: # bookmark # Internal version: 1.0.0 # https://github.com/theme-next/theme-next-bookmark bookmark: # reading_progress # Internal version: 1.0 # https://github.com/theme-next/theme-next-reading-progress # Example: https://cdn.jsdelivr.net/gh/theme-next/theme-next-reading-progress@1.1/reading_progress.min.js reading_progress: # valine comment # Example: https://cdn.jsdelivr.net/npm/valine@1.1.8/dist/Valine.min.js valine:# Assetscss: cssjs: jsimages: images# Theme versionversion: 6.0.6 2.4 动态背景在主题配置文件中，靠后面，改canvas_nest: true，想要更改颜色和数量？修改文件： 文件位置：~/blog/themes/next/source/lib/canvas-nest/canvas-nest.min.js 怎么修改？参考canvas-nest.js。 2.5 注脚参考hexo-footnotes。 3.优化:高级功能配置3.1 大佬们的文章更多如外挂一样的功能配置，就直接贴大佬的文章了，哪些功能自己喜欢，按照大佬的教程来配置就行。不过也有坑，比如有些功能（超链接样式、侧栏头像圆形并旋转）可以直接通过在custom.styl添加 CSS 代码实现，无需更改其它文件！ 打造个性超赞博客Hexo+NexT+GithubPages的超深度优化 hexo高阶教程next主题优化 hexo的next主题个性化教程:打造炫酷网站 Hexo搭建博客的个性化设置 3.2 鼠标点击效果 新建mouse.js，复制love或者富强民主…中的内容到js文件中。 将mouse.js放到/themes/next/source/js/src路径下 打开/themes/next/layout/layout.swig文件，添加如下代码： 1&lt;script type="text/javascript" src="/js/src/mouse.js"&gt;&lt;/script&gt; 3.3 文章加密参考：hexo-blog-encrypt 在博客根目录下的package.json文件中添加一行代码 1"hexo-blog-encrypt": "2.0.*" 在博客根目录下： npm install 在站点配置文件中配置文章加密 123# Securityencrypt: enable: true 然后在你的文章的头部添加上对应的字段，如 password, abstract, message 1234567title: hello worlddate: 2016-03-30 21:18:02tags: - fdsafsdafpassword: Mikeabstract: 没点开文章前显示的类容，类似于&lt;!--more--&gt;之前写的描述.message: 点开文章后，提示输入密码的信息. 3.4 博客推广及SEO优化建站完成后百度和Google是没有收录我们的网站的，想要搜索到我们的博客非常困难。因此优化搜索非常有必要。 博客推广 博客推广第一步，手动推广。 你可以多浏览别人的博客并留下你的爪印（博客地址），比如 评论 本文；你可以去 README.md中提到的 这个issue 留下你的爪印；你可以去 Issues页面 试着回答下大家的问题并留下你的爪印。 博客推广第二步，SEO（Search Engine Optimization）。 搜索引擎 直接推荐大佬文章：【搜索优化】Hexo-next百度和谷歌搜索优化 3.5 随机生成背景图在主题下的/source/css/_custom/custom.style文件中，添加如下代码： 123456789101112131415body&#123; background:url(https://source.unsplash.com/random/1920x1080); background-size:cover; background-repeat:no-repeat; background-attachment:fixed; background-position:50% 50%;&#125;.main-inner &#123; margin-top: 60px; padding: 60px 60px 60px 60px; background: #fff; opacity: 0.8; min-height: 500px;&#125; 3.6 背景动画依赖于theme-next-canvas-nest,或者3D library。 进入到主题目录，如：cd themes/next 下载插件 12git clone https://github.com/theme-next/theme-next-canvas-nest source/lib/canvas-nestgit clone https://github.com/theme-next/theme-next-three source/lib/three 在主题配置文件中开启，一次只开启一个 12345canvas_nest: falsethree_waves: falsecanvas_lines: truecanvas_sphere: false 插件更新 12$ cd themes/next/source/lib/canvas-nest$ git pull 3.7 底部footer加入运行时间 ~/blog/themes/next/layout/_partials 1234567891011121314151617181920212223242526272829&lt;div id="days"&gt;&lt;/div&gt;&lt;/script&gt;&lt;script language="javascript"&gt;function show_date_time()&#123; window.setTimeout("show_date_time()", 1000); BirthDay=new Date("05/27/2017 15:00:00"); today=new Date(); timeold=(today.getTime()-BirthDay.getTime()); sectimeold=timeold/1000 secondsold=Math.floor(sectimeold); msPerDay=24*60*60*1000 e_daysold=timeold/msPerDay daysold=Math.floor(e_daysold); e_hrsold=(e_daysold-daysold)*24; hrsold=setzero(Math.floor(e_hrsold)); e_minsold=(e_hrsold-hrsold)*60; minsold=setzero(Math.floor((e_hrsold-hrsold)*60)); seconds=setzero(Math.floor((e_minsold-minsold)*60)); document.getElementById('days').innerHTML="已运行"+daysold+"天"+hrsold+"小时"+minsold+"分"+seconds+"秒";&#125;function setzero(i)&#123; if (i&lt;10) &#123;i="0" + i&#125;; return i;&#125;show_date_time();&lt;/script&gt; 要是不喜欢颜色，感觉不好看，就可以在上文所提的custom.styl加入： 文件位置：~/blog/themes/next/source/css/_custom/custom.styl 1234567// 自定义的侧栏时间样式#days &#123; display: block; color: rgb(7, 179, 155); font-size: 13px; margin-top: 15px;&#125;]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。 介绍意图：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。主要解决：一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。关键代码：在抽象类（主题、被观察者）里有一个 集合 存放观察者们。优点： 观察者和被观察者是抽象耦合的。 建立一套触发机制。缺点：1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。注意事项：1、JAVA 中已经有了对观察者模式的支持类。2、避免循环引用。3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。 实现观察者模式主要使用的5个类或接口对象。 主题（被观察者）接口：定义绑定、移除、通知观察者的方法 主题实现类：实现上述三个方法，包含一个观察者引用队列 观察者接口：定义了该类观察者要实现的方法 观察者实现类：实现具体的观察者接口，初始化时将自己注册到主题的观察者引用队列 消息实体类：主题和观察者之间传递的消息实体 改进 JDK已有观察者顶层接口： java.util.EventListener JDK已有消息实体顶层父类： java.util.EventObject]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是设计模式]]></title>
    <url>%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[简介。 设计模式简介设计模式实质是前人在代码设计的基础上总结出来的编码经验，代表了最佳的实践。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 设计原则设计模式主要是基于以下的面向对象设计原则： 对接口编程而不是对实现编程。 优先使用对象组合而不是继承。 设计模式的类型 创建型模式–&gt;对象怎么来 结构型模式–&gt;对象和谁有关 行为型模式–&gt;对象与对象在干嘛 J2EE 模式–&gt;对象合起来要干嘛（表现层,文中表示层个人感觉用的不准确）java是面向对象的语言,所以要搞好对象,模式（套路）就是用来更加好的搞对象滴。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NM3000消息推送框架简介]]></title>
    <url>%2FNM3000%E6%B6%88%E6%81%AF%E6%8E%A8%E9%80%81%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[NM3000网管系统架构之一：消息推送框架简介 1、简介传统的顺序程序设计总是按照流程来安排所有的工作，而事件机制的特点在于:等待，有事情发生则处理。这样的好处是避免了顺序程序设计在没有工作时的空循环处理，释放了各种资源。 Java事件处理采用观察者模式，即发布-订阅模式。关于该设计模式，请参照观察者模式。 2、NM3000事件机制相关接口、类介绍2.1 监听者接口:主题和监听者之间消息传递的标准接口规范。 2.2 监听者：实现监听者接口，具体的事件执行者。2.3 *Adapter类：适配器类，继承该类后无需实现接口中所有方法，如果需要实现方法不多，可以无需建立适配器类。2.4 主题接口：被监听者的顶层接口.2.5 主题:被监听者，包含监听者接口的引用，一个事件队列，两个消息发送方法。 regs:监听者接口引用map集合 map的key是监听者接口的class对象，value是该接口下的实现类对象。 eventQueue:消息对象队列 阻塞队列中存放的是EmsEventObject对象，所以继承自该对象的消息对象都可以存放到队列中。 executorService：java线程池 采用生产者-消费者模式，多线程处理消息队列。 addListener：监听者类初始化时，调用该方法，将自己添加到messageService的监听者集合中。 addMessage:添加消息，将消息放到eventQueue中，等待执行 fireMessage：立即将消息传递给对应的监听者，即立即执行 重点：封装消息对象，设置监听该消息的接口和响应方法。 使用反射，从消息对象中获得响应方法，invoke执行，即将消息传递给指定接口的监听者。 2.6 消息对象：主题和监听者之间传递的事件描述对象。 3、NM3000事件机制的使用 新建*Listener接口，继承EmsListener 新建Adapter类，继承EmsAdapter，实现Listener接口。(可选) 新建Event类，继承EmsEventObject&lt;Listener&gt;类 一般在service层使用消息。 在监听者实现类(实现监听者接口)中注MessageServiceImpl类，并在initialize方法中添加Listener接口。在destroy方法中移除Listener接口。注意：在配置*serviceImpl实现类时，需要配置初始化及销毁时方法。示例：messageService.addListener(CmcEntityListener.class, this);messageService.removeListener(CmcEntityListener.class, this); 在需要发送消息的地方，构建消息对象，设置监听接口及方法，调用messageService发送消息。addMessage:将消息添加到消息缓冲队列，延迟执行fireMessage:立即执行]]></content>
      <categories>
        <category>NM3000</category>
      </categories>
      <tags>
        <tag>NM3000</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NM3000告警框架简介]]></title>
    <url>%2FNM3000%E5%91%8A%E8%AD%A6%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[NM3000网管系统核心架构之一：trap告警框架简介 1、告警概念设备在发生变化（比如断纤/断电/上线）时，会向trapserver中配置的各ip地址发送trap，上报这些变化信息。一般我们网管的ip都会配置到各设备的trapserver中，也就是说，设备发出的trap，网管是能够收到的。网管根据收到的trap作出对应的响应，包括产生告警、清除告警等。 2、snmp4j简介网管是利用snmp4j在指定端口监听SNMP消息。 2.1 重要类及接口Snmp类SNMP4J的最核心的类，负责SNMP报文的接受和发送。 PDU类和ScopedPDU类该类是SNMP报文单元的抽象，其中PDU类适用于SNMPv1、SNMPv2。ScopedPDU类继承于PDU类，适用于SNMPv3。 Target接口和UserTarget类对应于SNMP代理的地址信息，包括地址和端口号。其中Target接口适用于SNMPv1、SNMPv2。UserTarget类实现了UserTarget接口，适用于SNMPv3。 TransportMapping接口该接口代表了SNMP4J所使用的传输层协议。这也是SNMP4J的一大特色的地方。按照RFC规定，SNMP是只使用UDP作为传输层协议。而SNMP4J支持管理端和代理端使用UDP或TCP进行传输。该接口有两个子接口。 CommandResponder接口该接口接收PDU报文。实现了该接口的类，可以在processPdu方法中处理收到的报文。 2.2 两种消息发送模式SNMP支持两种消息发送模式：同步发送模式和异步发送模式。同步发送模式也称阻塞模式。当管理端发送出一条消息后，线程会被阻塞，直到收到对方的回应或者超时。异步发送模式也称非阻塞模式。当管理端发出一条消息后，线程将会继续执行，当收到消息的回应的时候，程序会对消息做出相应的处理。要实现异步模式，需要实例化一个实现了ResponseListener接口的对象。ResponseListener接口有一个onResponse的函数。这是一个回调函数，当程序收到响应的时候，会自动调用该函数。由该函数完成对响应的处理。 2.3 监听trap的步骤 明确SNMP在传输层所使用的协议一般情况下，我们使用UDP协议作为SNMP的传输层协议，所以需要实例化一个DefaultUdpTransportMapping接口对象。 实例化SNMP对象我们需要将实例化的DefaultUdpTransportMapping接口对象作为参数，构造SNMP对象。另外，如果实现SNMPv3协议，还需要设计安全机制，添加安全用户等。 监听SNMP消息实例化实现CommandResponder接口的对象，设置为snmp对象的消息处理器，以后监听到的PDU报文由接口的processPdu方法处理。SNMP对象开启监听。 3、网管如何收到Trap3.1 监听调度示意图 3.2 获取server ip + port 3.3 下发给engine，启动trap监听 将TrapCallBack接口的实现类（TrapServiceImpl）添加到SnmpTrapManager的监听集合中。 3.4 实际监听类SnmpTrapManager实现了CommandResponder接口，trap上来后会自动进入processPdu中处理。 3.5 小结关于trap是如何从设备上到网管系统的，我们不必太过于关心，基本上都是snmp4j的封装实现。只需要大概知道是如何实现监听的即可。最重要的还是网管处理trap的过程。 4、 网管处理Trap流程 整个trap的处理流程较为复杂，我们把它分解为几个阶段： snmpTrapManager处理trap，发送给server trapparser将trap转成event eventparser根据event生成告警或者清除告警 4.1 SnmpTrapManager处理trap，发送给server 为何使用多线程消费缓存的trap队列 最开始的模型是一个长度为1024的队列缓存接收到的trap，一个线程不断的处理这些trap。后来在珠江数码实网中发生了trap丢失的问题，经过抓取log日志发现，由于华为的部分OLT不断的向我们网管发送trap，平均每天收到43W条trap。而单线程的处理速度不够，在接收到trap频率达到一定程度后，导致缓存队列达到上限，丢失了部分trap。为了提升我们trap接收端的处理能力，需要改为多线程来进行处理。 多线程处理注意事项 每个ip发过来的trap处理顺序必须保证，因为告警间存在清除关系（断电/上线）。 trap缓存数据模型 1Map&lt;String, ConcurrentTrapQueue&gt; deviceTraps 以设备IP为key，该设备上报的trap都存在单独的ConcurrentTrapQueue中。 ConcurrentTrapQueue 这个自定义非阻塞队列非常关键，它继承自ConcurrentLinkedQueue，使用锁的机制来确保同时只有一个线程能操作队列数据，从而保证了trap的处理顺序。 因为如果同时可以从队列里面取出多条trap进行处理，后面的trap就可能先处理完成，从而破坏了顺序，导致告警无法产生或者告警无法清除等bug。 ConcurrentLinkedQueue使用了可重入锁ReentrantLock，来保证在一个trap处理完成前，该队列数据不能被其他线程取出。具体实现机制为： 1、判断当前队列是否被锁住，如果被锁住，表明有其他线程在处理该队列，不做尝试，直接返回。 2、如果没有被锁住，先加锁，保证处理期间其他线程不能操作队列。 3、取出队列中所有的trap，一个一个发送给server 4、释放锁，使得其他线程可以访问该队列。 线程池-ThreadPoolExecutor ConcurrentTrapQueue提供了支持并发的缓冲数据结构，我们还需要执行并发的线程池。我们使用executor框架提供的ThreadPoolExecutor来达到目的。 实现机制： 在SnmpTrapManager初始化时，创建线程池(线程池的创建)， 并不断的将各IP对应的ConcurrentTrapQueue丢到线程池中去执行。如何进行循环，一遍遍的将ConcurrentTrapQueue丢到线程池中去执行，这里使用了JAVA同步机制中非常重要的wait/notify机制。 wait/notify机制的简单介绍 JAVA中每个对象都有一个monitor对象（监视器）对象。线程获取了monitor对象，就获取了对应JAVA对象的锁。其他线程就会进入锁对应的等待队列/阻塞队列中。等待持有锁的线程释放锁，通知这些等待的线程去争抢锁。 Object.wait()：在对应对象上等待，等待其他持有该对象的线程通知唤醒 Object.notify()/notifyAll()：通知唤醒在该对象上wait的一个线程/所有线程 这是处理消费线程，每处理完一轮，最多等1s。如果有新来的trap，及时进行响应处理。 在接收trap端，每收到一条trap，就通知消费线程立即处理。 如何发送给server端 实现机制大致如下： 在server端的trapServiceImpl调用engine端的TrapFacadeImpl来开始监听的时候，就注册在发送trap时应该调用的回调函数callback类。从而对每一条trap，就知道怎样进行发送。 代码见上面的3.3小节。 4.2 trapparser将trap转成event不同设备的trap有不同的特征，在转成event时也需要不同的处理。所以，按照设备类型进行划分为几个不同的trapParser，分别用来处理不同设备类型的trap。 那么，如何让trap被正确的trapParser处理呢？这里使用的方式时，遍历调用每个trapParser的parse方法，命中则返回false，告知已经找到正确trapParser，遍历停止。如果返回true，表示trap不应被该trapParser处理，继续寻找。解析顺序：cos值越小越靠前。 我们可以关注下这种设计模式，它有几点值得我们学习： 将不同设备类型的trap处理封装成独立的类，避免难以维护的trap处理类。 采用各trapParser注册的模式，避免在分发trap给不同trapParser时硬编码各trap类。 巧妙使用parse()接口，不能处理的返回true，继续遍历寻找合适的trapParser，自己能处理的trap返回false停止遍历。而不是if-else或者switch这种硬编码。 TrapParser.parser()区分机制：设备上报的trap，1.3.6.1.6.3.1.1.4.1.0 这个节点标识trap的类型，区分是哪一种alarm还是eventOLT发送的trap，1.3.6.1.4.1.17409.2.2.11.1.2.4.0 标识trap的codeCCMTS发送的trap，1.3.6.1.2.1.69.1.5.8.1.6.0 标识trap的code 结合这些节点，根据业务逻辑的需要，判断上报的trap是否应该被当前trapParser解析。 Trap如何转成event EventSend EventSender是事件event分发器，它也采用了队列缓冲加处理线程消费队列的模式来解耦做什么（分发event）和怎么做（怎么分发）。 以单例模式创建EventSend 循环从event队列中消费,发送event insertEvent是不是很熟悉，eventParser的实现策略跟前面的trapParser是一致的，唯一不同的这里面符合条件的返回true，跟trapParser是反过来的。不是很清楚为什么弄成相反的。 4.3 eventparser根据event生成告警或者清除告警最顶层的是抽象类EventParser，提供了一些抽象方法让子类实现，也提供了最重要的doEvent()方法，实现了几乎所有event都需要经历的处理逻辑。 EventParser和TrapParser有个最重要的区别在于：TrapParser目前基本定死了有4种，如果某条trap一个都不符合，就会被丢弃，不处理。EventParser不一样，有太多种不同的event，所以这里面的设计策略是自定义的EventParser按照一定的优先级排号顺序依次执行，匹配上就结束。如果没有跟自定义的EventParser匹配上，就会调用默认实现的DefaultEventParser去处理，起到一个兜底的作用。 我们一起看看如何实现eventParser的优先级排序机制： eventPriority 自定义的eventParser只需要将自己的cos设置为大于0即可。 潜在隐患：有些eventParser没有修改默认值，就为0。而defaultEventParser也没有修改默认值，也是0。这样，就没有办法保证defaultEventParser一定是在最后，建议将defaultEventParser的cos设置为-1。 4.4 EventParserEventParser主要用于拿event跟数据库中的alert进行比对，来判断是否生成/清除告警。而操作数据库属于I/O操作，可能会被阻塞住。所以与trapParser不同，eventParser使用了队列缓冲+消费线程的模式来处理。parse()方法将event存入缓冲队列，消费线程不断取出event，进行处理。 4.5 doEvent这个方法非常关键，理解它是理解告警触发机制的核心。 我们先来了解一些基本概念：事件event与告警alert的关系存放在event2alert表中，并且：每一个告警事件都可能对应多种网管侧的告警类型（eventType），生成多条告警（一般产生告警只会对应一个）每一个清除事件都可能清除多种告警类型（eventType）的告警 针对每一个event，找到与之对应的所有alertType，针对每一个alertType,查找系统中当前是否有对应的alert。由此hyansheng衍生出以下4种情况： 数据库中存在告警，当前event是清除事件 数据库中存在告警，当前event是产生事件 数据库中不存在告警，当前event是清除事件 数据库中不存在告警，当前event是产生事件]]></content>
      <categories>
        <category>NM3000</category>
      </categories>
      <tags>
        <tag>NM3000</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找]]></title>
    <url>%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE.html</url>
    <content type="text"><![CDATA[二分查找法是对一组有序的数字中进行查找，传递相应的数据，进行比较查找到与原数据相同的数据，查找到了返回对应的数组下标，没有找到返回-1； 1、基本二分查找实现 while循环 1234567891011121314151617181920212223/** * 循环实现 * @param array 已排序数组 * @param target 目标 * @return 找不到返回-1，找到返回下标 */private static int binarySearch(int[] array, int target) &#123; int low = 0; int high = array.length - 1; while (low &lt;= high) &#123; int mid = low + (high - low) / 2; //注意此处写法，避免越界 if (array[mid] &gt; target) &#123; high = mid - 1; &#125; else if (array[mid] &lt; target) &#123; low = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125; 递归实现 123456789101112131415private static int binarySearch(int[] array, int target, int low, int high) &#123; int mid = low + (high - low) / 2; if (array[mid] == target) &#123; return mid; &#125; if (low &gt;= high) &#123; return -1; &#125; else if (target &gt; array[mid]) &#123; return binarySearch(array, target, mid + 1, high); &#125; else if (target &lt; array[mid]) &#123; return binarySearch(array, target, low, mid - 1); &#125; return -1;&#125; 2、变形随着二分查找的进行，如果找到key并不结束循环的话，最终的结束状态会是right &lt; left，并且right + 1 = left。 当数组中存在key时，根据二分区间选择的不同，这里又分为两种情况，如下图（key为2时） 当数组中不存在key时，最后仅有一种情况，即把图中的红色框框去掉。 那么，可以找到： 最后一个小于key的元素 1 左right 第一个大于等于key的元素 2 左left 最后一个小于等于key的元素 2 右right 第一个大于key的元素 5 右left 另外，如果存在多个key时，稍加判断，就可以找到 第一个与key相等的元素 最后一个与key相等的元素 123456789while (left &lt;= right) &#123; mid = (left + right) / 2; if (key ? arr[mid]) &#123; right = mid - 1; &#125; else &#123; left = mid + 1; &#125;&#125;return ?; 根据要求的值的位置，先确定比较符号，再确定返回值，比较符号：左&lt;=，右&lt;返回值：左right，右left 2.1 查找最后一个小于key的元素12345678910111213141516//1 查找最后一个小于key的元素int findLastLess(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt;= arr[mid]) &#123; // &lt;= 意为左 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return right; //返回左边值right&#125; 2.2 查找第一个大于等于key的元素12345678910111213141516//2 查找第一个大于等于key的元素int findLastLess(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt;= arr[mid]) &#123; // &lt;= 意为左 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; //返回右边值left&#125; 2.3 查找最后一个小于等于key的元素12345678910111213141516//3 查找第一个大于等于key的元素int findLastLess(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt; arr[mid]) &#123; // &lt;= 意为右 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return right; //返回左边值right&#125; 2.4 查找第一个大于key的元素12345678910111213141516//4 查找第一个大于key的元素int findLastLess(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt; arr[mid]) &#123; // &lt;= 意为右 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; return left; //返回右边值left&#125; 2.5 查找第一个与key相等的元素123456789101112131415161718192021//5 查找第一个与key相等的元素int findFirstEqual(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt;= arr[mid]) &#123; // &lt;= 意为左 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //right是最后一个小于key的 //left是第一个大于等于key的 if (left &lt; len &amp;&amp; arr[left] == key) &#123; return left; &#125; return -1;&#125; 2.6 查找最后一个与key相等的元素123456789101112131415161718192021//6 查找最后一个与key相等的元素int findLastEqual(int arr[], int len, int key) &#123; int left = 0; int right = len - 1; int mid; while (left &lt;= right) &#123; mid = left + (right - left) / 2; if (key &lt; arr[mid]) &#123; // &lt; 意为右 right = mid - 1; &#125; else &#123; left = mid + 1; &#125; &#125; //right是最后一个小于key的 //left是第一个大于等于key的 if (right &gt;= 0 &amp;&amp; arr[right] == key) &#123; return right; &#125; return -1;&#125; 参考资料你真的会写二分查找吗？-搏风雨]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见排序算法]]></title>
    <url>%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[我们通常所说的排序算法往往指的是内部排序算法，即数据记录在内存中进行排序。 排序算法大体可分为两种： 比较排序时间复杂度O(nlogn) ~ O(n^2)，主要有：冒泡排序，选择排序，插入排序，归并排序，堆排序，快速排序等。 非比较排序时间复杂度可以达到O(n)，主要有：计数排序，基数排序，桶排序等。 1、冒泡排序(Bubble Sort)冒泡排序算法的运作如下： 比较相邻的元素，如果前一个比后一个大，就把它们两个调换位置。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。冒泡排序的代码如下： 12345678910111213141516171819202122232425262728/** * 冒泡排序算法：平均o(n^2) 稳定 相邻两个比较，最大或最小的移到最右边 * * @author xiaoyue * @created @2018年3月6日-下午7:16:01 * */public class BubbleSort &#123; public static void main(String[] args) &#123; int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;; // 从小到大冒泡排序 int size = A.length; for (int i = 0; i &lt; size - 1; i++) &#123;// 每次最大元素就像气泡一样"浮"到数组的最后 for (int j = 0; j &lt; size - 1 - i; j++) &#123; //依次比较相邻的两个元素,使较大的那个向后移 if (A[j] &gt; A[j + 1]) &#123; // 如果条件改成A[j] &gt;= A[j + 1],则变为不稳定的排序算法 int temp = A[j]; A[j] = A[j + 1]; A[j + 1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; size; i++) &#123; System.out.print(A[i] + ", "); &#125; &#125;&#125; 2、选择排序(Selection Sort)选择排序也是一种简单直观的排序算法。它的工作原理很容易理解：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 注意选择排序与冒泡排序的区别：冒泡排序通过依次交换相邻两个顺序不合法的元素位置，从而将当前最小（大）元素放到合适的位置；而选择排序每遍历一次都记住了当前最小（大）元素的位置，最后仅需一次交换操作即可将其放到合适的位置。 1234567891011121314151617181920212223public static void main(String[] args) &#123; int A[] = &#123; 8, 5, 2, 6, 9, 3, 1, 4, 0, 7 &#125;; // 从小到大选择排序 int size = A.length; for (int i = 0; i &lt; size - 1; i++) &#123;//循环比对次数，除了最后一个数 int min = i; for (int j = i + 1; j &lt; size; j++) &#123;//选择用来比对的数，从当前下一位到最后一位 if (A[j] &lt; A[min]) &#123; min = j; &#125; &#125; if (min != i) &#123; //放到已排序序列的末尾，该操作很有可能把稳定性打乱，所以选择排序是不稳定的排序算法 int temp = A[i]; A[i] = A[min]; A[min] = temp; &#125; &#125; for (int i = 0; i &lt; size; i++) &#123; System.out.print(A[i] + ", "); &#125; &#125; 3、插入排序(Insertion Sort)具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 12345678910111213141516171819public static void main(String[] args) &#123; int A[] = &#123; 6, 5, 3, 1, 8, 7, 2, 4 &#125;;// 从小到大插入排序 int size = A.length; for (int i = 1; i &lt; size; i++) &#123; int get = A[i];// 右手抓到一张扑克牌 int j = i - 1;// 拿在左手上的牌总是排序好的 while (j &gt;= 0 &amp;&amp; A[j] &gt; get) &#123;// 将抓到的牌与手牌从右向左进行比较 A[j + 1] = A[j];// 如果该手牌比抓到的牌大，就将其右移 j--; &#125; A[j + 1] = get;// 直到该手牌比抓到的牌小(或二者相等)，将抓到的牌插入到该手牌右边 //(相等元素的相对次序未变，所以插入排序是稳定的) &#125; for (int i = 0; i &lt; size; i++) &#123; System.out.print(A[i] + ", "); &#125; &#125; 4、快速排序(Quick Sort)快速排序使用分治策略(Divide and Conquer)来把一个序列分为两个子序列。步骤为： 从序列中挑出一个元素，作为”基准”(pivot). 把所有比基准值小的元素放在基准前面，所有比基准值大的元素放在基准的后面（相同的数可以到任一边），这个称为分区(partition)操作。 对每个分区递归地进行步骤1~2，递归的结束条件是序列的大小是0或1，这时整体已经被排好序了。 1234567891011121314151617181920212223242526272829303132333435public static void main(String[] args) &#123; int a[] = &#123; 49, 37, 65, 97, 76, 13, 27, 49, 78 &#125;; int low = 0; int high = a.length-1; quickSort(a, low, high); for (int i = 0; i &lt; a.length; i++) &#123; System.out.print(a[i]+" "); &#125;&#125;private static void quickSort(int[] a, int low, int high) &#123; int i = low,j = high; if (i &gt; j) &#123; return; &#125; while (i &lt; j) &#123; while (i&lt;j &amp;&amp; a[j]&gt;=a[low]) &#123;//从后往前找小于基准数的位置 j--; &#125; while (i&lt;j &amp;&amp; a[i]&lt;=a[low]) &#123;//从前往后找大于基准数的位置 i++; &#125; if (i &lt; j) &#123;//注意，i,j不能相遇或交叉 swap(a,i,j); &#125; &#125; swap(a, low, j); quickSort(a, low, j-1); quickSort(a, j+1, high);&#125; Arrays.sort()Java系统提供的Arrays.sort函数。对于基础类型，底层使用快速排序。对于非基础类型，底层使用归并排序。请问是为什么？ 答：这是考虑到排序算法的稳定性。对于基础类型，相同值是无差别的，排序前后相同值的相对位置并不重要，所以选择更为高效的快速排序，尽管它是不稳定的排序算法；而对于非基础类型，排序前后相等实例的相对位置不宜改变，所以选择稳定的归并排序。 参考资料常用排序算法总结(一)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC(4)——requestMapping及controller返回值]]></title>
    <url>%2FSpring-MVC-4-%E2%80%94%E2%80%94requestMapping%E5%8F%8Acontroller%E8%BF%94%E5%9B%9E%E5%80%BC.html</url>
    <content type="text"><![CDATA[集中参数绑定方式及返回值类型。 1、RequestMappingrequestMapping注解的作用：对controller方法进行映射。 1.1 URL路径映射requestMapping指定url，对controller方法进行映射。 12@RequestMapping("/queryBook")public ModelAndView getBookById() &#123; 1.2 窄化请求路径为了更好的管理url，为了避免url冲突，可以在class上使用requestMapping指定根url。 123@Controller@RequestMapping("/books")//指定请求根路径public class Controller1 &#123; 在开发时候，需要提前进行url规划，以避免后期修改url后，需要大量修改页面上的url地址。 1.3 请求方法限定通过requestMapping限制http的请求方法，可以提高系统安全性。 12@RequestMapping(value="/queryBook",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)public ModelAndView getBookById() &#123; 2、Controller方法的返回值2.1 返回ModelAndViewcontroller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定逻辑视图名。 2.2 返回void类似于原始servlet开发。 123456@RequestMapping("/queryItemsReturnVoid")public void queryItemsReturnVoid(HttpServletRequest request,HttpServletResponse response,Integer[] ids)&#123; List&lt;Item&gt; itemsList = itemService.findItemsList(ids); request.setAttribute("itemsList", itemsList); request.getRequestDispatcher("/WEB-INF/jsp/itemsList.jsp").forward(request, response);&#125; 响应结果的三种方法： 使用request转发页面，如下 1request.getRequestDispatcher("页面路径").forward(request, response); 使用response页面重定向 1response.sendRedirect("url") 通过response指定响应结果，如响应json数据 123response.setCharacterEncoding("utf-8");response.setContentType("application/json;charset=utf-8");response.getWriter().write("json串"); 2.3 返回String(推荐)2.3.1 页面转发方式格式：forward:转发地址（不能写http://，只能写action的地址）特点：转发的上一个请求request和要转发的地址共用request，转发后浏览器的地址是不变化。 12345678910111213141516@RequestMapping(value="/queryBook",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)public String getBookById() &#123; Book book = bookService.findById(1000l); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("book", book); modelAndView.setViewName("bookDetail"); return "forward:/books/queryItemsReturnVoid.do";&#125;@RequestMapping("/queryItemsReturnVoid")public void queryItemsReturnVoid(HttpServletRequest request,HttpServletResponse response,Integer[] ids) throws ServletException, IOException&#123; //List&lt;Item&gt; itemsList = itemService.findItemsList(ids); request.setAttribute("itemsList", 111); request.getRequestDispatcher("/WEB-INF/jsp/itemsList.jsp").forward(request, response);&#125; 2.3.2 页面重定向方式格式是：redirect:重定向地址（比如：http://.....）特点：重定的上一个请求request和要重定的地址不公用request，重定后浏览器的地址是变化的。 12345678910111213141516@RequestMapping(value="/queryBook",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)public String getBookById() &#123; Book book = bookService.findById(1000l); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("book", book); modelAndView.setViewName("bookDetail"); return "redirect:/books/queryItemsReturnVoid.do";&#125;@RequestMapping("/queryItemsReturnVoid")public void queryItemsReturnVoid(HttpServletRequest request,HttpServletResponse response,Integer[] ids) throws ServletException, IOException&#123; //List&lt;Item&gt; itemsList = itemService.findItemsList(ids); request.setAttribute("itemsList", 111); request.getRequestDispatcher("/WEB-INF/jsp/itemsList.jsp").forward(request, response);&#125; 2.3.3 表示逻辑视图名返回一个string如果即不是转发格式，也不是重定向的格式，就表示一个逻辑视图名。 12345@RequestMapping(value="/queryBook",method=&#123;RequestMethod.GET,RequestMethod.POST&#125;)public String getBookById() &#123; return "bookDetail";&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC(3)——参数绑定]]></title>
    <url>%2FSpring-MVC-3-%E2%80%94%E2%80%94%E5%8F%82%E6%95%B0%E7%BB%91%E5%AE%9A.html</url>
    <content type="text"><![CDATA[springmvc接收请求的key/value串（比如：id=2&amp;type=101），经过类型转换，将转换后的值赋值给controller方法的形参，这个过程就叫参数绑定。 1、默认支持的类型在controller方法形参中如下类型是可以直接绑定成功，springmvc框架给以下类型的参数直接赋值： HttpServletRequest：通过request对象获取请求信息 HttpServletResponse：通过response处理响应信息 HttpSession：通过session对象得到session中存放的对象 Model/ModelMap：ModelMap是Model接口的实现类，通过Model或ModelMap向页面传递数据，如下： 123//调用service查询商品信息Items item = itemService.findItemById(id);model.addAttribute("item", item); 页面通过${item.XXXX}获取item对象的属性值。 使用Model和ModelMap的效果一样，如果直接使用Model，springmvc会实例化ModelMap。 2、基本类型基本类型类型：Integer、string、boolean、float。。。 绑定规则： 对于基本类型参数绑定，当请求的参数的名称和controller方法的形参名一致时可以绑定成功。 如果请求的参数的名称和controller方法的形参名不一致时，如何绑定？就要使用@RequestParam进行绑定： 使用方法如下：@RequestParam(value=”ids”) Integer id,将请求的参数名为ids的值绑定方法形参的id上。required：是否必须，默认是true，表示请求中一定要有相应的参数，否则将报；TTP Status 400 - Required Integer parameter ‘XXXX’ is not present;defaultValue：默认值，表示如果请求中没有同名参数时的默认值 3、简单pojo简单pojo：pojo中都基本类型，没有包括自定义pojo属性。 页面参数名称的定义： 12345678&lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="name" value="$&#123;item.name&#125;"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;价格&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="price" value="$&#123;item.price&#125;"/&gt;&lt;/td&gt;&lt;/tr&gt; controller方法的参数定义： 12@RequestMapping("editItem")public ModelAndView editItem(Item item) throws Exception &#123; 当页面参数名称和controller方法的pojo的参数的属性名一致，可以将请求的参数绑定到pojo形参的属性中。 4、包装类pojo包装类型pojo：pojo中属性也是一个pojo。 页面请求参数名称定义： 1234567&lt;tr&gt; &lt;td&gt;名称&lt;/td&gt; &lt;td&gt;&lt;input type="text" name="item.name"/&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt; &lt;td&gt;&lt;input type="submit" value="查询"/&gt;&lt;/td&gt;&lt;/tr&gt; controller方法形参的定义： 12@RequestMapping(/queryItems)public ModelAndView queryItems(ItemsQueryVo itemsQueryVo) throws Exception &#123; 包装类型的pojo绑定规则：item是包装pojo(ItemsQueryVo)的属性名。item.name中name就是包装pojo(ItemsQueryVo)中属性item的一个属性。 5、数组需求： 在商品查询列表页面批量选择商品进行删除。 页面要提交多个商品id，controller方法使用数组接收页面提交的参数。页面参数名称定义： 12345678&lt;c:forEach var="item" items="$&#123;itemsList&#125;"&gt; &lt;tr&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;"&gt;&lt;/td&gt; &lt;td&gt;&lt;input type="checkbox" name="delete_id" value="$&#123;item.id&#125;"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/c:forEach&gt; controller方法形参数定义： 12@RequestMapping(/deleteItems)public ModelAndView queryItems(Integer[] delete_id) throws Exception &#123; 绑定规则：如果请求多个参数且名称一致，可以绑定到和请求参数名一致的数组中。 6、List需求：实现商品信息批量修改功能，类似功能有成绩录入，一次录入好多门成绩，执行批量提交。 页面参数名称定义： 123&lt;td&gt;&lt;input type="text" name="itemsList[$&#123;status.index&#125;].name"/&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="itemsList[$&#123;status.index&#125;].prive"/&gt;&lt;/td&gt;&lt;td&gt;&lt;input type="text" name="itemsList[$&#123;status.index&#125;].createtime"/&gt;&lt;/td&gt; controller方法形参数定义: 12@RequestMapping(/queryItems)public ModelAndView queryItems(ItemsQueryVo itemsQueryVo) throws Exception &#123; itemsQueryVo定义： 123public class ItemsQueryVo &#123; private List&lt;Item&gt; itemsList; 7、自定义参数绑定问题：页面输入 2020-12-12 12:12:12(年月日时分秒)，springmvc默认提供年月日的绑定，没有对时分秒进行绑定。 解决问题：需要自定义参数绑定器，实现将页面输入年月日 时分秒全部转成日期类型数据。 自定义参数绑定器方法：自定义参数绑定器实现Conver，S表示源类型，T表示目标类型，S是页面请求的参数类型，即string，目标类型是要绑定到pojo的属性的类型，上边的例子T目标类型就是：Items中createtime属性类型即java.util.Date 开发自定义参数绑定器： 123456789101112131415public class DateConver implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String paramS) &#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); try &#123; return sdf.parse(paramS); &#125; catch (ParseException e) &#123; e.printStackTrace(); return null; &#125; &#125;&#125; 在springmvc.xml中在处理器适配器上配置参数绑定器： 12345678910&lt;!-- 简写 --&gt;&lt;mvc:annotation-driven conversion-service="conversionService"/&gt;&lt;bean id="conversionService" class="org.springframework.format.support.FormattingConversionServiceFactoryBean"&gt; &lt;property name="converters"&gt; &lt;list&gt; &lt;bean class="com.topvision.ssm.DateConver"&gt;&lt;/bean&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC(2)——整合spring-mybatis]]></title>
    <url>%2FSpring-MVC-2-%E2%80%94%E2%80%94%E6%95%B4%E5%90%88spring-mybatis.html</url>
    <content type="text"><![CDATA[这边博客介绍了springmvc与spring及mybatis的继承。 1、整合思路dao层： mybatis+spring 目标： 使用spring对sqlSessionFactory进行管理 使用spring和mybatis整合包中的mapper扫描器对mapper接口进行扫描生成代理对象。 service层： spring 目标： 让spring管理service类，将mapper代理对象注入到service对象中。 spring要对service方法执行进行事务控制 controller层： springmvc+spring 目标： 使用注解处理器映射器和适配器进行开发Handler Handler使用组件扫描方式在spring容器中进行注册 2、工程搭建2.1 创建maven web工程2.2 设置jar包依赖(pom设置)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.topvision.maven&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ssm Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 属性 --&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;!-- 锁定版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-library&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 2.3 配置service加入spring。 2.3.1 web.xml配置spring监听器，设置spring核心文件的位置。 123456789101112131415&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1" metadata-complete="true"&gt; &lt;!-- applicationContext对象仅加载一次，在服务器器启动时加载 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;/web-app&gt; 2.3.2 spring核心文件依据上一步的设置，在classpath下新建applicationContext.xml 设置spring约束的文件头 123456789101112&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt; &lt;/beans&gt; 开启注解功能，并设置扫描路径 123456&lt;!-- 1、开启注解、自动扫描 --&gt;&lt;context:annotation-config /&gt;&lt;context:component-scan base-package="com.topvision.ssm"&gt; &lt;context:exclude-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt;&lt;/context:component-scan&gt; 注意： 在配置扫描路径时，要避免对Controller注解的扫描，目的是将该注解所标识的bean交给springmvc管理而不是spring管理。 加载属性文件，如数据库配置文件 12345678910&lt;!-- 2、加载properties --&gt;&lt;!-- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; --&gt;&lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; 依上在classpath下新建jdbc.properties文件。 1234s2sm.jdbc.driverClass = com.mysql.jdbc.Drivers2sm.jdbc.url = jdbc:mysql://localhost:3306/springdbs2sm.jdbc.username = roots2sm.jdbc.password = 123 设置数据源 123456789101112131415 &lt;!--3、 数据库C3P0 --&gt;&lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;s2sm.jdbc.driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;s2sm.jdbc.url&#125;" /&gt; &lt;property name="user" value="$&#123;s2sm.jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;s2sm.jdbc.password&#125;" /&gt; &lt;property name="initialPoolSize" value="$&#123;s2sm.cpool.initialPoolSize&#125;" /&gt; &lt;property name="minPoolSize" value="$&#123;s2sm.cpool.minPoolSize&#125;" /&gt; &lt;property name="maxPoolSize" value="$&#123;s2sm.cpool.maxPoolSize&#125;" /&gt; &lt;property name="acquireIncrement" value="$&#123;s2sm.cpool.acquireIncrement&#125;" /&gt; &lt;property name="maxIdleTime" value="$&#123;s2sm.cpool.maxIdleTime&#125;" /&gt; &lt;property name="acquireRetryAttempts" value="$&#123;s2sm.cpool.acquireRetryAttempts&#125;" /&gt; &lt;property name="acquireRetryDelay" value="$&#123;s2sm.cpool.acquireRetryDelay&#125;" /&gt;&lt;/bean&gt; 设置SqlSessionFactory 12345678910111213&lt;!-- 4、配置SqlSessionFactory对象 --&gt;&lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.topvision.ssm.domain" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;!-- &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; --&gt; &lt;property name="mapperLocations" value="classpath*:com/topvision/ssm/dao/mapper/*.xml" /&gt;&lt;/bean&gt; 扫描Dao层接口 1234567&lt;!-- 5、配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.topvision.ssm.dao" /&gt;&lt;/bean&gt; Spring事务 1234567&lt;!-- 5、事务,开启注解事务 --&gt;&lt;tx:annotation-driven transaction-manager="transactionManager" /&gt;&lt;!-- 事务管理器 --&gt;&lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt;&lt;/bean&gt; 2.4 配置Dao 根据上面SqlSessionFactory的设置，在classpath下新建SqlMapConfig.xml。 12345678&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt;&lt;/configuration&gt; 2.5 整合Controller2.5.1 配置springmvc前端控制器123456789101112131415161718&lt;servlet&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--设置springmvc核心文件路径--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt; &lt;!-- *.action,*.do等，以其结尾的url交由springmvc管理 / 所有请求交由springmvc，但静态资源（css,js等）交由springmvc是不对的 /* 此种配置不正确，当请求为jsp页面时，springmvc无法解析 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.5.2 springmvc核心文件1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 可以扫描标记有@controller、@service、@repository、@component的bean --&gt; &lt;context:component-scan base-package="com.topvision.ssm.controller"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!-- 注解的处理器映射器和适配器 --&gt; &lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter" /&gt; --&gt; &lt;!-- 简写 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- ViewResolver --&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/jsp/" /&gt; &lt;property name="suffix" value=".jsp" /&gt; &lt;/bean&gt; &lt;!--静态资源默认servlet配置 (1)加入对静态资源的处理：js,gif,png (2)允许使用"/"做整体映射 --&gt; &lt;!-- &lt;mvc:default-servlet-handler/&gt; --&gt;&lt;/beans&gt; 2.5.3 开发Controller12345678910111213141516171819&lt;!--该注解标识handler--&gt;@Controllerpublic class Controller1 &#123; @Autowired private BookService bookService; &lt;!--该注解标识请求路径--&gt; @RequestMapping("/queryBook") public ModelAndView getBookById() &#123; Book book = bookService.findById(1000l); ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject("book", book); modelAndView.setViewName("bookDetail"); return modelAndView; &#125;&#125;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring MVC(1)——入门]]></title>
    <url>%2FSpring-MVC-1-%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[Spring MVC全称是Spring Web MVC,是spring框架中的一部分，与struts一样是一个表现层框架。 Spring MVC是当前最优秀的MVC框架，自从Spring2.5版本发布后，由于支持注解配置，易用性有了大幅度的提高。Spring3.0更加完善，实现了对Struts2的超越。现在越来越多的开发团队选择了Spring MVC。 1、Spring MVC与Struts2对比! 加载机制：SpringMVC入口是servlet,Struts2入口是filter;servlet与filter区别 性能：SpringMVC优于Struts2Struts2基于类设计，每次请求实例化一个action对象，对应一个request上下文；SpringMVC基于方法设计，每次请求实例化一个方法对象，每个方法独享request上下文。 参数传递：Struts2使用类变量接收参数，多个方法共享；SpringMVC使用请求参数获取，方法独享 框架继承：spring MVC和Spring是无缝(无缝：无须数据格式转换，直接访问来自数据源数据格式)的。从这个项目的管理和安全上也比Struts2高。 拦截机制：spring mvc用的是独立的AOP方式实现，而struts2有自己的interceptor机制，这样导致了struts2的配置文件量又比spring mvc大。 Restful架构实现：spring mvc用的是独立的AOP方式实现，而struts2有自己的interceptor机制，这样导致了struts2的配置文件量又比spring mvc大；spring mvc用的是独立的AOP方式实现，而struts2有自己的interceptor机制，这样导致了struts2的配置文件量又比spring mvc大。 2、SpringMVC运行流程 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用HandlerMapping处理器映射器查找Handler。 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 HandlerAdapter调用处理器Handler Handler执行完成返回ModelAndView HandlerAdapter将Handler执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器，ViewReslover根据逻辑视图名解析View ViewReslover返回View DispatcherServlet对View进行渲染视图（即将模型数据填充至request域）。 DispatcherServlet响应用户 从以上流程可以看出几个主要的部件： 前端控制器DispatcherServlet(SpringMVC提供)作用：接收请求，相应结果有了前端控制器减少各各组件之间的耦合性，前端控制器相关于中央调度器 处理器映射器HandlerMapping(SpringMVC提供)作用：根据url查找Handler，比如：根据xml配置、注解方式查找Handler 处理器适配器HandlerAdapter(SpringMVC提供)作用：执行Handler不同类型的Handler有不同的HandlerAdapter，好处可以通过扩展HandlerAdapter支持更多类型的Handler。 处理器Handler（由程序员开发）作用：业务处理实现开发中又称为controller即后端控制器Handler的开发按照HandlerAdapter的接口规则去开发。Handler处理后的结果是ModelAndView，是springmvc的底层对象，包括Model和view两个部分。view中只包括一个逻辑视图名（为了方便开发起一个简单的视图名称）。 ViewReslover视图解析（springmvc框架提供）作用：根据逻辑视图名创建一个View对象（包括真实视图物理地址）针对不同类型的view有不同类型的ViewReslover，常用的有jsp视图解析器即jstlView View视图（由程序员开发）作用：将模型数据填充进来(将model数据填充到request域)显示给用户view是一个接口，实现类包括：jstlView、freemarkerView，pdfView 3、案例搭建使用maven构建基本工程结构 3.1 创建web项目3.2 设置jdk版本及servlet环境细节参见Maven学习与基本使用 3.3 导入jar包,设置pom123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.topvision.maven&lt;/groupId&gt; &lt;artifactId&gt;ssm&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;ssm Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 属性 --&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;!-- 锁定版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;ssm&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 3.4 配置前端控制器关键：在web.xml配置springmvc的前端控制器 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://java.sun.com/xml/ns/javaee" xmlns:web="http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" xsi:schemaLocation="http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd" id="WebApp_ID" version="2.5"&gt; &lt;servlet&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--若不配置此项，默认加载/WEB-INF/[servlet的名字]-servlet.xml--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springDispatcherServlet&lt;/servlet-name&gt; &lt;!-- *.action或*.do等等，以其结尾的url由springmvc来解析 / 所有请求都由springmvc解析，单静态资源的请求（html,css,js）由其解析是不对的 /* 此种配置方式不对，当转到jsp页面，springmvc会去解析jsp页面路径地址，无法解析成功 --&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 3.5 配置处理器映射器在3.4设置的地址下新建对应的xml文件，一般在classpath下新建springmvc.xml 在springmvc.xml中配置处理器映射器。（有多种） 12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.0.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-3.0.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-3.0.xsd"&gt; &lt;!-- 处理器映射器,选择其中之一即可--&gt; &lt;!--根据handel的名字来匹配url--&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"/&gt; &lt;!--升级版--&gt; &lt;!--根据handel的id来匹配url--&gt; &lt;bean class="org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"&gt; &lt;property name="mappings"&gt; &lt;props&gt; &lt;prop key="/ItemsList2.action"&gt;itemsController&lt;/prop&gt; &lt;prop key="/ItemsList3.action"&gt;itemsController&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 3.6 配置处理器适配器开发Handel必须按照处理器适配器接口规则去开发，先要确定使用哪个处理器适配器。此处使用SimpleControllerHandlerAdapter。 12&lt;!-- 处理器适配器 --&gt;&lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"/&gt; 通过源码分析得出：123public boolean supports(Object handler) &#123; return (handler instanceof Controller);&#125; 只要实现了Controller接口的bean，SimpleControllerHandlerAdapter都可以去执行。 还有一个非注解适配器HttpRequestHandlerAdapter，只要实现HttpRequestHandler接口即可。 3.7 开发及配置Handel12345678910111213141516171819202122232425public class ItemsController1 implements Controller &#123; @Override public ModelAndView handleRequest(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // 调用service查询商品信息 // 这里不调用service使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(9688f); items_2.setDetail("iphoneX苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); ModelAndView modelAndView = new ModelAndView(); //此方法相当于request.setAttribute(arg0, arg1) modelAndView.addObject(itemsList); //指定视图地址 modelAndView.setViewName("/WEB-INF/jsp/itemsList.jsp"); return modelAndView; &#125;&#125; 3.8 配置视图解析器使用jsp视图解析器，在springmvc.xml中配置如下： 123456&lt;!-- ViewResolver --&gt;&lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;!--设置统一的前后缀--&gt; &lt;property name="prefix" value="/WEB-INF/jsp/"/&gt; &lt;property name="suffix" value=".jsp"/&gt;&lt;/bean&gt; 更改Handle代码，使用逻辑视图名: 123//指定视图地址//modelAndView.setViewName("/WEB-INF/jsp/itemsList.jsp");modelAndView.setViewName("itemList"); 3.9 配置jsp视图在web-inf/jsp下，创建itemList.jsp 4、注解开发4.1 注解的处理器映射器和适配器注解的处理器映射器：spring3.1之前使用org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMappingspring3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping; 注解的处理器适配器：spring3.1之前使用org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter3.1之后使用org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter 在springmvc.xml中配置： 1234567&lt;!-- 注解的处理器映射器和适配器 --&gt;&lt;!-- &lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping"/&gt;&lt;bean class="org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter" /&gt;--&gt;&lt;!-- 简写 --&gt;&lt;mvc:annotation-driven/&gt; 4.2 注解开发Handle注解处理器映射器和注解处理器适配器要配对使用，对标记@controller注解类中的标记有@RequestMapping方法进行映射和执行。@controller标记此类是一个控制器@RequestMapping：对url和Handler中的方法进行映射。 1234567891011121314151617181920212223242526272829303132@Controllerpublic class ItemsController2 &#123; @RequestMapping("/itemsList4") public ModelAndView itemList4() &#123; // 调用service查询商品信息 // 这里不调用service使用静态数据模拟 List&lt;Items&gt; itemsList = new ArrayList&lt;Items&gt;(); Items items_1 = new Items(); items_1.setName("联想笔记本"); items_1.setPrice(6000f); items_1.setDetail("ThinkPad T430 联想笔记本电脑！"); Items items_2 = new Items(); items_2.setName("苹果手机"); items_2.setPrice(5000f); items_2.setDetail("iphone6苹果手机！"); itemsList.add(items_1); itemsList.add(items_2); ModelAndView modelAndView = new ModelAndView(); // 此方法相当于request.setAttribute(arg0, arg1) modelAndView.addObject(itemsList); // 指定视图地址 // modelAndView.setViewName("/WEB-INF/jsp/itemsList.jsp"); modelAndView.setViewName("itemsList"); return modelAndView; &#125;&#125; 4.3 在spring容器中配置Handle为方便配置，采用注解扫描的方式。 12&lt;!-- 可以扫描标记有@controller、@service、@repository、@component的bean --&gt;&lt;context:component-scan base-package="com.topvision.ssm"&gt;&lt;/context:component-scan&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis(5)——与spring整合]]></title>
    <url>%2FMybatis-5-%E2%80%94%E2%80%94%E4%B8%8Espring%E6%95%B4%E5%90%88.html</url>
    <content type="text"><![CDATA[整合spring 1、jar包spring相关、mybatis、mybatis-srping整合包、数据库、数据库驱动、日志等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.hamcrest&lt;/groupId&gt; &lt;artifactId&gt;hamcrest-library&lt;/artifactId&gt; &lt;version&gt;1.3&lt;/version&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2、spring配置文件在classpath下创建applicationContext.xml，定义数据库链接池、SqlSessionFactory。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd"&gt; &lt;!-- 开启注解、自动扫描 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package="com.topvision.ssm"/&gt; &lt;!-- 1、加载properties --&gt; &lt;!-- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:jdbc.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--2、 数据库C3P0 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;s2sm.jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;s2sm.jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;s2sm.jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;s2sm.jdbc.password&#125;"/&gt; &lt;property name="initialPoolSize" value="$&#123;s2sm.cpool.initialPoolSize&#125;" /&gt; &lt;property name="minPoolSize" value="$&#123;s2sm.cpool.minPoolSize&#125;" /&gt; &lt;property name="maxPoolSize" value="$&#123;s2sm.cpool.maxPoolSize&#125;" /&gt; &lt;property name="acquireIncrement" value="$&#123;s2sm.cpool.acquireIncrement&#125;" /&gt; &lt;property name="maxIdleTime" value="$&#123;s2sm.cpool.maxIdleTime&#125;"/&gt; &lt;property name="acquireRetryAttempts" value="$&#123;s2sm.cpool.acquireRetryAttempts&#125;"/&gt; &lt;property name="acquireRetryDelay" value="$&#123;s2sm.cpool.acquireRetryDelay&#125;"/&gt; &lt;/bean&gt; &lt;!-- 3.配置SqlSessionFactory对象 --&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;!-- 配置MyBaties全局配置文件:mybatis-config.xml --&gt; &lt;property name="configLocation" value="classpath:sqlMapConfig.xml" /&gt; &lt;!-- 扫描entity包 使用别名 --&gt; &lt;property name="typeAliasesPackage" value="com.topvision.ssm.domain" /&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;!-- &lt;property name="mapperLocations" value="classpath:mapper/*.xml" /&gt; --&gt; &lt;property name="mapperLocations" value="classpath*:com/topvision/ssm/dao/mapper/*.xml" /&gt; &lt;/bean&gt; &lt;!-- 4.配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中 --&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;!-- 注入sqlSessionFactory --&gt; &lt;property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" /&gt; &lt;!-- 给出需要扫描Dao接口包 --&gt; &lt;property name="basePackage" value="com.topvision.ssm.dao" /&gt; &lt;/bean&gt; &lt;!-- 5、事务,开启注解事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 3、mybatis配置文件在classpath下新建sqlMapConfig.xml。 1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;!--此处暂时不需要任何配置，基本配置已在applicationContext.xml的第三步中配置--&gt;&lt;/configuration&gt; 4、jdbc.properties和log4j.properties在classpath下新建这两个文件，注意参数。例如下方： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374s2sm.jdbc.driverClass = com.mysql.jdbc.Drivers2sm.jdbc.url = jdbc:mysql://localhost:3306/springdbs2sm.jdbc.username = roots2sm.jdbc.password = 123s2sm.cpool.maxIdleTimeExcessConnections = 1800##最常用配置s2sm.cpool.initialPoolSize = 50#连接池初始化时创建的连接数,default : 3，取值应在minPoolSize与maxPoolSize之间s2sm.cpool.minPoolSize = 10#连接池保持的最小连接数,default : 3s2sm.cpool.maxPoolSize = 100#连接池中拥有的最大连接数，如果获得新连接时会使连接总数超过这个值则不会再获取新连接，而是等待其他连接释放，所以这个值有可能会设计地很大,default : 15s2sm.cpool.acquireIncrement = 5#连接池在无空闲连接可用时一次性创建的新数据库连接数,default : 3##管理连接池的大小和连接的生存时间s2sm.cpool.maxIdleTime = 3600#连接的最大空闲时间，如果超过这个时间，某个数据库连接还没有被使用，则会断开掉这个连接。如果为0，则永远不会断开连接,即回收此连接。default : 0 单位 s。建议使用s2sm.cpool.maxIdleTimeExcessConnections = 1800#这个配置主要是为了快速减轻连接池的负载，比如连接池中连接数因为某次数据访问高峰导致创建了很多数据连接，但是后面的时间段需要的数据库连接数很少，需要快速释放，#必须小于maxIdleTime。其实这个没必要配置，maxIdleTime已经配置了。default : 0 单位 s（不建议使用）s2sm.cpool.idleConnectionTestPeriod = 900#每900秒检查所有连接池中的空闲连接s2sm.cpool.maxConnectionAge = 6000#配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制。default : 0 单位 s（不建议使用）##配置PreparedStatement缓存s2sm.cpool.maxStatements=500#连接池为数据源缓存的PreparedStatement的总数。由于PreparedStatement属于单个Connection,#所以这个数量应该根据应用中平均连接数乘以每个连接的平均PreparedStatement#来计算。同时maxStatementsPerConnection的配置无效。default : 0（不建议使用）s2sm.cpool.maxStatementsPerConnection=30#连接池为数据源单个Connection缓存的PreparedStatement数，这个配置比maxStatements更有意义，因为它缓存的服务对象是单个数据连接，#如果设置的好，肯定是可以提高性能的。为0的时候不缓存。default : 0（看情况而论）##重连相关配置 s2sm.cpool.acquireRetryAttempts=5#连接池在获得新连接失败时重试的次数，如果小于等于0则无限重试直至连接获得成功。default : 30（建议使用）s2sm.cpool.acquireRetryDelay=1000#两次连接中间隔时间，单位毫秒，连接池在获得新连接时的间隔时间。default : 1000 单位ms（建议使用）s2sm.cpool.checkoutTimeout = 100#配置当连接池所有连接用完时应用程序getConnection的等待时间。为0则无限等待直至有其他连接释放或者创建新的连接，#不为0则当时间到的时候如果仍没有获得连接，则会抛出SQLException。其实就是acquireRetryAttempts*acquireRetryDelay。#default : 0（与上面两个，有重复，选择其中两个都行）s2sm.cpool.breakAfterAcquireFailure = false#如果为true，则当连接获取失败时自动关闭数据源，除非重新启动应用程序。所以一般不用。default : false（不建议使用）##其他s2sm.cpool.autoCommitOnClose = false#连接池在回收数据库连接时是否自动提交事务。如果为false，则会回滚未提交的事务，如果为true，则会自动提交事务。default : false（不建议使用）s2sm.cpool.numHelperThreads=10#c3p0是异步操作的，缓慢的JDBC操作通过帮助进程完成。扩展这些操作可以有效的提升性能 通过多线程实现多个操作同时被执行。Default: 3 12345678910111213141516171819#定义LOG输出级别 log4j.rootLogger=info,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log#定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB #输出所有日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis(4)——Mapper.xml映射文件]]></title>
    <url>%2FMybatis-4-%E2%80%94%E2%80%94Mapper-xml%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6.html</url>
    <content type="text"><![CDATA[Mapper.xml映射文件中定义了操作数据库的sql，每个sql是一个statement，映射文件是mybatis的核心。 SQL 映射文件有很少的几个顶级元素（按照它们应该被定义的顺序）： cache – 给定命名空间的缓存配置。cache-ref – 其他命名空间缓存配置的引用。resultMap – 是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。parameterMap – 已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。sql – 可被其他语句引用的可重用语句块。insert – 映射插入语句update – 映射更新语句delete – 映射删除语句select – 映射查询语句下一部分将从语句本身开始来描述每个元素的细节。 1、parameterType(输入类型)1.1 传递简单类型123456789&lt;!-- 根据名称模糊查询用户信息 --&gt;&lt;select id="selectUserByName" parameterType="string" resultType="user"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt;&lt;!-- 根据id查询用户信息 --&gt;&lt;select id="selectUserById" parameterType="int" resultType="user"&gt; select * from user where userId = #&#123;id&#125;&lt;/select&gt; 1.2 传递pojoMybatis使用ognl表达式解析对象字段的值，如下例子： 1234&lt;!-- 传递pojo对象综合查询用户信息 --&gt;&lt;select id="findUserByUser" parameterType="user" resultType="user"&gt; select * from user where id=#&#123;id&#125; and username like '%$&#123;username&#125;%'&lt;/select&gt; id 和 username 都是 User对象里面的属性字段。 1.3 传递pojo包装对象123456public class QueryVo &#123; private User user; //自定义用户扩展类 private UserCustom userCustom; 1234&lt;!-- 传递pojo包装对象综合查询用户信息 --&gt;&lt;select id="findUserList" parameterType="queryVo" resultType="user"&gt; select * from user where id=#&#123;user.id&#125; and username like '%$&#123;user.username&#125;%'&lt;/select&gt; 1.4 传递hashmap1234&lt;!-- 传递hashmap综合查询用户信息 --&gt;&lt;select id="findUserByHashmap" parameterType="hashmap" resultType="user"&gt; select * from user where id=#&#123;id&#125; and username like '%$&#123;username&#125;%'&lt;/select&gt; id和username是map的key 2、resultType(输出类型)输出简单类型，输出pojo,输出pojo列表（list），输出hashmap 输出pojo对象和输出pojo列表在sql中定义的resultType是一样的。返回单个pojo对象要保证sql查询出来的结果集为单条，内部使用session.selectOne方法调用，mapper接口使用pojo对象作为方法返回值。 返回pojo列表表示查询出来的结果集可能为多条，内部使用session.selectList方法，mapper接口使用List对象作为方法返回值。 输出pojo对象可以改用hashmap输出类型，将输出的字段名称作为map的key，value为字段值。 3、resultMapresultType可以指定pojo将查询结果映射为pojo，但需要pojo的属性名和sql查询的列名一致方可映射成功。如果sql查询字段名和pojo的属性名不一致，可以通过resultMap将字段名和属性名作一个对应关系 ，resultMap实质上还需要将查询结果映射到pojo对象中。resultMap可以实现将查询结果映射为复杂类型的pojo，比如在查询结果映射对象中包括pojo和list实现一对一查询和一对多查询。 4、动态sql通过mybatis提供的各种标签方法实现动态拼接sql。 4.1 if1234567891011&lt;!-- 传递pojo综合查询用户信息 --&gt;&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user where 1=1 &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; 4.2 where1234567891011&lt;select id="findUserList" parameterType="user" resultType="user"&gt; select * from user &lt;where&gt; &lt;if test="id!=null and id!=''"&gt; and id=#&#123;id&#125; &lt;/if&gt; &lt;if test="username!=null and username!=''"&gt; and username like '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; where 元素知道只有在一个以上的if条件有值的情况下才去插入“WHERE”子句。而且，若最后的内容是“AND”或“OR”开头的，where 元素也知道如何将他们去除。 4.3 choose, when, otherwise有些时候，我们不想用到所有的条件语句，而只想从中择其一二。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。 123456789101112131415&lt;select id="findActiveBlogLike" resultType="Blog"&gt; SELECT * FROM BLOG WHERE state = ‘ACTIVE’ &lt;choose&gt; &lt;when test="title != null"&gt; AND title like #&#123;title&#125; &lt;/when&gt; &lt;when test="author != null and author.name != null"&gt; AND author_name like #&#123;author.name&#125; &lt;/when&gt; &lt;otherwise&gt; AND featured = 1 &lt;/otherwise&gt; &lt;/choose&gt;&lt;/select&gt; 4.4 foreach向sql传递数组或List，mybatis使用foreach解析，如下： 通过pojo传递list 12345&lt;if test="ids!=null and ids.size&gt;0"&gt; &lt;foreach collection="ids" open=" and id in(" close=")" item="id" separator="," &gt; #&#123;id&#125; &lt;/foreach&gt;&lt;/if&gt; 传递单个List 123456789101112&lt;select id="selectUserByList" parameterType="java.util.List" resultType="user"&gt; select * from user &lt;where&gt; &lt;!-- 传递List，List中是pojo --&gt; &lt;if test="list!=null"&gt; &lt;foreach collection="list" item="item" open="and id in(" separator="," close=")"&gt; #&#123;item.id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 传递单个数组（数组中是pojo） 12345678910111213 &lt;!-- 传递数组综合查询用户信息 --&gt;&lt;select id="selectUserByArray" parameterType="Object[]" resultType="user"&gt; select * from user &lt;where&gt; &lt;!-- 传递数组 --&gt; &lt;if test="array!=null"&gt; &lt;foreach collection="array" index="index" item="item" open="and id in(" separator="," close=")"&gt; #&#123;item.id&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; 传递单个数组（数组中是字符串类型） 12345678910111213 &lt;!-- 传递数组综合查询用户信息 --&gt;&lt;select id="selectUserByArray" parameterType="Object[]" resultType="user"&gt; select * from user &lt;where&gt; &lt;!-- 传递数组 --&gt; &lt;if test="array!=null"&gt; &lt;foreach collection="array" index="index" item="item" open="and id in(" separator="," close=")"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; SQL片段 感觉实际开发中不怎么使用，不利于维护。 5、#{}与\${} #{}实现的是向prepareStatement中的预处理语句中设置参数值，sql语句中#{}表示一个占位符即?。使用占位符#{}可以有效防止sql注入，在使用时不需要关心参数值的类型，mybatis会自动进行java类型和jdbc类型的转换。#{}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称 \${}和#{}不同，通过\${}可以将parameterType传入的内容拼接在sql中且不进行jdbc类型转换,\${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，\${}括号中只能是value，使用\${}不能防止sql注入。 模糊查询时，推荐使用\${} 1234&lt;!-- 根据名称模糊查询用户信息 --&gt;&lt;select id="selectUserByName" parameterType="string" resultType="user"&gt; select * from user where username like '%$&#123;value&#125;%'&lt;/select&gt; order by排序，如果将列名通过参数传入sql，根据传的列名进行排序，应该写为：ORDER BY \${columnName}如果使用#{}将无法实现此功能。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis(3)——SqlMapConfig.xml文件详解]]></title>
    <url>%2FMybatis-3-%E2%80%94%E2%80%94SqlMapConfig-xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[MyBatis 的配置文件包含了会深深影响MyBatis行为的设置（settings）和属性（properties）信息。 SqlMapConfig.xml中配置的内容和顺序如下： properties(属性) settings（全局配置参数） typeAliases(类型别名) typeHandlers（类型处理器） objectFactory（对象工厂） plugins（插件） environments(环境) environment 环境变量 transactionManager 事务管理器 dataSource 数据源 databaseIdProvider(数据库厂商标识) mappers（映射器） 1、Properties这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。例如：在工程的classpath下新建jdbc.properties文件。 1234jdbc.driverClass = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/springdb?characterEncoding=utf-8jdbc.username = rootjdbc.password = 123 在sqlMapConfig.xml中配置如下：1234&lt;properties resource="jdbc.properties"&gt; &lt;property name="username" value="dev_user"/&gt; &lt;property name="password" value="123456"/&gt;&lt;/properties&gt; 其中的属性就可以在整个配置文件中使用来替换需要动态配置的属性值。比如: 1234567&lt;!-- 数据库连接池 --&gt;&lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt;&lt;/dataSource&gt; 注意： MyBatis 将按照下面的顺序来加载属性： 在 properties 元素体内定义的属性首先被读取。 然后会读取properties 元素中resource或 url加载的属性，它会覆盖已读取的同名属性。 最后读取parameterType传递的属性，它会覆盖已读取的同名属性。 因此，通过parameterType传递的属性具有最高优先级，resource或 url 加载的属性次之，最低优先级的是 properties 元素体内定义的属性。 2、settings这是 MyBatis 中极为重要的调整设置，它们会改变MyBatis的运行时行为。下表描述了设置中各项的意图、默认值等。 参数 描述 有效值 默认值 cacheEnabled 该配置影响的所有映射器中配置的缓存的全局开关 true/false true Hermione Granger Gryffindor 100 Draco Malfoy Slytherin 90 具体配置见Mybatis 3。 3、typeAliases类型别名是为 Java 类型设置一个短的名字。它只和XML配置有关，存在的意义仅在于用来减少类完全限定名的冗余。mybatis自身已经支持了部分数据类型的别名，如：别名 | 映射的类型:-: | :-:_byte | byte_long | long_short | short 更多见Mybatis 3。 当然，我们需要自定义别名： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias="book" type="com.topvision.maven.mybatis.domain.Book"/&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &lt;package name="com.topvision.maven.mybatis.domain"/&gt; &lt;package name="其它包"/&gt;&lt;/typeAliases&gt; 4、typeHandlers类型处理器用于java类型和jdbc类型映射，如下: 123&lt;select id="findUserById" parameterType="int" resultType="user"&gt; select * from user where id = #&#123;id&#125;&lt;/select&gt; mybatis自带的类型处理器基本上满足日常需求，不需要单独定义。 5、environments1234567891011121314&lt;!-- 和spring整合后 environments配置将废除 --&gt;&lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 6、mappers既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要定义SQL映射语句了。但是首先我们需要告诉 MyBatis 到哪里去找到这些语句。Java在自动查找这方面没有提供一个很好的方法，所以最佳的方式是告诉MyBatis到哪里去找映射文件。你可以使用相对于类路径的资源引用， 或完全限定资源定位符（包括 file:/// 的 URL），或类名和包名等。例如： 使用相对于类路径的资源 1&lt;mapper resource="sqlmap/User.xml" /&gt; 使用完全限定路径 1&lt;mapper url="file:///D:\workspace_spingmvc\mybatis_01\config\sqlmap\User.xml" /&gt; 使用mapper接口类路径 1&lt;mapper class="com.topvision.mybatis.mapper.UserMapper"/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中. 注册指定包下的所有mapper接口 1&lt;package name="com.topvision.mybatis.mapper"/&gt; 注意：此种方法要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis(2)——Dao层开发方法]]></title>
    <url>%2FMybatis-2-%E2%80%94%E2%80%94Dao%E5%B1%82%E5%BC%80%E5%8F%91%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[mybatis的dao层通常有两种开发方式，原始dao开发及mapper接口发开方法。 1、SqlSession的使用范围SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。通过SqlSessionFactory创建SqlSession，而SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 1.1 SqlSessionFactoryBuilderSqlSessionFactoryBuilder用于创建SqlSessionFacoty，SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了，因为SqlSession是通过SqlSessionFactory生产，所以可以将SqlSessionFactoryBuilder当成一个工具类使用，最佳使用范围是方法范围即方法体内局部变量。 1.2 SqlSessionFactorySqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法，SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用，通常以单例模式管理SqlSessionFactory。 1.3 SqlSessionSqlSession是一个面向用户的接口，sqlSession中定义了数据库操作，默认使用DefaultSqlSession实现类。 执行过程如下：1、 加载数据源等配置信息 Environment environment = configuration.getEnvironment();2、 创建数据库链接3、 创建事务对象4、 创建Executor，SqlSession所有操作都是通过Executor完成5、 SqlSession的实现类即DefaultSqlSession，此对象中对操作数据库实质上用的是Executor 结论： 每个线程都应该有它自己的SqlSession实例。SqlSession的实例不能共享使用，它也是线程不安全的。因此最佳的范围是请求或方法范围。绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。 打开一个 SqlSession；使用完毕就要关闭它。通常把这个关闭操作放到 finally 块中以确保每次都能执行关闭。 2、原始Dao开发原始开发方式需要编写dao接口及接口实现类。 2.1 编写映射文件（sql）12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;select id="queryById" parameterType="long" resultType="com.topvision.maven.mybatis.domain.Book"&gt; select book_id bookId,name,number from book where book_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 2.2 编写Dao接口123public interface BookDao &#123; public Book queryById(long id);&#125; 2.3 编写Dao实现类123456789101112131415161718192021222324252627282930313233public class BookDaoImpl implements BookDao &#123; private SqlSessionFactory sqlSessionFactory; // 注入SqlSessionFactory public BookDaoImpl(SqlSessionFactory sqlSessionFactory) &#123; this.setSqlSessionFactory(sqlSessionFactory); &#125; @Override public Book queryById(long id) &#123; SqlSession sqlSession = null; Book book = null; try &#123; sqlSession = sqlSessionFactory.openSession(); book = sqlSession.selectOne("test.queryById", id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; sqlSession.close(); &#125; return book; &#125; public SqlSessionFactory getSqlSessionFactory() &#123; return sqlSessionFactory; &#125; public void setSqlSessionFactory(SqlSessionFactory sqlSessionFactory) &#123; this.sqlSessionFactory = sqlSessionFactory; &#125; &#125; 2.4 测试用例12345678910111213141516171819202122public class BookDaoImplTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException&#123; String resource = "sqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testQueryById() &#123; BookDao bookDao = new BookDaoImpl(sqlSessionFactory); Book book = bookDao.queryById(1000l); System.out.println(book); &#125;&#125; 3、Mapper接口开发Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。Mapper接口开发需要遵循以下规范：1、 Mapper.xml文件中的namespace与mapper接口的类路径相同。2、 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同3、 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql的parameterType的类型相同4、 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 3.1 Mapper.xml(映射文件)在classpath下新建mapper文件夹，新建BookMapper.xml 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="com.topvision.maven.mybatis.dao.BookDao"&gt; &lt;select id="queryById" parameterType="long" resultType="book"&gt; select book_id bookId,name,number from book where book_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 3.2 BookDao接口123public interface BookDao &#123; public Book queryById(long id);&#125; 接口定义有如下特点：1、 Mapper接口方法名和Mapper.xml中定义的statement的id相同2、 Mapper接口方法的输入参数类型和mapper.xml中定义的statement的parameterType的类型相同3、 Mapper接口方法的输出参数类型和mapper.xml中定义的statement的resultType的类型相同 3.3 加载BookMapper.xml123&lt;mappers&gt; &lt;mapper resource="mapper/BookMapper.xml"/&gt;&lt;/mappers&gt; 3.4 测试12345678910111213141516@Testpublic void testQueryByIdInProxy() &#123; SqlSession sqlSession = null; try &#123; sqlSession = sqlSessionFactory.openSession(); BookDao bookDao = sqlSession.getMapper(BookDao.class); Book book = bookDao.queryById(1000l); System.out.println(book); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125;&#125; 3.5 小结 electOne和selectList动态代理对象调用sqlSession.selectOne()和sqlSession.selectList()是根据mapper接口方法的返回值决定，如果返回list则调用selectList方法，如果返回单个对象则调用selectOne方法。 namespacemybatis官方推荐使用mapper代理方法开发mapper接口，程序员不用编写mapper接口实现类，使用mapper代理方法时，输入参数可以使用pojo包装对象或map对象，保证dao的通用性。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis(1)——入门]]></title>
    <url>%2FMybatis-1-%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis，实质上Mybatis对ibatis进行一些改进。MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码。Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回。 1、资源下载mybaits的代码由github.com管理，地址：https://github.com/mybatis/mybatis-3/releases要使用 MyBatis， 只需将 mybatis-x.x.x.jar 文件置于 classpath 中即可。 如果使用 Maven 来构建项目，则需将下面的 dependency 代码置于 pom.xml 文件中：12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;x.x.x&lt;/version&gt;&lt;/dependency&gt; 2、架构 SqlMapConfig.xmlmybatis的全局配置文件，配置了运行环境等信息。mapper.xml即映射文件，里面配置了操作数据库的sql语句，该类文件需要在SqlMapConfig.xml中加载。 SqlSessionFactory通过mybatis环境等配置信息构造SqlSessionFactory即会话工厂 SqlSession由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行 Executormybatis底层自定义了Executor执行器接口操作数据库，Executor接口有两个实现，一个是基本执行器、一个是缓存执行器。 Mapper Statementmybatis底层封装对象，它包装了mybatis配置信息及sql映射信息等。mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id。Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中，输入参数映射就是jdbc编程中对preparedStatement设置参数。Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo，Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中，输出结果映射过程相当于jdbc编程中对结果的解析处理过程。 3、特点 上边使用jdbc的原始方法（未经封装）实现了查询数据库表记录的操作。 JDBC编程问题总结：1、 数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。 解决：在SqlMapConfig.xml中配置数据链接池，使用连接池管理数据库链接2、 Sql语句在代码中硬编码，造成代码不易维护，实际应用sql变化的可能较大，sql变动需要改变java代码。解决：将Sql语句配置在XXXXmapper.xml文件中与java代码分离。3、 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。4、 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。 4、入门程序搭建需求:查询图书id查询图书信息 创建数据库，新建book表：1234567891011CREATE TABLE `book` ( `book_id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT '图书ID', `name` varchar(100) NOT NULL COMMENT '图书名称', `number` int(11) NOT NULL COMMENT '馆藏数量', PRIMARY KEY (`book_id`)) ENGINE=InnoDB AUTO_INCREMENT=1004 DEFAULT CHARSET=utf8 COMMENT='图书表'INSERT INTO `book` VALUES ('1000', 'Java程序设计', '10');INSERT INTO `book` VALUES ('1001', '数据结构', '10');INSERT INTO `book` VALUES ('1002', '设计模式', '10');INSERT INTO `book` VALUES ('1003', '编译原理', '10'); 4.1、maven创建java工程省略 4.2、引入依赖加入mybatis核心包、依赖包、数据驱动包。完整的pom配置如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.topvision.maven&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;mybatis&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.7.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;mybatis&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 4.3、log4j.properties在classpath下加入日志配置：12345678910111213141516171819#定义LOG输出级别 log4j.rootLogger=DEBUG,Console,File #定义日志输出目的地为控制台 log4j.appender.Console=org.apache.log4j.ConsoleAppender log4j.appender.Console.Target=System.out #可以灵活地指定日志输出格式，下面一行是指定具体的格式 log4j.appender.Console.layout = org.apache.log4j.PatternLayout log4j.appender.Console.layout.ConversionPattern=[%c] - %m%n #文件大小到达指定尺寸的时候产生一个新的文件 log4j.appender.File = org.apache.log4j.RollingFileAppender #指定输出目录 log4j.appender.File.File = logs/ssm.log#定义文件最大大小 log4j.appender.File.MaxFileSize = 10MB #输出所有日志，如果换成DEBUG表示输出DEBUG以上级别日志 log4j.appender.File.Threshold = ALL log4j.appender.File.layout = org.apache.log4j.PatternLayout log4j.appender.File.layout.ConversionPattern =[%p] [%d&#123;yyyy-MM-dd HH\:mm\:ss&#125;][%c]%m%n 4.4、jdbc.properties在classpath下新建数据库连接文件。 1234jdbc.driverClass = com.mysql.jdbc.Driverjdbc.url = jdbc:mysql://localhost:3306/springdb?characterEncoding=utf-8jdbc.username = rootjdbc.password = 123 4.4、SqlMapConfig.xml在classpath下新建SqlMapConfig.xml文件，配置mybatis运行环境。 1234567891011121314151617181920212223&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE configurationPUBLIC "-//mybatis.org//DTD Config 3.0//EN""http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&lt;configuration&gt; &lt;properties resource="jdbc.properties"/&gt; &lt;!-- 和spring整合后 environments配置将废除 --&gt; &lt;environments default="development"&gt; &lt;environment id="development"&gt; &lt;!-- 使用jdbc事务管理 --&gt; &lt;transactionManager type="JDBC" /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driverClass&#125;" /&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;" /&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;" /&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;" /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;/configuration&gt; SqlMapConfig.xml是mybatis核心配置文件，上边文件的配置内容为数据源、事务管理。 4.5、编写Po类Po类作为mybatis进行sql映射使用，po类通常与数据库表对应，Book.java如下:123456public class Book &#123; private long bookId;// 图书ID private String name;// 图书名称 private int number;// 馆藏数量 ... 4.6、编写映射文件（sql）在classpath下的sqlmap目录下创建sql映射文件Book.xml： 12345678910&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapperPUBLIC "-//mybatis.org//DTD Mapper 3.0//EN""http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="test"&gt; &lt;select id="queryById" parameterType="long" resultType="com.topvision.maven.mybatis.domain.Book"&gt; select book_id bookId,name,number from book where book_id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; namespace ：命名空间，用于隔离sql语句，后面会讲另一层非常重要的作用。parameterType：定义输入到sql中的映射类型，#{id}表示使用preparedstatement设置占位符号并将输入变量id传到sql。resultType：定义结果映射类型。 4.7、加载映射文件在SqlMapConfig.xml中加载映射文件Book.xml 123&lt;mappers&gt; &lt;mapper resource="sqlmap/Book.xml"/&gt;&lt;/mappers&gt; 4.8、测试123456789101112131415161718192021222324252627public class BookDaoTest &#123; private SqlSessionFactory sqlSessionFactory; @Before public void createSqlSessionFactory() throws IOException&#123; String resource = "sqlMapConfig.xml"; InputStream inputStream = Resources.getResourceAsStream(resource); sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); &#125; @Test public void testQueryById() &#123; SqlSession sqlSession = null; try &#123; sqlSession = sqlSessionFactory.openSession(); Book book = sqlSession.selectOne("test.queryById",1000l); System.out.println(book); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; if (sqlSession != null) &#123; sqlSession.close(); &#125; &#125; &#125;&#125; 至此，若能查询出结果，则工程搭建成功。]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql触发器]]></title>
    <url>%2FMysql%E8%A7%A6%E5%8F%91%E5%99%A8.html</url>
    <content type="text"><![CDATA[触发器（TRIGGER）是MySQL的数据库对象之一，从5.0.2版本开始支持。它和函数比较相似，也需要声明和执行，但是它不用程序或人工调用，而是由事件驱动的。 那么，什么是触发器？ 在MySQL Server里面也就是对某一个表的一定的操作，触发某种条件（Insert,Update,Delete 等），从而自动执行的一段程序。从这种意义上讲触发器是一个特殊的存储过程 1、语法12345CREATE TRIGGER trigger_nametrigger_time trigger_eventON tbl_nameFOR EACH ROW trigger_body trigger_name：触发器的名称，不能与已经存在的触发器重复； trigger_time：{ BEFORE | AFTER }，表示在事件之前或之后触发； trigger_event:：{ INSERT |UPDATE | DELETE }，触发该触发器的具体事件； tbl_name：该触发器作用在tbl_name上； trigger_body：sql语句 你必须拥有相当大的权限才能创建触发器（CREATE TRIGGER），如果你已经是Root用户，那么就足够了。这跟SQL的标准有所不同。 2、实例创建学生表 12345CREATE TABLE `student` ( `id` int(5) NOT NULL AUTO_INCREMENT, `classId` int(5) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 创建班级表 12345CREATE TABLE `class` ( `id` int(5) NOT NULL, `name` varchar(10) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 创建插入触发器 123456789CREATE TRIGGER tri_insertAFTER INSERT ON studentFOR EACH ROWBEGIN DECLARE c INT; SET c = (SELECT num from class WHERE id = new.classId); UPDATE class SET num = c + 1 WHERE id = new.classId;END 插入一条数据到student表，class表对应的班级学生数+1 3、变量详解MySQL 中使用 DECLARE 来定义一局部变量，该变量只能在 BEGIN … END 复合语句中使用，并且应该定义在复合语句的开头， 即其它语句之前，语法如下： 1DECLARE var_name[,...] type [DEFAULT value] var_name 为变量名称，同 SQL 语句一样，变量名不区分大小写； type 为 MySQL 支持的任何数据类型；可以同时定义多个同类型的变量，用逗号隔开； 变量初始值为 NULL，如果需要，可以使用DEFAULT子句提供默认值，值可以被指定为一个表达式。 对变量赋值采用 SET 语句，语法为： 1SET var_name = expr [,var_name = expr] ... 4、NEW 与 OLD 详解上述示例中使用了NEW关键字，和 MS SQL Server 中的 INSERTED 和 DELETED 类似，MySQL 中定义了 NEW 和 OLD，用来表示 触发器的所在表中，触发了触发器的那一行数据。具体地：在 INSERT 型触发器中，NEW用来表示将要（BEFORE）或已经（AFTER）插入的新数据；在 UPDATE 型触发器中，OLD用来表示将要或已经被修改的原数据，NEW用来表示将要或已经修改为的新数据；在 DELETE 型触发器中，OLD 用来表示将要或已经被删除的原数据； 使用方法： NEW.columnName （columnName 为相应数据表某一列名）另外，OLD 是只读的，而 NEW 则可以在触发器中使用 SET 赋值，这样不会再次触发触发器，造成循环调用（如每插入一个学生前，都在其学号前加“2013”）。 5、查看与删除触发器和查看数据库（show databases;）查看表格（showtables;）一样，查看触发器的语法如下： 1SHOW TRIGGERS [FROM schema_name]; 其中，schema_name 即 Schema 的名称，在 MySQL 中 Schema 和 Database 是一样的，也就是说，可以指定数据库名，这样就不必先“USE database_name;”了。 和删除数据库、删除表格一样，删除触发器的语法如下： 1DROP TRIGGER [IF EXISTS] [schema_name.]trigger_name 6、执行顺序我们建立的数据库一般都是 InnoDB 数据库，其上建立的表是事务性表，也就是事务安全的。这时，若SQL语句或触发器执行失败，MySQL 会回滚事务，有： ①如果 BEFORE 触发器执行失败，SQL 无法正确执行。②SQL 执行失败时，AFTER 型触发器不会触发。③AFTER 类型的触发器执行失败，SQL 会回滚。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(6)——Struts标签、国际化、文件上传下载]]></title>
    <url>%2FStruts2-6-%E2%80%94%E2%80%94Struts%E6%A0%87%E7%AD%BE%E3%80%81%E5%9B%BD%E9%99%85%E5%8C%96%E3%80%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD.html</url>
    <content type="text"><![CDATA[struts2标签的使用，国际化及文件上传下载。 1、struts标签Struts2标签库常用标签 2、国际化Struts2在ActionSupport中为我们提供了getText()来获取国际化value. 2.1 定义资源包 全局资源 创建资源文件 格式：基本名称_语言_国家.properties 例如：resources_zh_CN.properties resources_en_US.properties 指定文在所在位置及文件名 123 &lt;!-- 国际化资源文件路径及名称 --&gt;&lt;constant name="struts.custom.i18n.resources" value="com/topvision/s2sm/resources" /&gt; 包范围 在包下创建资源文件，不用在xml中指定文件路径 文件名：package_zh_CN.properties package_zh_CN.properties Action范围 在Action同级目录创建资源文件，不用在xml中指定文件路径。 文件名：ActionName_zh_CN.properties ActionName是对应action的名字 2.2 获取资源包内容获取国际化 Action： this.getText(key) Jsp: 使用标签， 配置文件:key(直接使用国际化配置文件中的key值即可获得) 自由选择消息资源包 1234&lt;!--自己随意指定消息资源包--&gt;&lt;s:i18n name="com/topvision/package"&gt; &lt;s:text name="key"&gt;&lt;/s:text&gt;&lt;/s:i18n&gt; 3、文件上传下载3.1 上传Struts2上传对表单有要求： post提交 表单的enctype必须为multipart/form-data 表单提供如下类型的input 1&lt;input type="file" name="name"/&gt; Struts2中如何实现文件上传的： 借助一个fileUpload拦截器完成的； 最底层的还是借助的commons-fileupload这个组件； 单文件上传 准备表单 1234&lt;form action="aaa/upload.tv" method="post" enctype="multipart/form-data"&gt; &lt;input type="file" name="upload"&gt; &lt;button type="submit"&gt;上传&lt;/button&gt;&lt;/form&gt; action 12345678910111213141516171819202122232425262728private File upload;//input标签的name属性private String uploadFileName; //name属性+FileNameprivate String uploadContentType;//name属性+ContentTypepublic String upload() throws IOException &#123; ServletContext servletContext = ServletActionContext.getServletContext(); String realPath = servletContext.getRealPath("/WEB-INF/file"); File file = new File(realPath); if (!file.exists()) &#123; file.mkdirs(); &#125; /*InputStream is = new FileInputStream(upload); OutputStream os = new FileOutputStream(new File(file, uploadFileName)); int len = -1; byte b[] = new byte[1024]; while ((len = is.read(b)) != -1) &#123; os.write(b, 0, len); &#125;*/ FileUtils.moveFile(upload, new File(file, uploadFileName)); is.close(); os.close(); return SUCCESS;&#125; 配置xml 123 &lt;action name="upload" class="com.topvision.s2sm.login.action.LoginAction" method="upload2"&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt;&lt;/action&gt; 多文件上传 第一种，比较煞笔的，多写几个上传框第二种:使用 uploadify 插件 3.2 下载action配置 1234567891011121314private InputStream inputStream;public String download() throws FileNotFoundException &#123; ServletContext servletContext = ServletActionContext.getServletContext(); String realPath = servletContext.getRealPath("/WEB-INF/web.xml"); inputStream = new FileInputStream(realPath); return SUCCESS;&#125;public InputStream getInputStream() &#123; return inputStream;&#125;public void setInputStream(InputStream inputStream) &#123; this.inputStream = inputStream;&#125; xml配置 123456789101112&lt;result name="success" type="stream"&gt; &lt;!-- 设置输入流来源 --&gt; &lt;param name="inputstream"&gt;inputstream&lt;/param&gt; &lt;!-- 响应头 --&gt; &lt;param name="contentDisposition"&gt;attachment;filename=web.xml&lt;/param&gt; &lt;!-- 传的什么类型数据，在tomcat的web.xml中有定义 --&gt; &lt;param name="contentType"&gt;application/xml&lt;/param&gt; &lt;!-- 下载缓存 ,默认1024--&gt; &lt;param name="bufferSize"&gt;10240&lt;/param&gt; &lt;!-- 下载文件大小 --&gt; &lt;param name="contentLength"&gt;10240&lt;/param&gt;&lt;/result&gt;]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(5)——拦截器]]></title>
    <url>%2FStruts2-5-%E2%80%94%E2%80%94%E6%8B%A6%E6%88%AA%E5%99%A8.html</url>
    <content type="text"><![CDATA[1、简介struts2中很多的核心功能都是拦截器完成的。比如：params(封装动态参数)、staticParams（静态参数封装）、i18n(国际化)、modelDrivern（模型驱动）、servletConfig（注入servletAPI）等。 作用：在执行动作前或后进行拦截 1&lt;default-interceptor-ref name="defaultStack"/&gt; 1234567891011121314151617181920212223242526&lt;interceptor-stack name="defaultStack"&gt; &lt;interceptor-ref name="exception"/&gt; &lt;interceptor-ref name="alias"/&gt; &lt;interceptor-ref name="servletConfig"/&gt; &lt;interceptor-ref name="i18n"/&gt; &lt;interceptor-ref name="prepare"/&gt; &lt;interceptor-ref name="chain"/&gt; &lt;interceptor-ref name="scopedModelDriven"/&gt; &lt;interceptor-ref name="modelDriven"/&gt; &lt;interceptor-ref name="fileUpload"/&gt; &lt;interceptor-ref name="checkbox"/&gt; &lt;interceptor-ref name="datetime"/&gt; &lt;interceptor-ref name="multiselect"/&gt; &lt;interceptor-ref name="staticParams"/&gt; &lt;interceptor-ref name="actionMappingParams"/&gt; &lt;interceptor-ref name="params"/&gt; &lt;interceptor-ref name="conversionError"/&gt; &lt;interceptor-ref name="validation"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="workflow"&gt; &lt;param name="excludeMethods"&gt;input,back,cancel,browse&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;interceptor-ref name="debugging"/&gt; &lt;interceptor-ref name="deprecation"/&gt;&lt;/interceptor-stack&gt; 2、运作图 结论： 动作方法执行前：拦截器会按照顺序依次进行拦截 执行动作方法 返回结果视图拦截器会按照原来的顺序的相反顺序再次进行拦截 执行过程中：ActionInvocation保存了需要用到的数据 3、自定义拦截器熟悉拦截器的体系：所有的拦截器都直接或间接的实现了Interceptor接口 3.1 创建拦截器类，继承AbstractInterceptor或实现Interceotor123456789101112public class MyInterceptor extends AbstractInterceptor &#123; private static final long serialVersionUID = -828084112876621948L; @Override public String intercept(ActionInvocation invocation) throws Exception &#123; System.out.println("MyInterceptor拦截前"); String invoke = invocation.invoke();//放行 System.out.println("MyInterceptor拦截后"); return invoke; &#125;&#125; 3.2 注册拦截器在struts.xml中注册拦截器，可以针对单个action配置，也可全局配置 针对单个action配置 首先在package中声明拦截器 123&lt;interceptors&gt; &lt;interceptor name="myInterceptor" class="com.topvision.s2sm.plantform.interceptor.MyInterceptor"&gt;&lt;/interceptor&gt;&lt;/interceptors&gt; 然后在action中声明引用该拦截器 123456789 &lt;action name="loginTest" class="com.topvision.s2sm.login.action.LoginAction" method="loginTest"&gt; &lt;!-- 如果没有声明拦截器，默认使用struts-default.xml中的defaultStack 如果声明了，则defaultStack失效 --&gt; &lt;interceptor-ref name="myInterceptor"&gt;&lt;/interceptor-ref&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt;&lt;/action&gt; 但是一般不用这种，因为Struts2有这么一种机制，一旦为Action指定了拦截器，那么就不会再为这个Action执行默认拦截器了，即defaultStack这个拦截器栈中的拦截器都不会执行，也就是说，这个Action没有输入校验、没有参数注入、没有国际化、没有…，这是不行的，所以我们需要在这个元素中再引用defaultStack拦截器栈。 全局配置（常用） 创建一个拦截器栈，包含默认拦截器栈和自定义拦截器。 123456789101112&lt;package name="default" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 自定义拦截器 --&gt; &lt;interceptor name="myInterceptor" class="com.topvision.s2sm.plantform.interceptor.MyInterceptor"&gt;&lt;/interceptor&gt; &lt;!-- 自定义拦截器栈 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;interceptor-ref name="myInterceptor"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 指定默认拦截器 --&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt; 4、MethodFilterInterceptor是AbstractInterceptor的子类：setIncludeMethods(String includeMethods):设置需要拦截的方法，多个方法用逗号分隔setExcludeMethods(String excludeMethods):设置不需要拦截的方法，多个方法用逗号分隔 12345678910111213public class MethodInterDemo extends MethodFilterInterceptor&#123; private static final long serialVersionUID = -9060068603523571867L; @Override protected String doIntercept(ActionInvocation invocation) throws Exception &#123; //拦截前操作 String invoke = invocation.invoke(); //拦截后操作 return invoke; &#125;&#125; 配置xml1234567891011121314151617&lt;package name="default" extends="struts-default"&gt; &lt;interceptors&gt; &lt;!-- 自定义拦截器 --&gt; &lt;interceptor name="myInterceptor" class="com.topvision.s2sm.plantform.interceptor.MyInterceptor"&gt;&lt;/interceptor&gt; &lt;interceptor name="methodInterceptor" class="com.topvision.s2sm.plantform.interceptor.MethodInterDemo"&gt;&lt;/interceptor&gt; &lt;!-- 自定义拦截器栈 --&gt; &lt;interceptor-stack name="myStack"&gt; &lt;interceptor-ref name="defaultStack"/&gt; &lt;interceptor-ref name="myInterceptor"/&gt; &lt;interceptor-ref name="methodInterceptor"/&gt; &lt;/interceptor-stack&gt; &lt;/interceptors&gt; &lt;!-- 指定默认拦截器 --&gt; &lt;default-interceptor-ref name="myStack"&gt;&lt;/default-interceptor-ref&gt;&lt;/package&gt; 设置指定action 12345678910111213&lt;package name="login" namespace="/" extends="default"&gt; &lt;action name="loginTest" class="com.topvision.s2sm.login.action.LoginAction" method="loginTest"&gt; &lt;interceptor-ref name="myStack"&gt; &lt;!-- 设置不需要methodInterDemo拦截的方法 --&gt; &lt;param name="methodInterDemo.excludeMethods"&gt;loginTest&lt;/param&gt; &lt;!-- 设置需要methodInterDemo拦截的方法 --&gt; &lt;param name="methodInterDemo.includeMethods"&gt;aaa&lt;/param&gt; &lt;/interceptor-ref&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt; &lt;result name="input"&gt;/error.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt;]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(4)——数据封装和类型转换]]></title>
    <url>%2FStruts2-4-%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.html</url>
    <content type="text"><![CDATA[数据封装静态参数封装 静态参数即在action中固定不变的参数，在struts.xml中配置action时赋值。 1234567&lt;package name="login" namespace="/" extends="struts-default"&gt; &lt;action name="loginTest" class="com.topvision.s2sm.login.action.LoginAction" method="loginTest"&gt; &lt;param name="username"&gt;xiaoyue&lt;/param&gt; &lt;param name="password"&gt;123456&lt;/param&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; 在action中创建对应属性，提供getter和setter方法。 1234567891011121314151617181920212223242526@Controller@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class LoginAction extends BaseAction&#123; private static final long serialVersionUID = -4442251270114214406L; private String username; private String password; public String loginTest() &#123; System.out.println(username); System.out.println(password); return SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 输出结果 12xiaoyue123456 静态参数封装依赖的是静态参数拦截器staticParams。该拦截器会将静态参数放入值栈中，而action就在值栈中的栈顶，自然就会找到该action中的对应属性，然后进行赋值了。想查看源码，参考该篇博文：struts2 18拦截器详解(十四) — StaticParametersInterceptor 动态参数封装属性驱动和模型驱动都非常重要，都需要掌握，如果还不会ognl表达式，那么可以在学完ognl表达后在回过头来看即可。 属性驱动 基本属性驱动 表单： 1234&lt;form action="aaa/loginTest.tv" method="post"&gt; &lt;input type="text" name="username"&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; action：提供对应属性及getter和setter方法 1234567private String username;public String getUsername() &#123; return username;&#125;public void setUsername(String username) &#123; this.username = username;&#125; 依赖params拦截器注入数据 ![params][4] 该拦截器做的事有两件，一是对提交的参数进行数据校验，判断是否合法，判断是否合法的标准就是拦截器中的excludeParams参数的正则表达式的值。二是将其封装到值栈中的栈顶元素中去，而当前action就在栈顶，所以能够将参数放入action中。通过查看[struts2 18拦截器详解(十五) --- ParametersInterceptor][5]来了解其源码 。 ognl属性驱动 表单，封装对象 12345&lt;form action="aaa/loginTest.tv" method="post"&gt; 姓名：&lt;input type="text" name="user.username"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="user.age"&gt;&lt;br&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; 创建JavaBean对象 1234567891011121314151617public class User implements Serializable &#123; private static final long serialVersionUID = 4340332295972232437L; private String username; private int age; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; Action接收：创建对象，提供getter和setter 123456789private User user = new User();public User getUser() &#123; return user;&#125;public void setUser(User user) &#123; this.user = user;&#125; 在jsp页面中的user.username和user.age其实就是ognl表达式，代表着往根(root，值栈valueStack)中存放值，而值栈中的栈顶元素也就是为当前action，我们在action中设置user的get、set属性，即可以让存进来的值匹配到，进而将对应属性赋值成功。 模型驱动 实现ModelDriven接口，提供一个方法getModel()，编写对象实例。 jsp表单：12345&lt;form action="aaa/loginTest.tv" method="post"&gt; 姓名：&lt;input type="text" name="user.username"&gt;&lt;br&gt; 年龄：&lt;input type="text" name="user.age"&gt;&lt;br&gt; &lt;button type="submit"&gt;提交&lt;/button&gt;&lt;/form&gt; Action类实现ModelDriven接口，提供getModel()方法123456private User user = new User(); @Overridepublic User getModel() &#123; return null;&#125; 分析：这有一个专门的拦截器，叫做modelDriven。源码分析：struts2 18拦截器详解(十) — ModelDrivenInterceptor其实原理就是，该拦截器将getModel方法返回的结果压入值栈，而我们的表单参数会从值栈中从上往下进行查找，自然就直接将参数封装到User对象中了。 类型转换从表单元素提交过来的都是String类型的，而我们在servlet中获取到表单元素后，得到的是Object类型，也就是需要我们自己手动转型，但是在struts2中，我们却不需要，是因为有这么一个机制，参数类型自动转型，获取过来的参数都是String类型的，但是如果我们需要int型，double型等，都会帮我们自己转换。 这里需要注意一点，在使用struts2中的日期自动转型时，表单中的日期字符串的格式是固定的，必须是2014-12-06，也就是yyyy-mm-dd这样的格式，其他格式的话，不能够转型成功，这对有些人来说，就有些不舒服，使用习惯不一样，但是没关系，struts2能够让我们自定义类型转换器，格式让我们自己来决定。 例如：表单输入2013-12-23，接收date为Tue Dec 23 00:00:00 CST 2014 自定义类型转换器 编写转换器类继承StrutsTypeConverter,实现两个抽象方法 1234567891011121314151617181920212223242526272829303132public class DateConverter extends StrutsTypeConverter&#123; SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd"); /* * context:struts2的数据中心 * values:输入的数据 * toClass:要转换成的类型 */ @Override public Object convertFromString(Map context, String[] values, Class toClass) &#123; if (values != null &amp;&amp; values.length &gt; 0) &#123; String value = values[0]; if (toClass == Date.class) &#123; try &#123; return sdf.parse(value); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return null; &#125; @Override public String convertToString(Map context, Object o) &#123; if (o != null &amp;&amp; o.getClass() == Date.class) &#123; return sdf.format(o); &#125; return null; &#125;&#125; 注册类型转换器 2.1 注册局部转换器 在需要转换的Action同级目录，创建一个properties.位置：action类同包名称：actionClass-conversion.propertiesactionClass:action类的类名conversion.properties：固定名 文件内容： 1date = com.topvision.s2sm.plantform.converter.DateConverter 2.2 注册全局转换 在src下创建一个properties。 位置：src 名称：xwork-conversion.properties 固定写法 文件内容： 1java.util.date = com.topvision.s2sm.plantform.converter.DateConverter]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(3)——Action配置及访问方式]]></title>
    <url>%2FStruts2-3-%E2%80%94%E2%80%94Action%E9%85%8D%E7%BD%AE%E5%8F%8A%E8%AE%BF%E9%97%AE%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[Action类构建及访问方式。 1、如何编写动作类 普通POJO类做action(不推荐) 实现Action接口，重写excute方法(不推荐) 继承ActionSupport，写自己需要的方法。 2、如何访问动作类struts.xml中action的配置。12345&lt;package name="login" namespace="/" extends="struts-default"&gt; &lt;action name="loginTest" class="com.topvision.s2sm.login.action.LoginAction" method="loginTest"&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt; &lt;/action&gt;&lt;/package&gt; package.name:包名，不能和其他package重复，唯一标识 package.namespace:命名空间，默认“”，优化访问路径 package.extends：自己写的package要继承struts-default这个包 action.name：动作的名称。让用户访问用的。 action.class：动作类的全名。 有默认值的，这个默认值是：com.opensymphony.xwork2.ActionSupport,在struts-default.xml中有配置： action.method：要执行的动作类中的动作方法。 有默认值的，这个默认值是：public String execute()方法 如上会有一个缺点，就是每个方法都要在xml中配置一个action，较为麻烦。如何优化呢？有两个办法：动态方法调用和通配符。 通配符 通配符使用的比较多，是人为的设置编码规则，体现出约定大于编码的规范。即action.name可以使用通配符星号(*)，在action.class、aciton.method、result.name处可以使用{n}方式匹配星号，举个例子就明白了。 123&lt;action name="*_*" class="&#123;1&#125;" method="&#123;2&#125;"&gt; &lt;result&gt;&lt;/result&gt;&lt;/action&gt; 请求路径：…./userAction_add，{1}匹配第一个,为userAction, {2}匹配第二个，为add。 动态方法调用 在struts.xml中开启动态方法的使用。struts.enable.DynamicMethodInvocation = true。 12&lt;!-- 让struts2支持动态方法调用,可以使用通配符 --&gt;&lt;constant name="struts.enable.DynamicMethodInvocation" value="true" /&gt; 那么就可以直接使用http://localhost:8080/xxx/xxxAction!add,直接调用xxxAction中的add方法了，并且在struts.xml中的action配置中，就不需要配置method属性的值了。这样做就解决了写死method值的问题 3、动作类生命周期诞生：每次用户访问时。活着：动作没有响应结束。死亡：响应结束。 多例的；没有线程安全问题。（与struts1所不同的）。因为动作类是一个非常普通的Java类，创建它需要消耗的资源可以省略不计。 4、动作类访问Servlet的API 实现xxxAware接口 ServletContextAware, ServletRequestAware,ServletResponseAware,SessionAware. struts2提供了这四个Aware接口用于Action类的实现，从而注入对应的application、request、response，session。这和ActionContext一样是解耦的，即没有引入servlet相关的包，是在struts2内部的。 通过XxxAware接口的实现，可以方便的获取web资源。 12345678910111213141516171819202122232425262728public class BaseAction extends ActionSupport implements SessionAware,ServletRequestAware, ServletResponseAware, ServletContextAware &#123; private static final long serialVersionUID = -6318930077865937364L; protected Logger logger = LoggerFactory.getLogger(getClass()); protected Map&lt;String, Object&gt; session; protected HttpServletRequest request; protected HttpServletResponse response; protected ServletContext context; @Override public void setSession(Map&lt;String, Object&gt; session) &#123; this.session = session; &#125; @Override public void setServletRequest(HttpServletRequest request) &#123; this.request = request; &#125; @Override public void setServletResponse(HttpServletResponse response) &#123; this.response = response; &#125; @Override public void setServletContext(ServletContext context) &#123; this.context = context; &#125;&#125; 直接耦合构造 123ServletContext servletContext = ServletActionContext.getServletContext();HttpServletRequest request = ServletActionContext.getRequest();HttpSession session = request.getSession();]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(2)——搭建struts及spring整合Demo]]></title>
    <url>%2FStruts2-2-%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BAstruts%E5%8F%8Aspring%E6%95%B4%E5%90%88Demo.html</url>
    <content type="text"><![CDATA[简单介绍struts2整合spring项目的搭建。 1、创建maven工程，引入jar依赖pom.xml文件如下，maven相关知识请参看maven学习。属性：设置版本等信息依赖管理：锁定依赖jar包的具体版本依赖： spring: struts2 mybatis mysql驱动 c3p0 slf4j junit、jstl servlet jsp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.topvision&lt;/groupId&gt; &lt;artifactId&gt;s2sm&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;s2sm Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 属性 --&gt; &lt;properties&gt; &lt;spring.version&gt;4.3.12.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;struts.version&gt;2.3.24.1&lt;/struts.version&gt; &lt;/properties&gt; &lt;!-- 锁定版本 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt; &lt;version&gt;$&#123;struts.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- Struts --&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-spring-plugin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-json-plugin&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- mybatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.6&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- c3p0 --&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j --&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- junit --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.9&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- jstl --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- servlet jsp --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;finalName&gt;s2sm&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 2、配置web.xml 配置spring监听器 12345678&lt;!-- applicationContext对象仅加载一次，在服务器器启动时加载 --&gt;&lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;&lt;/listener&gt;&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/config/applicationContext*.xml&lt;/param-value&gt;&lt;/context-param&gt; 配置struts2核心过滤器 1234567891011121314151617181920 &lt;!-- Struts2核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 指定action所在包路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;actionPackages&lt;/param-name&gt; &lt;param-value&gt;com.topvision&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 指定struts.xml文件路径，默认classpath下 --&gt; &lt;init-param&gt; &lt;param-name&gt;filterConfig&lt;/param-name&gt; &lt;param-value&gt;classpath:struts.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 设置url过滤 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 设置编码，防止乱码 12345678910111213 &lt;!-- 编码 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 设置首页 123456789&lt;!-- 首页设置 --&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt; 3、applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tool="http://www.springframework.org/schema/tool" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.2.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tool http://www.springframework.org/schema/tool/spring-tool-3.2.xsd "&gt; &lt;!-- 开启注解配置Bean --&gt; &lt;!-- 设置扫描包路径 --&gt; &lt;context:annotation-config/&gt; &lt;context:component-scan base-package="com.topvision"/&gt; &lt;!-- 开启注解事务 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt; &lt;!-- 事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 数据库C3P0 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;s2sm.jdbc.driverClass&#125;"/&gt; &lt;property name="jdbcUrl" value="$&#123;s2sm.jdbc.url&#125;"/&gt; &lt;property name="user" value="$&#123;s2sm.jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;s2sm.jdbc.password&#125;"/&gt; &lt;property name="initialPoolSize" value="$&#123;s2sm.cpool.initialPoolSize&#125;" /&gt; &lt;property name="minPoolSize" value="$&#123;s2sm.cpool.minPoolSize&#125;" /&gt; &lt;property name="maxPoolSize" value="$&#123;s2sm.cpool.maxPoolSize&#125;" /&gt; &lt;property name="acquireIncrement" value="$&#123;s2sm.cpool.acquireIncrement&#125;" /&gt; &lt;property name="maxIdleTime" value="$&#123;s2sm.cpool.maxIdleTime&#125;"/&gt; &lt;property name="acquireRetryAttempts" value="$&#123;s2sm.cpool.acquireRetryAttempts&#125;"/&gt; &lt;property name="acquireRetryDelay" value="$&#123;s2sm.cpool.acquireRetryDelay&#125;"/&gt; &lt;/bean&gt; &lt;!-- 加载properties --&gt; &lt;!-- &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; --&gt; &lt;bean id="propertyConfigurer" class="org.springframework.beans.factory.config.PropertyPlaceholderConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath:/config/*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt; 4、Action编写12345678910111213141516171819202122232425262728293031@Controller@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class LoginAction extends BaseAction&#123; private static final long serialVersionUID = -4442251270114214406L; private String username; private String password; public String loginTest() &#123; String key = username + ":" + password; ActionContext context2 = ActionContext.getContext(); context2.put("key", key); return SUCCESS; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125;&#125; 5、配置struts.xmlstruts.xml文件路径要与struts2核心过滤器中配置的路径一致，默认在classpath下即可。 1234567891011121314151617181920212223242526272829&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE struts PUBLIC "-//Apache Software Foundation//DTD Struts Configuration 2.3//EN" "http://struts.apache.org/dtds/struts-2.3.dtd"&gt;&lt;struts&gt; &lt;!-- 所有匹配*.action的请求都由struts2处理 --&gt; &lt;constant name="struts.action.extension" value="tv,mb" /&gt; &lt;!-- 主题 simple,xhtml,css_xhtml和ajax--&gt; &lt;constant name="struts.ui.theme" value="simple"/&gt; &lt;!-- 是否启用开发模式 --&gt; &lt;constant name="struts.devMode" value="true" /&gt; &lt;!-- struts配置文件改动后，是否重新加载，有助于开发 --&gt; &lt;constant name="struts.configuration.xml.reload" value="true" /&gt; &lt;!-- 每次HTTP请求系统都重新加载资源文件，有助于开发 --&gt; &lt;constant name="struts.i18n.reload" value="true" /&gt; &lt;!-- 设置浏览器是否缓存静态内容,开发是设为false,部署后true --&gt; &lt;constant name="struts.serve.static.browserCache" value="false" /&gt; &lt;!-- Content Model : ((package | include | bean | constant)*, unknown-handler-stack?) --&gt; &lt;package name="login" namespace="/aaa" extends="struts-default"&gt; &lt;action name="loginTest" class="com.topvision.s2sm.login.action.LoginAction" method="loginTest"&gt; &lt;result&gt;/WEB-INF/jsp/login/login.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 6、测试 首页设置 1234567891011&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="aaa/loginTest.tv?username=中文&amp;password=123"&gt;请点击这个链接&lt;/a&gt;&lt;br&gt; &lt;/body&gt;&lt;/html&gt; login.jsp 12345678910111213141516&lt;%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%&gt;&lt;%@ taglib prefix="s" uri="/struts-tags" %&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;成功&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;跳转成功&lt;/h2&gt;&lt;s:property value="@java.lang.Integer@MAX_VALUE"/&gt;&lt;s:property value="username"/&gt;&lt;s:property value="password"/&gt;&lt;s:debug&gt;&lt;/s:debug&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2(1)——基本认识]]></title>
    <url>%2FStruts2-1-%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%86.html</url>
    <content type="text"><![CDATA[Struts2就是一个web层框架，并且是使用MVC设计模式实现的的一个框架，之前使用的是Serlvet+JSP来开发web项目，现在用Struts2框架来替代他，那Struts2到底有哪些优点呢？那就需要我们自己来研究它了.请求 ———– Servlet ————– JSP serlvet+JSP 请求 ———– Action ————– JSP Struts 1.工作原理 请求在struts2框架中的处理流程大概可以分为以下几步： 客户端初始化一个指向servlet容器(例如Tomcat)的请求 该请求经过一系列的过滤器（Filter）（这些过滤器中有一个叫做ActionContextCleanUp的可选过滤器，这个过滤器对于Struts2和其他框架的集成很有帮助，例如：SiteMesh Plugin） 然后FilterDispather(StrutsPrepareAndExecuteFilter)被调用，询问ActionMapper来决定这个请是否需要调用某个Action。 如果ActionMapper决定需要调用某个Action，FilterDispatcher把请求的处理交给ActionProxy. ActionProxy通过ConfigurationManager询问框架的配置文件，找到需要调用的Action类 ,这里，我们一般是从struts.xml配置中读取。 ActionProxy创建一个ActionInvocation的实例 ActionInvocation实例使用命名模式来调用，在调用Action的过程前后，涉及到相关拦截器（Intercepter）的调用。 一旦Action执行完毕，ActionInvocation负责根据struts.xml中的配置找到对应的返回结果。返回结果通常是（但不总是，也可能是另外的一个Action链）一个需要被表示的JSP或者FreeMarker的模版。在表示的过程中可以使用Struts2 框架中继承的标签。在这个过程中需要涉及到ActionMapper 在上述过程中所有的对象（Action，Results，Interceptors等）都是通过ObjectFactory来创建的。 2.配置文件 配置文件的名称 位置 主要内容 说明 default.properties struts2-core-2.3.15.3.jar/org/apache/struts2/default.properties 一些参数配置 程序员不能直接修改的 struts-default.xml struts2-core-2.3.15.3.jar/struts-default.xml 一些参数配置 程序员不能直接修改的 struts.xml 应用的classpath中 struts的配置文件 程序员使用的 struts.properties 应用的classpath中 struts的参数配置文件 程序员使用的 web.xml WEB-INF/web.xml 应用的配置文件 给过滤器配置参数 以上配置文件在应用被启动的时候就完成了加载；而且有加载的顺序要求。后面的配置会覆盖掉前面配置文件中相同的信息。 2.1 default.properties 参数名称 参数的默认值 说明 struts.i18n.encoding UTF-8 框架使用的默认编码 struts.action.extension action 进入框架核心的uri的后缀。多个值用逗号分隔 struts.serve.static.browserCache true 告诉客户端要不要缓存静态的资源 struts.configuration.xml.reload 被注释掉了：建议true 每当xml配置文件被修改后，不需要重新加载应用就能够使配置生效。适合开发阶段 struts.devMode false 是否是开发模式。开发阶段应该设置为true 如何修改他们的默认值呢？struts.xml:通过该文件来进行修改12&lt;!--通过constant元素覆盖掉之前配置文件参数的默认值--&gt;&lt;constant name="struts.devMode" value="true" /&gt; 2.2 struts-default.xml 这个文件定义了action返回结果类型，struts的拦截器，以及一些其他默认配置。 2.3 struts.xml 作用：希望程序员能够按照分包的思想管理你的动作配置 属性： name:必须要的，给包取一个名字。唯一。 extends：当前包需要继承的父包的名称。框架希望程序员能够用面向对象的方式管理你的包。子包能够继承父包中的所有配置。自己写的包一般情况下要继承一个name=struts-default的包（它在struts-default.xml中） abstract：把包声明成抽象包。没有任何子元素的package就可以声明为抽象的包。 namespace：名称空间。默认值是””（空字符串）。名称空间+动作名称：构成了动作的访问路径。 2.4 struts.properties这个文件是struts2框架的全局属性文件，也是自动加载的文件。该文件包含了系列的key-value对。该文件完全可以配置在struts.xml文件中，使用constant元素。下面是这个文件中一些常见的配置项及说明。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116### 指定加载struts2配置文件管理器，默认为org.apache.struts2.config.DefaultConfiguration### 开发者可以自定义配置文件管理器，该类要实现Configuration接口，可以自动加载struts2配置文件。# struts.configuration=org.apache.struts2.config.DefaultConfiguration### 设置默认的locale和字符编码# struts.locale=en_USstruts.i18n.encoding=UTF-8### 指定struts的工厂类# struts.objectFactory = spring### 指定spring框架的装配模式### 装配方式有: name, type, auto, and constructor (name 是默认装配模式)struts.objectFactory.spring.autoWire = name### 该属性指定整合spring时，是否对bean进行缓存，值为true or false,默认为true.struts.objectFactory.spring.useClassCache = true### 指定类型检查#struts.objectTypeDeterminer = tiger#struts.objectTypeDeterminer = notiger### 该属性指定处理 MIME-type multipart/form-data，文件上传# struts.multipart.parser=cos# struts.multipart.parser=pellstruts.multipart.parser=jakarta# 指定上传文件时的临时目录，默认使用 javax.servlet.context.tempdir struts.multipart.saveDir=struts.multipart.maxSize=2097152### 加载自定义属性文件 (不要改写struts.properties!)# struts.custom.properties=application,org/apache/struts2/extension/custom### 指定请求url与action映射器，默认为org.apache.struts2.dispatcher.mapper.DefaultActionMapper#struts.mapper.class=org.apache.struts2.dispatcher.mapper.DefaultActionMapper### 指定action的后缀，默认为actionstruts.action.extension=action### 被 FilterDispatcher使用### 如果为 true 则通过jar文件提供静态内容服务. ### 如果为 false 则静态内容必须位于 &lt;context_path&gt;/strutsstruts.serve.static=true### 被 FilterDispatcher使用### 指定浏览器是否缓存静态内容，测试阶段设置为false，发布阶段设置为true.struts.serve.static.browserCache=true### 设置是否支持动态方法调用，true为支持，false不支持.struts.enable.DynamicMethodInvocation = true### 设置是否可以在action中使用斜线，默认为false不可以，想使用需设置为true.struts.enable.SlashesInActionNames = false### 是否允许使用表达式语法，默认为true.struts.tag.altSyntax=true### 设置当struts.xml文件改动时，是否重新加载.### - struts.configuration.xml.reload = true### 设置struts是否为开发模式，默认为false,测试阶段一般设为true.struts.devMode = false### 设置是否每次请求，都重新加载资源文件，默认值为false.struts.i18n.reload=false###标准的UI主题### 默认的UI主题为xhtml,可以为simple,xhtml或ajaxstruts.ui.theme=xhtml###模板目录struts.ui.templateDir=template#设置模板类型. 可以为 ftl, vm, or jspstruts.ui.templateSuffix=ftl###定位velocity.properties 文件. 默认 velocity.propertiesstruts.velocity.configfile = velocity.properties### 设置velocity的context.struts.velocity.contexts =### 定位toolbox.struts.velocity.toolboxlocation=### 指定web应用的端口.struts.url.http.port = 80### 指定加密端口struts.url.https.port = 443### 设置生成url时，是否包含参数.值可以为: none, get or allstruts.url.includeParams = get### 设置要加载的国际化资源文件，以逗号分隔.# struts.custom.i18n.resources=testmessages,testmessages2### 对于一些web应用服务器不能处理HttpServletRequest.getParameterMap()### 像 WebLogic, Orion, and OC4J等，须设置成true,默认为false.struts.dispatcher.parametersWorkaround = false### 指定freemarker管理器#struts.freemarker.manager.classname=org.apache.struts2.views.freemarker.FreemarkerManager### 设置是否对freemarker的模板设置缓存### 效果相当于把template拷贝到 WEB_APP/templates.struts.freemarker.templatesCache=false### 通常不需要修改此属性.struts.freemarker.wrapper.altMap=true### 指定xslt result是否使用样式表缓存.开发阶段设为true,发布阶段设为false.struts.xslt.nocache=false### 设置struts自动加载的文件列表.struts.configuration.files=struts-default.xml,struts-plugin.xml,struts.xml### 设定是否一直在最后一个slash之前的任何位置选定namespace.struts.mapper.alwaysSelectFullNamespace=false 2.5 web.xml配置struts2的核心过滤器和spring的加载器。这里针对struts2相关配置作介绍。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;!-- Struts2核心过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;!-- 指定action所在包路径 --&gt; &lt;init-param&gt; &lt;param-name&gt;actionPackages&lt;/param-name&gt; &lt;param-value&gt;com.topvision&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 指定struts.xml文件路径，默认classpath下 --&gt; &lt;init-param&gt; &lt;param-name&gt;filterConfig&lt;/param-name&gt; &lt;param-value&gt;classpath:struts.xml&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;!-- 设置url过滤 --&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 编码 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 404错误跳转 --&gt;&lt;error-page&gt; &lt;error-code&gt;404&lt;/error-code&gt; &lt;location&gt;/error.jsp?code=404&lt;/location&gt;&lt;/error-page&gt;&lt;!-- 首页设置 --&gt;&lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt;&lt;/welcome-file-list&gt;]]></content>
      <categories>
        <category>Struts2</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java中读取properties]]></title>
    <url>%2FJava%E4%B8%AD%E8%AF%BB%E5%8F%96properties.html</url>
    <content type="text"><![CDATA[将一些业务常量配置成properties文件，是扩展程序兼容性的常用做法。在业务变更导致数据需要改变时，不需要修改代码，只用更改配置文件并重启即可生效。 方法一：IO实现123456789101112131415161718192021public static String getValue(String fileNamePath, String key) throws IOException &#123; Properties props = new Properties(); InputStream in = null; try &#123; in = new FileInputStream(fileNamePath); //如果将in改为下面的方法，必须要将.Properties文件和此class类文件放在同一个包中 //in = propertiesTools.class.getResourceAsStream(fileNamePath); props.load(in); String value = props.getProperty(key); // 有乱码时要进行重新编码 // new String(props.getProperty("name").getBytes("ISO-8859-1"), "GBK"); return value; &#125; catch (FileNotFoundException e) &#123; return null; &#125; finally &#123; if (null != in) &#123; in.close(); &#125; &#125;&#125; 方法二：spring实现在spring扫描配置文件时，将properties中的key和value放入一个map中。 Spring配置 12345678&lt;bean id="propertyConfigurer" class="com.hapishop.util.ProjectDBinfoConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath*:/META-INF/*.properties&lt;/value&gt; &lt;value&gt;file:conf/*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 自定义CustomizedPropertyConfigurer,继承PropertyPlaceholderConfigurer 1234567891011121314151617181920212223 public class CustomizedPropertyConfigurer extends PropertyPlaceholderConfigurer &#123; private static Map&lt;String, String&gt; properties = new HashMap&lt;String, String&gt;(); protected void processProperties(ConfigurableListableBeanFactory beanFactoryToProcess, Properties props) throws BeansException &#123; // cache the properties PropertyPlaceholderHelper helper = new PropertyPlaceholderHelper(DEFAULT_PLACEHOLDER_PREFIX,DEFAULT_PLACEHOLDER_SUFFIX, DEFAULT_VALUE_SEPARATOR, false); for (Entry&lt;Object, Object&gt; entry : props.entrySet()) &#123; String stringKey = String.valueOf(entry.getKey()); String stringValue = String.valueOf(entry.getValue()); stringValue = helper.replacePlaceholders(stringValue, props); properties.put(stringKey, stringValue); &#125; super.processProperties(beanFactoryToProcess, props); &#125; public static Map&lt;String, String&gt; getProperties() &#123; return properties; &#125; public static String getProperty(String key) &#123; return properties.get(key); &#125;&#125; 配置properties 123site=iteye blog=antlove url=$&#123;site&#125;/$&#123;blog&#125; Java获取 12//调用此方法获取valueCustomizedPropertyConfigurer.getContextProperty() 方法三：注解实现 Spring配置 12345678&lt;bean id="propertyConfigurer" class="com.hapishop.util.ProjectDBinfoConfigurer"&gt; &lt;property name="locations"&gt; &lt;list&gt; &lt;value&gt;classpath*:/META-INF/*.properties&lt;/value&gt; &lt;value&gt;file:conf/*.properties&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; 注解获取 123456@Value("$&#123;socket.time.out&#125;")int socketTimeout;public void setSocketTimeout(int socketTimeout) &#123; this.socketTimeout = socketTimeout; &#125; @Value写在要注入的属性上，要提供setter方法。 spring加载properties的两个类的区别 PropertiesFactoryBean是PropertiesLoaderSupport直接的实现类，专门用来管理properties文件的工厂bean，默认是单例的。 PropertyPlaceholderConfigurer是解决properties文件占位符问题的，也实现了PropertiesLoaderSupport类。 在java 代码里，一般是使用@Value注解来引用 properties 文件的属性。 使用 PropertyPlaceholderConfigurer 时， @Value表达式的用法是 @Value(value=”${properties key}”) ， 使用 PropertiesFactoryBean 时，我们还可以用@Value 读取 properties对象的值， @Value 用法 是 @Value(value=”#{configProperties[‘properties key’]}”)]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>properties</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activiti5 流程框架]]></title>
    <url>%2FActiviti5-%E6%B5%81%E7%A8%8B%E6%A1%86%E6%9E%B6.html</url>
    <content type="text"><![CDATA[工作流(Workflow)，就是“业务过程的部分或整体在计算机应用环境下的自动化”，它主要解决的是“使在多个参与者之间按照某种预定义的规则传递文档、信息或任务的过程自动进行，从而实现某个预期的业务目标，或者促使此目标的实现”。 1 Activiti简介Activiti5是由Alfresco软件在2010年5月17日发布的业务流程管理（BPM）框架，它是覆盖了业务流程管理、工作流、服务协作等领域的一个开源的、灵活的、易扩展的可执行流程语言框架。Activiti基于Apache许可的开源BPM平台，创始人Tom Baeyens是JBoss jBPM的项目架构师，它特色是提供了eclipse插件，开发人员可以通过插件直接绘画出业务流程图。 1.1 工作流引擎这是Activiti的核心，负责生成流程运行时的各种实例及数据、监控和管理流程的运行。 1.2 BPMN2.0业务流程建模与标注（Business Process Model and Notation，BPMN) ，描述流程的基本符号，包括这些图元如何组合成一个业务流程图（Business Process Diagram） 1.3 数据库Activiti的后台是有数据库的支持，所有的表都以ACT_开头。第二部分是表示表的用途的两个字母标识。 用途也和服务的API对应。 ACTRE*: ‘RE’表示repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。 ACTRU*: ‘RU’表示runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。 ACTID*: ‘ID’表示identity。 这些表包含身份信息，比如用户，组等等。 ACTHI*: ‘HI’表示history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。 ACTGE*: 通用数据， 用于不同场景下。 1.3.1 资源库流程规则表 act_re_deployment 部署信息表 act_re_mode 流程设计模型部署表 act_re_procdef 流程定义表 1.3.2 运行时数据库 act_ru_execution 运行时流程执行实例表 act_ru_identitylink 运行时流程人员表，主要存储任务节点与参与者的相关信息 act_ru_task 运行时任务节点表 act_ru_variable 运行时流程变量数据表 1.3.3 历史数据库表 act_hi_actinst 历史节点表 act_hi_attachment 历史附件表 act_hi_comment 历史意见表 act_hi_identitylink 历史流程人员表 act_hi_detail 历史详情表，提供历史变量的查询 act_hi_procinst 历史流程实例表 act_hi_taskinst 历史任务实例表 act_hi_varinst 历史变量表 1.3.4 组织机构表 act_id_group 用户组信息表 act_id_info 用户扩展信息表 act_id_membership 用户与用户组对应信息表 act_id_user 用户信息表 这四张表很常见，基本的组织机构管理，关于用户认证方面建议还是自己开发一套，组件自带的功能太简单，使用中有很多需求难以满足 。可以使shiro完成用户认证。 1.3.5 统用数据表 act_ge_bytearray 二进制数据表 act_ge_property 属性数据表存储整个流程引擎级别的数据,初始化表结构时，会默认插入三条记录 1.4 activiti.cfg.xmlActiviti核心配置文件，配置流程引擎创建工具的基本参数和数据库连接池参数。 定义数据库配置参数： jdbcUrl: 数据库的JDBC URL。 jdbcDriver: 对应不同数据库类型的驱动。 jdbcUsername: 连接数据库的用户名。 jdbcPassword: 连接数据库的密码。 基于JDBC参数配置的数据库连接 会使用默认的MyBatis连接池。 下面的参数可以用来配置连接池（来自MyBatis参数）： jdbcMaxActiveConnections: 连接池中处于被使用状态的连接的最大值。默认为10。 jdbcMaxIdleConnections: 连接池中处于空闲状态的连接的最大值。 jdbcMaxCheckoutTime: 连接被取出使用的最长时间，超过时间会被强制回收。 默认为20000（20秒）。 jdbcMaxWaitTime: 这是一个底层配置，让连接池可以在长时间无法获得连接时， 打印一条日志，并重新尝试获取一个连接。（避免因为错误配置导致沉默的操作失败）。 默认为20000（20秒）。 示例如下： 12345678910111213 &lt;bean name="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="JdbcDriver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="JdbcUrl" value="jdbc:mysql://localhost:3306/activititest"/&gt;&lt;property name="JdbcUsername" value="root" /&gt;&lt;property name="JdbcPassword" value="123" /&gt;&lt;!-- databaseSchemaUpdate：设置流程引擎启动和关闭时如何处理数据库表 false（默认）:检查数据库表的版本和依赖库的版本，如果不一致就抛出异常 true:构建流程引擎是执行检查，如果需要就更新，如果表不存在就创建 create-drop：构建流程引擎是创建表，关闭时删除表 --&gt;&lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;/bean&gt; 关于c3p0、dbcp等数据库连接池配置请参看spring(4)——持久层封装 1.5 logging.properties1234log4j.rootLogger=WARN, stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d %p [%c] - %m%n 更详细log4j说明请参看log4j.properties配置详解与实例 2 环境搭建2.1 需求java环境 JDK1.6或更高 支持的数据库有：h2, mysql, oracle, postgres, mssql, db2等。 支持activiti5运行的jar包 开发环境为Eclipse3.7或者以上版本,myeclipse为8.6版本 2.2 资源下载activiti可以到Activiti官方网站下载得到。 百度网盘下载地址，5.22.0和6.0.0两个版本，还有eclipse插件。百度网盘下载 注意：安装插件后，在Windows-&gt;Preferences-&gt;Activiti-&gt;Save菜单下勾选保存时自动生成图片。 2.3 配置开发环境2.3.1 添加jar包在activiti-5.22.0→wars目录下是一些示例项目，解压activiti-rest项目，导入activiti-rest目录中WEB-INF\lib下所有jar包到classpath中。注意还需要数据库连接驱动包，如Mysql还需要添加mysql-connector-java.jar。 2.3.2 初始化数据库123456789101112131415@Testpublic void createTable() &#123; //1、创建流程引擎配置对象 ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration(); //2、配置数据库 processEngineConfiguration.setJdbcDriver("com.mysql.jdbc.Driver"); processEngineConfiguration.setJdbcUrl("jdbc:mysql://localhost:3306/activititest"); processEngineConfiguration.setJdbcUsername("root"); processEngineConfiguration.setJdbcPassword("123"); //3、设置建表策略 processEngineConfiguration.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE); //4、创建流程引擎对象 ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine(); System.out.println("processEngine"+processEngine);&#125; 在Activiti中，在创建核心的流程引擎对象时会自动建表。如果程序正常执行，mysql会自动建库，然后创建23张表。 2.3.3 配置文件在Actiiti5中定制流程必定会操作到数据库，如果都像上面那样写一大段代码会非常麻烦，所以我们可以把数据库连接配置写入配置文件。 在Activiti5的官方示例中并没有现成的配置文件，所以先得找到activiti-rest\WEB-INF\classes下有：activiti-context.xml：一个类似spring结构的配置文件，清空内容后改名为activiti.cfg.xml，用来做流程引擎的相关配置。 12345678910111213 &lt;bean name="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="JdbcDriver" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="JdbcUrl" value="jdbc:mysql://localhost:3306/activititest"/&gt;&lt;property name="JdbcUsername" value="root" /&gt;&lt;property name="JdbcPassword" value="123" /&gt;&lt;!-- databaseSchemaUpdate：设置流程引擎启动和关闭时如何处理数据库表 false（默认）:检查数据库表的版本和依赖库的版本，如果不一致就抛出异常 true:构建流程引擎是执行检查，如果需要就更新，如果表不存在就创建 create-drop：构建流程引擎是创建表，关闭时删除表 --&gt;&lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;/bean&gt; Java代码如下： 12345@Testpublic void createTable2() &#123; ProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml"); ProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();&#125; 3 核心API3.1 ProcessEngine 在Activiti中最核心的类，其他的类都是由它而来。 产生方式2.1 方式一：最基础版本，见2.3.2小节2.2 方式二：配置文件+java代码，见2.3.3小节 1234@Testpublic void createTable3() &#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();&#125; 这种方式更加简单，会自动加载classpath下名为activiti.cfg.xml的文件。 产生各种service 12345678910//流程仓库业务类，管理流程定义、部署RepositoryService repositoryService = processEngine.getRepositoryService();//流程运行业务类，管理流程启动、推进、删除等操作RuntimeService runtimeService = processEngine.getRuntimeService();//流程任务类，管理具体的任务TaskService taskService = processEngine.getTaskService();//流程历史数据类HistoryService historyService = processEngine.getHistoryService();//流程用户业务类IdentityService identityService = processEngine.getIdentityService(); 3.2 ReposityService流程仓库业务类，仓库简单理解即流程定义文档的两个文件：bpmn文件和流程图片 产生流程部署配置对象，用来定义流程部署的相关参数 123456789@Testpublic void Demo1() &#123; DeploymentBuilder deploymentBuilder = processEngine.getRepositoryService().createDeployment().name(&quot;test&quot;); deploymentBuilder.addClasspathResource(&quot;diagrams/HelloWord.bpmn&quot;); deploymentBuilder.addClasspathResource(&quot;diagrams/HelloWord.png&quot;); Deployment deployment = deploymentBuilder.deploy(); System.out.println(deployment.getId() + &quot;。。。。&quot;+ deployment.getName());&#125; 删除流程定义 1repositoryService.deleteDeployment(deploymentId); 3.3 RuntimeService流程执行服务类。可以从这个类中获取很多关于流程执行相关的信息。 启动流程 123//常用的启动流程实例的两种方法ProcessInstance processInstance = runtimeService.startProcessInstanceById(processInstanceId);ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processInstanceKey); 3.4 TaskServiceactiviti的任务服务类。可以从这个类中获取任务的信息。 3.5 ProcessDefinition流程定义类。可以从这里获得资源文件等。每个流程文件唯一对应一个相同key的流程定义，只是流程定义的version不同 3.6 ProcessInstance流程实例。根据流程定义实例化的具体流程，我们可以利用这个对象来了解当前流程实例的进度等信息。如： 公司有一个所有人通用的请假流程，这个叫做流程定义。 小明今天请假，填写请假单，就是创建了一个流程实例。 12345678/** Represents one execution of a &#123;@link ProcessDefinition&#125;. 1. 2. @author Tom Baeyens 3. @author Joram Barrez 4. @author Daniel Meyer 5. @author Tijs Rademakers */public interface ProcessInstance extends Execution &#123; 从上面可以看出ProcessInstance就是Execution，但实际有点区别 单线流程中，ProcessInstance与Execution是一致的，ID都一样 多线 流程中，总线路代表ProcessInstance，而分线路中每个活动代表Execution。 3.7 ExecutionActiviti用这个对象去描述流程执行的每一个节点。在没有并发的情况下，同ProcessInstance。 4 流程定义4.1 创建流程文件在classpath下创建流程文件编辑流程文件 4.2 部署流程定义部署流程定义可以看成是添加流程定义1234567891011121314@Testpublic void deploy() &#123; //创建流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); //创建流程部署对象 DeploymentBuilder deploymentBuilder = processEngine.getRepositoryService().createDeployment(); //读取文件部署流程 Deployment deploy = deploymentBuilder.name("测试") .addClasspathResource("diagrams/HelloWord.bpmn") .addClasspathResource("diagrams/HelloWord.png") .deploy(); System.out.println(deploy.getId() + "。。。" + deploy.getName());&#125; 部署流程会改变3张表 act_re_deployment 存放流程定义的显示名和部署时间，每部署一次增加一条记录 act_re_procdef 存放流程定义的属性信息，部署每个新的流程定义都会在这张表中增加一条记录。 act_ge_bytearray 存储流程定义相关的部署信息。即流程定义文档的存放地。每部署一次就会增加两条记录，一条是关于bpmn规则文件的，一条是图片的（如果部署时只指定了bpmn一个文件，activiti会在部署时解析bpmn文件内容自动生成流程图）。两个文件不是很大，都是以二进制形式存储在数据库中。 4.3 查看流程定义123456789101112131415161718192021@Testpublic void view() &#123; RepositoryService repositoryService = ProcessEngines.getDefaultProcessEngine().getRepositoryService(); List&lt;ProcessDefinition&gt; list = repositoryService.createProcessDefinitionQuery() //过滤条件 .processDefinitionKey("HelloWorld") //.processDefinitionId(processDefinitionId) //分页 //.listPage(firstResult, maxResults) //排序 //.orderByProcessDefinitionVersion() //执行查询 .list(); for (ProcessDefinition processDefinition : list) &#123; System.out.print("id:" + processDefinition.getId() + ",");//流程Id System.out.print("key:" + processDefinition.getKey() + ",");//流程Key System.out.print("name:" + processDefinition.getName() + ",");//流程名字 System.out.print("version:" + processDefinition.getVersion() + ",");//流程版本 System.out.println("deploymentId():" + processDefinition.getDeploymentId());//流程部署对象Id &#125;&#125; 查询结果 id:HelloWorld:1:35004,key:HelloWorld,name:请假审批流程,version:1,deploymentId():35001 再部署一次，再查询 id:HelloWorld:1:35004,key:HelloWorld,name:请假审批流程,version:1,deploymentId():35001 id:HelloWorld:2:37504,key:HelloWorld,name:请假审批流程,version:2,deploymentId():37501 说明： 因为流程定义的信息在仓库中，实际在actre*表中，所以创建RepositoryService 创建查询对象ProcessDefinitionQuery，设置查询参数，调用list()执行查询 由查询结果可知：3.1 流程定义的key和name与流程文件的id和name一致 1&lt;process id="HelloWorld" name="请假审批流程" isExecutable="true"&gt; 3.2 key属性被用来区别不同的流程定义。3.3 带有特定key的流程定义第一次部署时，version为1。之后每次部署都会在当前最高版本号上加13.4 Id的生成规则为：{processDefinitionKey}:{processDefinitionVersion}:{generated-id}，这里的generated-id是一个自动生成的唯一的数字3.5 重复部署一次，deploymentId的值以一定的形式变化 4.4 删除流程定义删除部署到activiti中的流程定义。如:删除请假流程定义，则大家再也不能请假了。 123456789@Testpublic void delete() &#123; RepositoryService repositoryService = ProcessEngines.getDefaultProcessEngine().getRepositoryService(); String deploymentId = "7501"; //如果有关联信息，会报错 //repositoryService.deleteDeployment(deploymentId); //如果有关联信息，会级联删除 repositoryService.deleteDeployment(deploymentId, true);&#125; 4.5 获取流程定义文档资源12345678910111213141516171819202122@Testpublic void getResource() throws IOException &#123; RepositoryService repositoryService = ProcessEngines.getDefaultProcessEngine().getRepositoryService(); String deploymentId = "35001"; String resourceName = null; //资源文件名,即act_re_bytearray表中的name List&lt;String&gt; names = repositoryService.getDeploymentResourceNames(deploymentId); for (String str : names) &#123; //过滤出特定的图片文件 if (str.indexOf("HelloWorld.png") != -1) &#123; resourceName = str; &#125; &#125; System.out.println(resourceName); if (resourceName != null) &#123; //通过部署ID和文件名获得输入流 InputStream inputStream = repositoryService.getResourceAsStream(deploymentId, resourceName); File file = new File("D:/"+ resourceName); FileUtils.copyInputStreamToFile(inputStream, file); &#125;&#125; 5 流程实例5.1 启动流程实例12345678910@Testpublic void startProcess() &#123; RuntimeService runtimeService = ProcessEngines.getDefaultProcessEngine().getRuntimeService(); //根据流程Id启动流程 //ProcessInstance processInstance = runtimeService.startProcessInstanceById(processDefinitionId); //根据流程key启动流程，会自动找到版本最高的流程定义来创建 ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("HelloWorld"); System.out.println(processInstance.getId());//流程实例Id System.out.println(processInstance.getActivityId());//流程当前节点Id&#125; 启动流程实例有很多重载方法，根据实际需要选用。 5.2 查询任务在Activiti中，任务主要分为两类： 确切指定了办理者的任务，之歌任务称为制定者的私人任务 2.无法指定具体的某一个人来办理的任务，可以把任务分配给几个人或者一到 多个小组，让这个范围内的用户可以选择性（如有空余时间时）来办理这类任务。 123456789101112131415161718192021@Testpublic void taskQuery() &#123; TaskService taskService = ProcessEngines.getDefaultProcessEngine().getTaskService(); List&lt;Task&gt; list = taskService.createTaskQuery() //查询指定用户的私人任务 //.taskAssignee("指定用户") //查询某人可接的共有任务 //.taskCandidateUser("候选用户") //排序 .orderByTaskCreateTime().desc() //执行查询 .list(); for (Task task : list) &#123; System.out.println("id:" + task.getId()); System.out.println("name:" + task.getName()); System.out.println("assignee:" + task.getAssignee()); System.out.println("createTime:" + task.getCreateTime()); System.out.println("ProcessInstanceId:" + task.getProcessInstanceId()); System.out.println("ProcessDefinitionId:" + task.getProcessDefinitionId()); &#125;&#125; 5.3 认领任务1taskService.claim(taskId, userId); 将任务变为用户的私人任务 5.4 办理任务1234//根据任务Id办理任务taskService.complete(taskId);//根据任务Id办理任务,并设置任务变量taskService.complete(taskId, variables); variables是Map，当设置变量时，会在act_ru_variables表中添加相应条数的数据，变量可以用来执行gateway的判断，后面会讲到gateway。 5.5 判断流程是否结束在流程执行过程中，创建的流程实例ID在整个过程都不会变，当流程结束后，流程实例将被删除。 从运行库中查询该流程是否还存在 从历史库中查询该流程是否存在 1234567891011121314151617181920212223242526@Testpublic String checkStatus() &#123; String processInstanceId = "1213"; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); RuntimeService runtimeService = processEngine.getRuntimeService(); //从运行库查询该流程实例是否存在 ProcessInstance instance = runtimeService.createProcessInstanceQuery() .processInstanceId(processInstanceId) .singleResult(); //实例不存在，可能未开始或者已结束 if (instance == null) &#123; //从历史库查 HistoryService historyService = processEngine.getHistoryService(); HistoricProcessInstance singleResult = historyService.createHistoricProcessInstanceQuery() .processInstanceId(processInstanceId) .singleResult(); if (singleResult != null &amp;&amp; singleResult.getEndTime() != null) &#123; //流程已结束 return "COMPLETE"; &#125; else &#123; //流程未开始 return "NOT_START"; &#125; &#125; return instance.getActivityId();//当前任务节点&#125; 6 流程历史在前一个的例子中，大家可能会流程执行完毕后，究竟去了哪里有些疑问。虽然已完成的任务在act_ru_task和act_ru_execution表中都已被删除，但是这些数据还存在activiti的数据库中，作为历史改由HistoryService来管理。 历史是一个组件，它可以捕获发生在进程执行中的信息并永久的保存，与运行时数据不同的是，当流程实例运行完成之后它还会存在于数据库中。 在流程引擎配置对象中可以设置历史记录规则： 1234567891011&lt;bean name="processEngineConfiguration" class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration"&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;!-- Activiti提供了四种历史级别： none:不保存任何历史，可以提高性能 activiti:保存所有流程实例、任务、活动信息 audit:默认级别,保存所有流程实例、任务、活动、表单 full:保存所有信息,如流程变量 --&gt; &lt;property name="history" value="activiti"/&gt; 由于数据库中保存着历史信息以及正在运行的流程实例信息，在实际项目中对已完成任务的查看频率远不及对代办和可接任务的查看，所以在activiti采用分开管理，把正在运行的交给runtimeService管理，而历史数据交给HistoryService来管理。 对已成为历史的数据主要进行查询操作，我们主要关心两种类型的历史数据： HistoricProcessInstance 包含当前和已经结束的流程实例信息。 HistoricActivityInstance 包含一个活动(流程上的节点)的执行信息。 6.1 查看历史流程实例123456789101112131415161718@Testpublic void queryHisInstance() &#123; //流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); //流程定义ID String processDefinitionId = "HelloWorld:2:37504"; //查询历史流程实例 List&lt;HistoricProcessInstance&gt; list = processEngine.getHistoryService().createHistoricProcessInstanceQuery() .processDefinitionId(processDefinitionId) .finished() .orderByProcessInstanceStartTime().desc() .list(); for (HistoricProcessInstance hp : list) &#123; System.out.println("ID："+hp.getId()); System.out.println("startTime："+hp.getStartTime()); System.out.println("endTime："+hp.getEndTime()); &#125;&#125; 1.通常查询历史流程实例都需要指定一个过滤条件，指定 processDefinitionId查看具体某一次部署所开启的流程或者指定 processDefinitionKey查看某个规则下不限版本的所有流程 2.可以选择性添加finished方法控制是否查询未完成的流程实例。在流 程开启时，activiti同时在act_ru_execution表和act_hi_procinst表中 创建了一条记录，在流程完成之前act_hi_procinst表中实例的结束时间为空 6.2 查看历史流程活动（节点）1234567891011121314151617181920212223@Testpublic void queryHisActiviti() &#123; //流程引擎 ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); //流程实例ID String processInstanceId = "HelloWorld:2:37504"; //查询历史流程活动 List&lt;HistoricActivityInstance&gt; list = processEngine.getHistoryService() //创建历史流程活动实例查询对象 .createHistoricActivityInstanceQuery() //过滤条件 .processInstanceId(processInstanceId) //排序 .orderByHistoricActivityInstanceStartTime().desc() //执行查询 .list(); for (HistoricActivityInstance ha : list) &#123; System.out.println("ID："+ha.getActivityId()); System.out.println("name:"+ha.getActivityName()); System.out.println("startTime："+ha.getStartTime()); System.out.println("endTime："+ha.getEndTime()); &#125;&#125; 通常查询历史流程活动都需要指定一个过滤条件，指定processInstanceId查看具体某一次流程执行过程中所经历的步奏 7 流程变量流程变量在整个工作流中扮演很重要的作用。例如：请假流程中有请假天数、请假原因等一些参数都为流程变量的范围。流程变量的作用域范围是流程实例。也就是说各个流程实例的流程变量是不相互影响的。流程实例结束完成以后流程变量是否保存在数据库中取决于存储策略，见第六章。 7.1 添加流程变量 启动流程实例时添加 1234567891011@Testpublic void addVariables() &#123; ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine(); RuntimeService runtimeService = processEngine.getRuntimeService(); String processDefinitionKey = "HelloWorld"; Map&lt;String,Object&gt; variables = new HashMap&lt;&gt;(); variables.put("请假天数", 3); variables.put("请假原因", "约会"); ProcessInstance processInstance = runtimeService.startProcessInstanceByKey(processDefinitionKey, variables);&#125; 说明： 1) 在启动流程实例时，通过重载startProcessInstanceByKey的方法可以加载流程变量。 2) 第二个参数要求是Map&lt;String ,Object&gt;类型，意味着可以添加多个流程变量。 3) 当这段代码执行完以后，会在数据库表act_ru_variable中添加两行记录。 完成任务时添加1234//办理过程中taskService.setVariables(taskId, variables);//提交时taskService.complete(taskId, variables); 执行流程实例时添加1234//执行流程实例时runtimeService.setVariables(executionId, variables);//流程实例提交时runtimeService.signal(executionId, processVariables);//signal用于接受任务 7.2 获取流程变量1234//某个流程的变量runtimeService.getVariables(executionId);//某个任务的变量taskService.getVariables(taskId); 说明：这些流程变量是从act_ru_variable这个表中读出来的。 7.3 流程变量范围 从图中可以看出包括了大部分封装类型和Date、String和实现了Serializable接口的类的类型。 7.4 Javabean类型变量 定义一个javabean，这个javabean实现了Serializable接口 实例化javaBean，放到map中，然后正常设置流程变量 正常取出变量 8 流程定义语言8.1 流程（Process）bpmn文件一个流程的根元素。一个流程就代表一个工作流。 8.2 顺序流（sequenceFlow）顺序流是连接两个流程节点的连线，代表一个节点的出口。流程执行完一个节点后，会沿着节点的所有外出顺序流继续执行。 就是说，BPMN 2.0默认的行为就是并发的： 两个外出顺序流会创造两个单独的，并发流程分支。 顺序流主要由4个属性组成： Id: 唯一标示，用来区分不同的顺序流 sourceRef：连线的源头节点ID targetRef：连线的目标节点ID name（可选）：连线的名称，不涉及业务，主要用于显示 8.3 节点8.3.1 开始事件节点(startEvent)开始事件用来指明流程在哪里开始。开始事件的类型（流程在接收事件时启动， 还是在指定时间启动，等等），定义了流程如何启动， 这通过事件中不同的小图表来展示。 在XML中，这些类型是通过声明不同的子元素来区分的。 空开始事件空开始事件技术上意味着没有指定启动流程实例的触发条件。最常用的一种开始，意味着流程的启动需要手动触发，通过调用api的startProcessInstanceByXXX方法。 1ProcessInstance processInstance = runtimeService.startProcessInstanceByXXX() 图形标记：空开始事件显示成一个圆圈，没有内部图表（没有触发类型）XML结构如下： 1&lt;startEvent id="startevent" name="Start"&gt;&lt;/startEvent&gt; 定时开始事件 定时开始事件用来在指定的时间创建流程实例。 它可以同时用于只启动一次的流程 和应该在特定时间间隔启动多次的流程。 注意： 1.子流程不能使用定时开始事件。 2.定时开始事件在流程发布后就会开始计算时间。不需要调用startProcessInstanceByXXX，虽然也而已调用启动流程的方法，但是那会导致调用startProcessInstanceByXXX时启动过多的流程。 3.当包含定时开始事件的新版本流程部署时，对应的上一个定时器就会被删除。这是因为通常不希望自动启动旧版本流程的流程实例。 图形标记：定时开始事件显示为一个圆圈，内部是一个表。XML内容：定时开始事件的XML内容是普通开始事件的声明，包含一个定时定义子元素。示例：流程会启动4次，每次间隔5分钟，从2013年9月18日，12:10开始计时。 12345&lt;startEvent id="theStart"&gt; &lt;timerEventDefinition&gt; &lt;timeCycle&gt;R4/2017-11-22T11:04/PT5M&lt;/timeCycle&gt; &lt;/timerEventDefinition&gt;&lt;/startEvent&gt; 示例：流程会根据选中的时间启动一次。 12345&lt;startEvent id="theStart"&gt; &lt;timerEventDefinition&gt; &lt;timeDate&gt;2017-12-31T23:59:59&lt;/timeDate&gt; &lt;/timerEventDefinition&gt;&lt;/startEvent&gt; 8.3.2 结束事件节点(endEvent)结束事件表示（子）流程（分支）的结束。结束事件都是触发事件。这是说当流程达结束事件，会触发一个结果。 结果的类型是通过事件的内部黑色图标表示的。 空结束事件 空结束事件意味着到达事件时不会指定抛出的结果。这样，引擎会直接结束当前执行的分支，不会做其他事情。图形标记:空结束事件是一个粗边圆圈，内部没有小图表（无结果类型）XML内容:空结束事件的XML内容是普通结束事件定义，不包含子元素（其他结束事件类型都会包含声明类型的子元素）。 1&lt;endEvent id="end" name="my end event"/&gt; 8.3.3 任务节点(Task) 用户任务节点用户任务用来设置必须由人员完成的工作。当流程执行到用户任务，会创建一个新任务，并把这个新任务加入到分配人或群组的任务列表中。图形标记：用户任务显示成一个普通任务（圆角矩形），左上角有一个小用户图标。XML内容：XML中的用户任务定义如下。id属性是必须的。 name属性是可选的。 1&lt;userTask id="theTask" name="Important task"/&gt; 用户任务也可以设置描述(实际上所有BPMN 2.0元素都可以设置描述)。 添加documentation元素可以定义描述。 1234&lt;userTask id="theTask" name="Schedule meeting"&gt; &lt;documentation&gt; Schedule an engineering meeting for next week with the new hire. &lt;/documentation&gt; 在实际应用中，用户接到任务后可以参照任务描述来办理任务，描述文本可以通过标准的java方法来获得： 1task.getDescription() 私人任务 私有任务即有直接分配给指定用户的任务。只有一个用户可以成为任务的执行者。 在activiti中，用户叫做执行者。 拥有执行者的用户任务（即私有任务）对其他用户是不可见的。只能出现执行者的个人任务列表中. 直接把用户任务分配给指定用户使用assignee属性，XML代码如下： 1&lt;userTask id="theTask" name="my task" activiti:assignee="username"/&gt; Assignee属性对应的值为一个用户的ID。 直接分配给用户的任务可以通过TaskService像下面这样办理： 123 List&lt;Task&gt;tasks =taskService.createTaskQuery().taskAssignee("sirius").list();Task task = tasks.get(0);// 假设任务集合的第一条是要办理的任务taskService.complete(task.getId()); 公有任务 有的用户任务在指派时无法确定具体的办理者，这时任务也可以加入到 人员的候选任务列表中，然后让这些人员选择性认领和办理任务。 公有任务的分配可以分为指定候选用户和候选组两种。 - 把任务添加到一批用户的候选任务列表中，使用candidateUsers 属 性，XML内容如下: 1&lt;userTaskid="theTask"name="my task"activiti:candidateUsers="sirius,kermit"/&gt; candidateUsers属性内为用户的ID，多个用户ID之间使用（半角）逗号间隔。 - 把任务添加到一个或多个候选组下，这时任务对组下的所有用户可见，首先得保证每个组下面有用户，通过IdentityService对象创建用户和组，然后把用户添加到对应的组下。然后配置组任务，使用candidateGroups属性，XML内容如下： 1&lt;userTask id="theTask" name="my task" activiti:candidateGroups="testGroup，developGroup"/&gt; 间接分配给用户的任务，可以通过TaskService像下面这样操作： 123456List&lt;Task&gt;tasks =taskService.createTaskQuery().taskCandidateUser("sirius").list();Task task = tasks.get(0);// 假设任务集合的第一条是要办理的任务String taskId = task.getId();taskService.claim(taskId ,“sirius”); //认领任务，让用户成为任务的执行者taskService.complete(taskId ); 说明： 1. 要维护用户和组得使用用户管理服务对象，使用 processEngine 得到IdentityService。 2. 要分配组任务必须先创建组，而且组下得有用户，用户和组的 最关键属性是ID。 3. 使用newUser（userId）和newGroup（groupId）创建用户和组。 4. 使用createMembership（userId，groupId）把用户挂到组下。 5. 办理候选任务，首先得认领任务，让用户成为任务的执行者 如果上面的方式还不够灵活，那么我们也可以自定义一个任务分配处理器，通过代码的方式来动态设置任务的属性。XML代码如下： 12345&lt;userTask id="task1" name="My task"&gt; &lt;extensionElements&gt; &lt;activiti:taskListener event="create" class="org.activiti.MyAssignmentHandler"/&gt; &lt;/extensionElements&gt;&lt;/userTask&gt; DelegateTask会传递给TaskListener的实现，通过它可以设置执行人，候选人和候选组： 123456789101112Public class MyAssignmentHandler implements TaskListener &#123; Public void notify(DelegateTask delegateTask)&#123; // 执行用户搜索相关代码 ... // 然后把获取到的用户通过下面方法，设置给当前触发事件的任务 delegateTask.setAssignee("sirius"); //delegateTask.addCandidateUser("kermit"); //delegateTask.addCandidateGroup("testGroup"); ... &#125;&#125; 接收任务节点（receiveTask） 接收任务是一个简单任务，它会等待对应消息的到达。当前，官方只实现了这个任务的java语义。 当流程达到接收任务，流程状态会保存到数据库中。在任务创建后，意味着流程会进入等待状态，直到引擎接收了一个特定的消息，这会触发流程穿过接收任务继续执行。 图形标记：接收任务显示为一个任务（圆角矩形），右上角有一个消息小标记。 消息是白色的（黑色图标表示发送语义）。 XML内容： 1&lt;receiveTask id="waitState" name="wait"/&gt; 当前任务（一般指机器自动完成，但需要耗费一定时间的工作）完成后，向后推移流程，可以调用runtimeService.signal(executionId)，传递接收任务上流程的id。 123456ProcessInstance pi = runtimeService.startProcessInstanceByKey("receiveTask");Execution execution = runtimeService.createExecutionQuery() .processInstanceId(pi.getId()) .activityId("waitState") .singleResult();runtimeService.signal(execution.getId()); 述两个虽然都可以统称为任务节点，但是还是有本质区别： receiveTask主要代表机器自动执行的，userTask代表人工干预的。 eiveTask任务产生后会在act_ru_execution表中新增一条记录， 而userTask产生后会在act_ru_execution和act_ru_task（主要记录任 务的发布时间，办理人等信息）中各产生一条记录。 receiveTask任务提交方式使用RuntimeService的signal方法提交， userTask任务提交方式使用TaskService的complete方法提交。 8.3.4 网关（gateWay） 排他网关排他网关（也叫异或（XOR）网关，或更技术性的叫法基于数据的排他网关），用来在流程中实现决策。 图形标记:排他网关显示成一个普通网关（比如，菱形图形）,内部是一个“X”图标,表示异或（XOR）语义。注意，没有内部图标的网关，默认为排他网关。BPMN2.0规范不允许在同一个流程定义中同时使用没有X和有X的菱形图形。 XML内容:排他网关的XML内容是很直接的：用一行定义了网关,条件表达式定义在外出顺序流中。参考条件顺序流 获得这些表达式的可用配置。 12345678910&lt;exclusiveGatewayid="exclusiveGw"name="Exclusive Gateway"/&gt;&lt;sequenceFlow id="flow2" sourceRef="exclusiveGw" targetRef="theTask1"&gt; &lt;conditionExpressionxsi:type="tFormalExpression"&gt;$&#123;input == 1&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; &lt;sequenceFlow id="flow3" sourceRef="exclusiveGw" targetRef="theTask2"&gt; &lt;conditionExpressionxsi:type="tFormalExpression"&gt;$&#123;input == 2&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt;&lt;sequenceFlow id="flow4" sourceRef="exclusiveGw" targetRef="theTask3"&gt; &lt;conditionExpressionxsi:type="tFormalExpression"&gt;$&#123;input == 3&#125;&lt;/conditionExpression&gt; &lt;/sequenceFlow&gt; 说明： 1.一个排他网关对应一个以上的顺序流 2.由排他网关流出的顺序流都有个conditionExpression元素，在内部维护返回boolean类型的决策结果。 3.决策网关只会返回一条结果。当流程执行到排他网关时，流程引擎会自动检索网关出口，从上到下检索如果发现第一条决策结果为true或者没有设置条件的(默认为成立)，则流出。 4.如果没有任何一个出口符合条件则抛出异常。 并行网关 网关也可以表示流程中的并行情况。最简单的并行网关是parallelGateWay，它允许将流程分成多条分支，也可以把多条分支汇聚到一起。 图形标记：并行网关显示成一个普通网关（菱形）内部是一个“加号”图标，表示“与（AND）”语义。 XML内容：定义并行网关只需要一行 1&lt;parallelGateway id="myParallelGateway"/&gt; 实际发生的行为（分支，聚合，同时分支聚合），要根据并行网关的顺序流来决定。 123456789101112131415161718192021&lt;startEvent id="theStart"/&gt;&lt;sequenceFlow id="flow1" sourceRef="theStart" targetRef="fork"/&gt;&lt;parallelGateway id="fork"/&gt; &lt;sequenceFlow sourceRef="fork" targetRef="receivePayment"/&gt;&lt;sequenceFlow sourceRef="fork" targetRef="shipOrder"/&gt; &lt;userTaskid="receivePayment"name="Receive Payment"/&gt;&lt;sequenceFlow sourceRef="receivePayment" targetRef="join"/&gt; &lt;userTaskid="shipOrder"name="Ship Order"/&gt;&lt;sequenceFlow sourceRef="shipOrder" targetRef="join"/&gt;&lt;parallelGateway id="join"/&gt;&lt;sequenceFlow sourceRef="join" targetRef="archiveOrder"/&gt; &lt;userTask id="archiveOrder"name="Archive Order"/&gt;&lt;sequenceFlow sourceRef="archiveOrder" targetRef="theEnd"/&gt; &lt;endEventid="theEnd"/&gt; 上面例子中，流程启动之后，会创建两个任务： 1234567ProcessInstancepi =runtimeService.startProcessInstanceByKey("forkJoin");List&lt;Task&gt; tasks = taskService.createTaskQuery().list();Task task1 =tasks.get(0);System.out.println("Receive Payment"+task1.getName());Task task2 =tasks.get(1);System.out.println("Ship Order"+task2.getName()); 当两个任务都完成时，第二个并行网关会汇聚两个分支，因为它只有一条外出连线，不会创建并行分支，只会创建归档订单任务。 说明：1.并行网关的功能是基于进入和外出的顺序流的： 分支(fork)：并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。 汇聚(join)：所有到达并行网关，在此等待的进入分支，直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。 2.并行网关的进入和外出都是使用相同节点标示3.如果同一个并行网关有多个进入和多个外出顺序流，它就同时具有分支和汇聚功能。这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。4.并行网关不会解析条件。 即使顺序流中定义了条件，也会被忽略。5.并行网关不需要是“平衡的”（比如，对应并行网关的进入和外出节点数目相等）。如图中标示是合法的： 8.4 监听器（Listener）在流程中我们有时会对整个流程或者一个节点的某种状态做出相应的处理。这时就会用到监听器。 在Activiti中流程的监听主要分为两大类，执行监听器和任务监听器。 8.4.1 执行监听器（ExecutionListener）执行监听器可以执行外部java代码或执行表达式，当流程定义中发生了某个事件。 可以捕获的事件有: 流程实例的启动和结束。 选中一条连线。 节点的开始和结束。 网关的开始和结束。 中间事件的开始和结束。 开始事件结束或结束事件开始。 现在有这样一个简单流程，只包含开始、结束、接收任务和用户任务4个节点：配置监听器,XML代码如下123&lt;extensionElements&gt; &lt;activiti:executionListener event="start" class="test.ProcessStartListener"&gt;&lt;/activiti:executionListener&gt;&lt;/extensionElements&gt; 说明： 任务监听器支持以下属性： event（必选）：任务监听器会被调用的任务类型 start：流程节点创建后触发 end：当任务完成，并尚未从运行数据中删除时触发 take：任务完成后，流程流出时触发 class(必选)：代理类，实现org.activiti.engine.delegate.ExecutionListener接口。示例：12345678910public class ProcessStartListener implements ExecutionListener &#123;private static final long serialVersionUID = 1L;@Overridepublic void notify(DelegateExecution execution) throws Exception &#123; System.out.println("ID:"+execution.getId()+", Name:"+execution.getCurrentActivityName()); &#125;&#125; 执行监听器配置可以放在以下三个地方，如图 a) 监听整个流程的启动和结束状态，配置为process节点的子元素，如① b) 监听一个节点的启动和结束状态，配置为一个节点的子元素，如②和③ c) 监听一条连线的执行，配置在sequenceFlow节点的内部，只有task一种事件，如④ 启动流程测试代码如下：12345678910111213141516@Testpublic void Demo1() &#123; //部署流程 Deployment deployment = repositoryService.createDeployment() .addClasspathResource("diagrams/Listener.bpmn") .addClasspathResource("diagrams/Listener.png") .deploy(); //启动 ProcessInstance processInstance = runtimeService.startProcessInstanceByKey("ListenerTest"); //推动 String processInstanceId = processInstance.getId(); runtimeService.signal(processInstanceId); String id = taskService.createTaskQuery().processInstanceId(processInstanceId).singleResult().getId(); taskService.complete(id);&#125; 测试结果如下： ID:60005, Name:开始 ID:60005, Name:接收任务 ID:60005, Name:用户任务 8.4.2 任务监听器（TaskListener）任务监听器可以在发生对应的任务相关事件时执行自定义java逻辑 或表达式。任务监听器只能添加到流程定义中的用户任务中。在之前任务节点上添加任务监听: 任务监听器支持以下属性 event（必选）：任务监听器会被调用的任务类型。 可能的类型为： create：任务创建并设置所有属性后触发。 assignment：任务分配给一些人时触发。当流程到达userTask，assignment事件 会在create事件之前发生。这样的顺序似乎不自然，但是原因很简单：当获得create时间时， 我们想获得任务的所有属性，包括执行人。 complete：当任务完成，并尚未从运行数据中删除时触发。 class：必须调用的代理类。 这个类必须实现org.activiti.engine.delegate.TaskListener 接口。 新添加的任务监听包裹在executionListener监听的内部，顺序为：execution Start–&gt; task Assignment–&gt;task Create–&gt;task Complete–&gt;execution End–&gt;execution take。 9 Spring集成虽然前面的例子中我们可以自己手动来创建相应的API实例，但是在一个项目中这些API都应该以单例形式存在的。和Spring的集成主要就是把Activiti的主要对象交给Spring容器管理。 12345678910111213141516171819202122232425&lt;!-- 流程引擎 --&gt;&lt;bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean"&gt; &lt;property name="processEngineConfiguration" ref="processEngineConfiguration"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!-- 流程引擎配置对象 --&gt;&lt;bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration"&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;property name="transactionManager" ref="transactionManager" /&gt; &lt;!-- activiti表数据更新策略 false true（默认） create-drop--&gt; &lt;property name="databaseSchemaUpdate" value="true" /&gt; &lt;!-- activiti历史数据保存策略 none activity audit(默认) full--&gt; &lt;property name="history" value="audit" /&gt; &lt;!-- 管理线程计时器和异步消息,默认开启，但有ManagementService替代，避免冲突所以关闭 --&gt; &lt;property name="jobExecutorActivate" value="false" /&gt; &lt;!-- 加载资源文件 --&gt; &lt;property name="deploymentResources" value="classpath:/activiti-process/*.bpmn" /&gt;&lt;/bean&gt;&lt;!-- 核心业务类 --&gt;&lt;bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService" /&gt;&lt;bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService" /&gt;&lt;bean id="taskService" factory-bean="processEngine" factory-method="getTaskService" /&gt;&lt;bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService" /&gt;&lt;bean id="managementService" factory-bean="processEngine" factory-method="getManagementService" /&gt; 注意： ProcessEngineConfiguration单独使用和整合Spring时不是同一个class独立使用：org.activiti.engine.ProcessEngineConfiguration整合Spring：org.activiti.spring.SpringProcessEngineConfiguration 项目部署后会自动在数据库中创建相关流程定义]]></content>
      <categories>
        <category>JavaEE</category>
      </categories>
      <tags>
        <tag>activiti</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Callable及Future]]></title>
    <url>%2FCallable%E5%8F%8AFuture.html</url>
    <content type="text"><![CDATA[1. 概述在线程池中执行任务，使用execute()方法，执行的是Runnable任务，它不返回任何值。如果希望任务完成后返回结果，那么需要使用Callable接口，这也是本文要研究的主题。 12345678910111213141516171819202122232425262728293031public class CallableTest &#123; public static void main(String[] args) &#123; Callable&lt;Integer&gt; callable = new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; System.out.println("callable线程执行"); return new Random().nextInt(100); &#125; &#125;; ExecutorService executorService = Executors.newSingleThreadExecutor(); Future&lt;Integer&gt; future = executorService.submit(callable); try &#123; // 限定时间获取结果 System.out.println(future.get(5, TimeUnit.SECONDS)); &#125; catch (TimeoutException e) &#123; // 超时触发线程中止 e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; // 抛出执行异常 e.printStackTrace(); &#125; finally &#123; // 如果任务还在运行，执行中断 boolean mayInterruptIfRunning = true; future.cancel(mayInterruptIfRunning); &#125; &#125;&#125; 上面是callable和future的简单应用，执行时要求在限定时间内获取结果，超时执行会抛出TimeoutException，执行异常会抛出ExecutionException。最后在finally里，如果任务还在执行，就进行取消；如果任务已经执行完，取消操作也没有影响。 2. Callable接口我们先回顾一下java.lang.Runnable接口，就声明了run(),其返回值为void，当然就无法获取结果了。123public interface Runnable &#123; public abstract void run(); &#125; 而callable的接口定义如下：123public interface Callable&lt;V&gt; &#123; V call() throws Exception; &#125; callable接口声明call()方法，有返回值，也可抛出异常，对该接口我们先了解这么多就行，下面我们来说明如何使用。 无论是Runnable接口的实现类还是Callable接口的实现类，都可以被ThreadPoolExecutor或ScheduledThreadPoolExecutor执行，ThreadPoolExecutor或ScheduledThreadPoolExecutor都实现了ExcutorService接口，而因此Callable需要和Executor框架中的ExcutorService结合使用，我们先看看ExecutorService提供的方法：123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); 第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。 第二个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。 第三个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。这个用的很少，因为是自己给定的返回结果，意义不大。 因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。还有点要注意的是，除了我们自己实现Callable对象外，我们还可以使用工厂类Executors来把一个Runnable对象包装成Callable对象。Executors工厂类提供的方法如下：12public static Callable&lt;Object&gt; callable(Runnable task) public static &lt;T&gt; Callable&lt;T&gt; callable(Runnable task, T result) 3. Future接口Future接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get()),取消(cancel()),判断是否完成等操作。我们看看Future接口的源码：1234567public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; &#125; 方法解析： get(): 获取异步执行的结果，如果没有结果可用，此方法会阻塞直到异步计算完成。 get(long timeout, TimeUnit unit):获取异步执行结果，如果没有结果可用，此方法会阻塞，但是会有时间限制，如果阻塞时间超过设定的timeout时间，该方法将抛出异常。 isDone():如果任务执行结束，无论是正常结束或是中途取消还是发生异常，都返回true。 isCancelled():如果任务完成前被取消，则返回true。 cancel(): 如果任务还没开始，执行cancel(…)方法将返回false 如果任务已经启动，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果停止成功，返回true；当任务已经启动，执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时返回false 当任务已经完成，执行cancel(…)方法将返回false 通过方法分析我们也知道实际上Future提供了3种功能： 能够中断执行中的任务 判断任务是否执行完成 获取任务执行完成后额结果。 但是我们必须明白Future只是一个接口，我们无法直接创建对象，因此就需要其实现类FutureTask登场啦 4. FutureTask————————-————————–FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）. 4.1 FutureTask的状态12345678private volatile int state;private static final int NEW = 0;private static final int COMPLETING = 1;private static final int NORMAL = 2;private static final int EXCEPTIONAL = 3;private static final int CANCELLED = 4;private static final int INTERRUPTING = 5;private static final int INTERRUPTED = 6; FutureTask有7种状态，初始状态从NEW开始，状态转换路径可以归纳为图2所示。在后文的代码，会使用int的大小比较判断状态处于哪个范围，需要留意上面状态的排列顺序FutureTask的状态路径，取决于run和cancel的调用顺序，在后文分析时，对号入座这几条路径。 NEW -&gt; COMPLETING -&gt; NORMAL 正常的流程 NEW -&gt; COMPLETING -&gt; EXCEPTIONAL 异常的流程 NEW -&gt; CANCELLED 被取消流程 NEW -&gt; INTERRUPTING -&gt; INTERRUPTED 被中断流程 4.2 FutureTask的变量123456789private volatile int state;/** The underlying callable; nulled out after running */private Callable&lt;V&gt; callable;/** The result to return or exception to throw from get() */private Object outcome; // non-volatile, protected by state reads/writes/** The thread running the callable; CASed during run() */private volatile Thread runner;/** Treiber stack of waiting threads */private volatile WaitNode waiters; state、runner、waiters三个变量没有使用原子类，而是使用Unsafe对象进行原子操作。代码中会见到很多形如compareAndSwap的方法，入门原理可以看认识非阻塞的同步机制CAS。 callable是要执行的任务，runner是执行任务的线程，outcome是返回的结果（正常结果或Exception结果） 12345static final class WaitNode &#123; volatile Thread thread; volatile WaitNode next; WaitNode() &#123; thread = Thread.currentThread(); &#125;&#125; waiters的数据结构是WaitNode，保存了Thread和下个WaitNode的引用。waiters保存了等待结果的线程，每次操作只会增减头，所以是一个栈结构，详细见后文对get方法的分析。 4.3 FutureTask的创建下面是FutureTask的两种创建方式：1234567891011public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125;public FutureTask(Runnable runnable, V result) &#123; this.callable = Executors.callable(runnable, result); this.state = NEW; // ensure visibility of callable&#125; 提交FutureTask到线程池的submit定义在AbstractExecutorService，根据入参的不同，有三个submit方法。下面以提交Callable为例： 12345678910public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; FutureTask在newTaskFor创建，然后调用线程池的execute执行，最后返回Future。获取Future后，就可以调用get获取结果，或者调用cancel取消任务。 4.4 FutureTask的运行FutureTask实现了Runnable，在线程池里执行时调用的方法是run。 123456789101112131415161718192021222324252627282930public void run() &#123; //1 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset,null, Thread.currentThread())) return; //2 try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; result = null; ran = false; setException(ex); &#125; if (ran) set(result); &#125; &#125; finally &#123; //3 runner = null; int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 标记1处检查FutureTask的状态，如果不是处于NEW，说明状态已经进入四条路径之一，也就没有必要继续了。如果状态是NEW，则将执行任务的线程交给runner。 标记2处开始正式执行任务，调用call方法获取结果，没有异常就算成功，最后执行set方法；出现异常就调用setException方法。 标记3处，无论任务执行是否成功，都需要将runner重新置为空。 123456789101112131415protected void set(V v) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); &#125;&#125;protected void setException(Throwable t) &#123; if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = t; UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); &#125;&#125; 任务执行成功与失败，分别对应NEW -&gt; COMPLETING -&gt; NORMAL和NEW -&gt; COMPLETING -&gt; EXCEPTIONAL两条路径。这里先将状态修改为中间状态，再对结果赋值，最后再修改为最终状态。 12345678910111213141516171819202122private void finishCompletion() &#123; // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) &#123; if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; for (;;) &#123; Thread t = q.thread; if (t != null) &#123; q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); callable = null; // to reduce footprint&#125; 最后调用finishCompletion执行任务完成，唤醒并删除所有在waiters中等待的线程。done方法是空的，供子类实现，最后callable也设置为空。 FutureTask还有个runAndReset，逻辑和run类似，但没有调用set方法来设置结果，执行完成后将任务重新初始化。 1234567891011121314151617181920212223242526272829protected boolean runAndReset() &#123; if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return false; boolean ran = false; int s = state; try &#123; Callable&lt;V&gt; c = callable; if (c != null &amp;&amp; s == NEW) &#123; try &#123; c.call(); // don't set result ran = true; &#125; catch (Throwable ex) &#123; setException(ex); &#125; &#125; &#125; finally &#123; // runner must be non-null until state is settled to // prevent concurrent calls to run() runner = null; // state must be re-read after nulling runner to prevent // leaked interrupts s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125; return ran &amp;&amp; s == NEW;&#125; 4.5 FutureTask的取消对于已经提交执行的任务，可以调用cancel执行取消。 12345678910111213141516171819202122public boolean cancel(boolean mayInterruptIfRunning) &#123; //1 if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception //2 if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; finishCompletion(); &#125; return true;&#125; 标记1处判断任务状态，为NEW才能被取消。如果mayInterruptIfRunning是true，代表任务需要被中断，走NEW -&gt; INTERRUPTING -&gt; INTERRUPTED流程。否则代表任务被取消，走NEW -&gt; CANCELLED流程。 标记2处理任务被中断的情况，这里仅仅是对线程发出中断请求，不确保任务能检测并处理中断，详细原理去看Java的中断机制。 最后调用finishCompletion完成收尾工作。 123public boolean isCancelled() &#123; return state &gt;= CANCELLED;&#125; 判断任务是否被取消，具体逻辑是判断state &gt;= CANCELLED，包括了被中断一共两条路径的结果。 4.5 FutureTask获取结果调用FutureTask的get方法获取任务的执行结果，可以阻塞直到获取结果，也可以限制范围时间内获取结果，否则抛出TimeoutException。1234567891011121314151617public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);&#125;public V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123; if (unit == null) throw new NullPointerException(); int s = state; if (s &lt;= COMPLETING &amp;&amp; (s = awaitDone(true, unit.toNanos(timeout))) &lt;= COMPLETING) throw new TimeoutException(); return report(s);&#125; get的核心实现调用了awaitDone，入参为是否开启时间限制和最大的等待时间。 123456789101112131415161718192021222324252627282930313233343536private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) &#123; if (Thread.interrupted()) &#123; removeWaiter(q); throw new InterruptedException(); &#125; int s = state; if (s &gt; COMPLETING) &#123; //1 if (q != null) q.thread = null; return s; &#125; else if (s == COMPLETING) // cannot time out yet //2 Thread.yield(); else if (q == null) //3 q = new WaitNode(); else if (!queued) //4 queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); else if (timed) &#123; //5 nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; LockSupport.parkNanos(this, nanos); &#125; else //6 LockSupport.park(this); &#125;&#125; awaitDone主要逻辑是一个无限循环，首先判断线程是否被中断，是的话移除waiter并抛出中断异常。接下来是一串if-else，一共六种情况。 判断任务状态是否已经完成，是就直接返回； 任务状态是COMPLETING，代表在set结果时被阻塞了，这里先让出资源； 如果WaitNode为空，就为当前线程初始化一个WaitNode； 如果当前的WaitNode还没有加入waiters，就加入； 如果是限定时间执行，判断有无超时，超时就将waiter移出，并返回结果，否则阻塞一定时间； 如果没有限定时间，就一直阻塞到下次被唤醒。 LockSupport是用来创建锁和其他同步类的基本线程阻塞原语。park和unpark的作用分别是阻塞线程和解除阻塞线程。 12345678private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; 最后get调用report，使用outcome返回结果。 如果多个线程向同一个FutureTask实例get结果，但FutureTask又没有执行完毕，线程将会阻塞并保存在waiters中。待FutureTask获取结果后，唤醒waiters等待的线程，并返回同一个结果。]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程池的创建]]></title>
    <url>%2FJava%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA.html</url>
    <content type="text"><![CDATA[1. Executor框架从JDK 1.5 开始，java.util.concurrent包中的Executor执行器将用来管理Thread对象，从而简化并发编程。 Executor是一套线程池管理框架，接口里只有一个方法execute，执行Runnable任务。ExecutorService接口扩展了Executor，添加了线程生命周期的管理，提供任务终止、返回任务结果等方法。AbstractExecutorService实现了ExecutorService，提供例如submit方法的默认实现逻辑。 然后到今天的主题ThreadPoolExecutor，继承了AbstractExecutorService，提供线程池的具体实现。 2. ThreadPoolExecutor2.1 构造ThreadPoolExecutor的构造方法有四种，下面是参数最全的构造： 123456789public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; &#125; corePoolSize:线程池目标大小，即刚刚创建时的线程数 maximumPoolSize: 线程池的最大上限 keepAliveTime: 线程的存活时间，当线程池内的线程数量超过corePoolSize，超出存活时间的空闲线程就会被回收； unit: 时间单位 workQueue: 缓存队列 threadFactory: 线程工厂 handler: 缓存队列饱和处理策略 2.2 定制线程池ThreadPoolExecutor中有几个预先设置好的线程池，通过Executors的工厂方法创建。 2.2.1 newFixedThreadPool12345public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); &#125; newFixedThreadPool的corePoolSize和maximumPoolSize都设置为传入的固定数量，keepAliveTim设置为0。线程池创建后，线程数量将会固定不变，适合需要线程很稳定的场合。 2.2.2 newSingleThreadExecutor123456public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); &#125; newSingleThreadExecutor是线程数量固定为1的newFixedThreadPool版本，保证池内的任务串行。注意到返回的是FinalizableDelegatedExecutorService，来看看源码： 123456789static class FinalizableDelegatedExecutorService extends DelegatedExecutorService &#123; FinalizableDelegatedExecutorService(ExecutorService executor) &#123; super(executor); &#125; protected void finalize() &#123; super.shutdown(); &#125;&#125; FinalizableDelegatedExecutorService继承了DelegatedExecutorService，仅仅在gc时增加关闭线程池的操作，再来看看DelegatedExecutorService的源码： 12345678910static class DelegatedExecutorService extends AbstractExecutorService &#123; private final ExecutorService e; DelegatedExecutorService(ExecutorService executor) &#123; e = executor; &#125; public void execute(Runnable command) &#123; e.execute(command); &#125; public void shutdown() &#123; e.shutdown(); &#125; public List&lt;Runnable&gt; shutdownNow() &#123; return e.shutdownNow(); &#125; public boolean isShutdown() &#123; return e.isShutdown(); &#125; public boolean isTerminated() &#123; return e.isTerminated(); &#125; ...&#125; DelegatedExecutorService包装了ExecutorService，使其只暴露出ExecutorService的方法，因此不能再配置线程池的参数。本来，线程池创建的参数是可以调整的，ThreadPoolExecutor提供了set方法。使用newSingleThreadExecutor目的是生成单线程串行的线程池，如果还能配置线程池大小，那就没意思了。 Executors还提供了unconfigurableExecutorService方法，将普通线程池包装成不可配置的线程池。如果不想线程池被不明所以的后人修改，可以调用这个方法。 2.2.3 newCachedThreadPool12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; newCachedThreadPool生成一个会缓存的线程池，线程数量可以从0到Integer.MAX_VALUE，超时时间为1分钟。线程池用起来的效果是：如果有空闲线程，会复用线程；如果没有空闲线程，会新建线程；如果线程空闲超过1分钟，将会被回收。 2.2.4 newScheduledThreadPool123public static ScheduledExecutorService newScheduledThreadPool(int corePoolSize) &#123; return new ScheduledThreadPoolExecutor(corePoolSize); &#125; 1234public ScheduledThreadPoolExecutor(int corePoolSize) &#123; super(corePoolSize, Integer.MAX_VALUE, 0, NANOSECONDS, new DelayedWorkQueue()); &#125; newScheduledThreadPool将会创建一个可定时执行任务的线程池。这个不打算在本文展开，后续会另开文章细讲。 2.3 等待队列看完上面四个预设置的线程池，回发现在构造中都有一个 Queue 参数。 线程池的大小或有限（newFixedThreadPool）、或几乎无限（newCachedThreadPool），但是系统资源是有限的，任务的处理速度总有可能比不上任务的提交速度。因此，可以为ThreadPoolExecutor提供一个阻塞队列来保存因线程不足而等待的Runnable任务，这就是BlockingQueue。 Executor提供了以下几种等待队列（部分）： ArrayBlockingQueue：数组结构的阻塞队列 LinkedBlockingQueue：链表结构的阻塞队列 PriorityBlockingQueue：有优先级的阻塞队列 SynchronousQueue：不会存储元素的阻塞队列 DelayedWorkQueue newFixedThreadPool和newSingleThreadExecutor在默认情况下使用一个无界的LinkedBlockingQueue。要注意的是，如果任务一直提交，但线程池又不能及时处理，等待队列将会无限制地加长，系统资源总会有消耗殆尽的一刻。所以，推荐使用有界的等待队列，避免资源耗尽。但解决一个问题，又会带来新问题：队列填满之后，再来新任务，这个时候怎么办？后文会介绍如何处理队列饱和。 newCachedThreadPool使用的SynchronousQueue十分有趣，看名称是个队列，但它却不能存储元素。要将一个任务放进队列，必须有另一个线程去接收这个任务，一个进就有一个出，队列不会存储任何东西。因此，SynchronousQueue是一种移交机制，不能算是队列。newCachedThreadPool生成的是一个没有上限的线程池，理论上提交多少任务都可以，使用SynchronousQueue作为等待队列正合适。 2.4 饱和策略在上一小节中说道，等待队列不能无限制的增长，但若队列填满了该如何处理？此时就是饱和策略在发挥作用。ThreadPoolExecutor的饱和策略通过传入RejectedExecutionHandler来实现。如果没有为构造函数传入，将会使用默认的defaultHandler。 1private static final RejectedExecutionHandler defaultHandler = new AbortPolicy(); AbortPolicy 123456public static class AbortPolicy implements RejectedExecutionHandler &#123; public AbortPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; throw new RejectedExecutionException("Task " + r.toString() + " rejected from " + e.toString()); &#125; &#125; AbortPolicy是默认的实现，直接抛出一个RejectedExecutionException异常，让调用者自己处理。除此之外，还有几种饱和策略，来看一下 DiscardPolicy 12345public static class DiscardPolicy implements RejectedExecutionHandler &#123; public DiscardPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; &#125; &#125; DiscardPolicy的rejectedExecution直接是空方法，什么也不干。如果队列满了，后续的任务都抛弃掉。 DiscardOldestPolicy 123456789public static class DiscardOldestPolicy implements RejectedExecutionHandler &#123; public DiscardOldestPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; e.getQueue().poll(); e.execute(r); &#125; &#125; &#125; DiscardOldestPolicy会将等待队列里最旧的任务踢走，让新任务得以执行。 CallerRunsPolicy 12345678public static class CallerRunsPolicy implements RejectedExecutionHandler &#123; public CallerRunsPolicy() &#123; &#125; public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123; if (!e.isShutdown()) &#123; r.run(); &#125; &#125;&#125; CallerRunsPolicy它既不抛弃新任务，也不抛弃旧任务，而是直接在当前线程运行这个任务。当前线程一般就是主线程啊，让主线程运行任务，说不定就阻塞了。如果不是想清楚了整套方案，还是少用这种策略为妙。 2.5 ThreadFactory每当线程池需要创建一个新线程，都是通过线程工厂获取。如果不为ThreadPoolExecutor设定一个线程工厂，就会使用默认的defaultThreadFactory： 123public static ThreadFactory defaultThreadFactory() &#123; return new DefaultThreadFactory();&#125; 1234567891011121314151617181920212223242526static class DefaultThreadFactory implements ThreadFactory &#123; private static final AtomicInteger poolNumber = new AtomicInteger(1); private final ThreadGroup group; private final AtomicInteger threadNumber = new AtomicInteger(1); private final String namePrefix; DefaultThreadFactory() &#123; SecurityManager s = System.getSecurityManager(); group = (s != null) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup(); namePrefix = "pool-" + poolNumber.getAndIncrement() + "-thread-"; &#125; public Thread newThread(Runnable r) &#123; Thread t = new Thread(group, r, namePrefix + threadNumber.getAndIncrement(), 0); if (t.isDaemon()) t.setDaemon(false); if (t.getPriority() != Thread.NORM_PRIORITY) t.setPriority(Thread.NORM_PRIORITY); return t; &#125; &#125; 平时打印线程池里线程的name时，会输出形如pool-1-thread-1之类的名称，就是在这里设置的。这个默认的线程工厂，创建的线程是普通的非守护线程，如果需要定制，实现ThreadFactory后传给ThreadPoolExecutor即可。 参考文章链接]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用i18next完成前端国际化]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8i18next%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[i18next是一个用来支持应用国际化的javascript库,不依赖于其他第三方js库如jQuuery。i18next官方网站 1 初始化init123456789101112131415161718192021222324252627282930313233i18next .use(i18nextXHRBackend) .init(&#123; fallbackLng: 'en', lng: 'en', debug: false, ns: 'strings', defaultNS: 'strings', backend: &#123; loadPath: src + '/&#123;&#123;lng&#125;&#125;/&#123;&#123;ns&#125;&#125;.json', //在每个html中定义localesPath，即localesPath文件夹路径 crossDomain: true &#125; &#125;, function(err, t) &#123; // init set content var array = document.querySelectorAll('[data-i18n]'); if(array)&#123; for(var i = 0, len = array.length; i &lt; len; i++) &#123; var value = array[i].getAttribute('data-i18n'); array[i].innerHTML = i18next.t(value); &#125; &#125;; var inputs = document.querySelectorAll('input'); if(inputs) &#123; for(var i = 0, len = inputs.length; i &lt; len; i++) &#123; var placeholder = inputs[i].getAttribute("placeholder"); var value = inputs[i].getAttribute('data-i18n'); if(placeholder != null)&#123; inputs[i].setAttribute("placeholder", i18next.t(value)); &#125; &#125; &#125; &#125;); 2 API2.1 initi18next.init(options, callback) 123456789101112131415i18next.init(&#123; fallbackLng: 'en', ns: ['file1', 'file2'], defaultNS: 'file1', debug: true&#125;, (err, t) =&gt; &#123; if(err) return console.log('something went wrong loading', err); t('key'); // -&gt; same as i18next.t&#125;);// with only callbacki18next.init((err, t) =&gt; &#123; if(err) return console.log('something went wrong loading', err); t('key'); // -&gt; same as i18next.t&#125;); debug:default false，是否输出日志 fallbackLng:default ‘dev’,当当前语言中找不到key，则去fallbackLng中查找 lng:default undefined,设置当前翻译的语言 ns：default ‘translation’，命名空间，可以是数组，可以理解为国际化文件的名字 defaultNS：default ‘translation’，如果没有找到设置的ns文件，则去找defaultNS文件 backend：设置国际化文件路径，需要配合i18nextXHRBackend插件使用，可以跨域读取网络文件，可以读取本地文件。具体配置参看i18next-xhr-backend loadPath： 文件路径 crossDomain： 是否强制跨域 2.2 usei18next.use(module) 用来添加插件,如下代码所示，注意：一定要在工程中引入对应的js文件123456i18next .use(Backend) .use(Cache) .use(LanguageDetector) .use(postProcessor) .init(options, callback); 2.3 ti18next.t(keys, options) 在js中手动查找key得到对应翻译，options可省略，基本用法如下，详细用法请参看interpolation 1i18next.t('common.hello') 或 t('common.hello') 3 小结以上是i18next的基本使用，可以满足基本的国际化需求。对于更加复杂的国际化需求，请参看官方文档。 说明： 国际化文件为json格式 国际化文件路径建议设置为 locales/语言（国家代码）/命名空间.json 对应第2条，loadPath设置为 locales文件夹路径//.json]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thread及Runnable]]></title>
    <url>%2FThread%E5%8F%8ARunnable.html</url>
    <content type="text"><![CDATA[本文简单介绍了多线程的基本概念、基于Thread和Runnable实现多线程编程及简单的线程安全问题示例。 1 概述1.1 进程与线程 进程是正在执行的程序 JVM是一个进程. 线程进程中用于控制程序执行的控制单元(执行路径) 进程中至少有一个线程,对于JVM,启动时至少有两个线程:JVM的主线程和JVM的垃圾回收线程 1.2 并行与并发 并行就是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU) 并发是指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。 1.3 基本实现方式1.3.1 继承Thread类覆盖run方法1234567891011121314151617181920package com.topvision.thread;public class ThreadDemo1 &#123; public static void main(String[] args) &#123; Demo1 d1 = new Demo1(); d1.start(); for (int i = 0; i &lt; 60; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125;class Demo1 extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125; 1.3.2 实现Runnable接口实现run方法123456789101112131415161718public class ThreadDemo1 &#123; public static void main(String[] args) &#123; Thread d2 = new Thread(new Demo2()); d2.start(); for (int i = 0; i &lt; 60; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125;class Demo2 implements Runnable &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(Thread.currentThread().getName() + i); &#125; &#125;&#125; 1.4 继承Thread与实现Runnable的区别 查看源码的区别: a.继承Thread : 由于子类重写了Thread类的run(), 当调用start()时, 直接找子类的run()方法 b.实现Runnable : 构造函数中传入了Runnable的引用, 成员变量记住了它, start()调用run()方法时内部判断成员变量Runnable的引用是否为空, 不为空编译时看的是Runnable的run(),运行时执行的是子类的run()方法 继承Thread 好处是:可以直接使用Thread类中的方法,代码简单 弊端是:如果已经有了父类,就不能用这种方法 实现Runnable接口 好处是:即使自己定义的线程类有了父类也没关系,因为有了父类也可以实现接口,而且接口是可以多实现的 弊端是:不能直接使用Thread中的方法需要先获取到线程对象后,才能得到Thread的方法,代码复杂 2 基本API与人有生老病死一样，线程也同样要经历开始（等待）、运行、挂起和停止四种不同的状态。这四种状态都可以通过Thread类中的方法进行控制。下面给出了Thread类中和这四种状态相关的方法。 开始线程 publicvoid start( );publicvoid run( ); 挂起和唤醒线程 publicvoid resume( ); // 不建议使用publicvoid suspend( ); // 不建议使用publicstaticvoid sleep(long millis);publicstaticvoid sleep(long millis, int nanos); 终止线程 publicvoid stop( ); // 不建议使用publicvoid interrupt( ); 得到线程状态 publicboolean isAlive( );publicboolean isInterrupted( );publicstaticboolean interrupted( ); join方法 publicvoid join( ) throws InterruptedException; 线程在建立后并不马上执行run方法中的代码，而是处于等待状态。线程处于等待状态时，可以通过Thread类的方法来设置线程不各种属性，如线程的优先级（setPriority）、线程名(setName)和线程的类型（setDaemon）等。 当调用start方法后，线程开始执行run方法中的代码。线程进入运行状态。可以通过Thread类的isAlive方法来判断线程是否处于运行状态。当线程处于运行状态时，isAlive返回true，当isAlive返回false时，可能线程处于等待状态，也可能处于停止状态。 一但线程开始执行run方法，就会一直到这个run方法执行完成这个线程才退出。但在线程执行的过程中，可以通过两个方法使线程暂时停止执行。这两个方法是suspend和sleep。在使用suspend挂起线程后，可以通过resume方法唤醒线程。而使用sleep使线程休眠后，只能在设定的时间后使线程处于就绪状态（在线程休眠结束后，线程不一定会马上执行，只是进入了就绪状态，等待着系统进行调度）。 2.1 设置及获取线程名字 构造方法中传入名字 new Thread(“张三”){} 线程对象设置名字 thread.setName() 线程对象获取名字 thread.getName() Thread.currentThread().hetName() 2.2 休眠线程Sleep sleep方法有两个重载形式，其中一个重载形式不仅可以设毫秒，而且还可以设纳秒(1,000,000纳秒等于1毫秒)。但大多数操作系统平台上的Java虚拟机都无法精确到纳秒，因此，如果对sleep设置了纳秒，Java虚拟机将取最接近这个值的毫秒。 在使用sleep方法时必须使用throws或try{…}catch{…}。因为run方法无法使用throws，所以只能使用try{…}catch{…}。当在线程休眠的过程中，使用interrupt方法中断线程时sleep会抛出一个InterruptedException异常。sleep方法的定义如下： publicstaticvoid sleep(long millis) throws InterruptedException publicstaticvoid sleep(long millis, int nanos) throws InterruptedException 2.3 守护线程DaemonsetDaemon(), 设置一个线程为守护线程, 该线程不会单独执行, 当其他非守护线程都执行结束后, 自动退出 12345678910111213141516171819202122232425262728public class ThreadDemo4 &#123; /** * @param args * 守护线程 */ public static void main(String[] args) &#123; Thread t1 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName() + "...aaaaaaaaaaaaaaaaaaaa"); &#125; &#125; &#125;; Thread t2 = new Thread() &#123; public void run() &#123; for (int i = 0; i &lt; 5000; i++) &#123; System.out.println(getName() + "...bb" + i); &#125; &#125; &#125;; t2.setDaemon(true); // 设置为守护线程 t1.start(); t2.start(); &#125;&#125; 2.4 加入线程Joinjoin方法的功能就是使异步执行的线程变成同步执行。也就是说，当调用线程实例的start方法后，这个方法会立即返回，如果在调用start方法后后需要使用一个由这个线程计算得到的值，就必须使用join方法。如果不使用join方法，就不能保证当执行到start方法后面的某条语句时，这个线程一定会执行完。而使用join方法后，直到这个线程退出，程序才会往下执行。下面的代码演示了join的用法。 2.5 礼让线程YieldThread.yield()方法作用是：暂停当前正在执行的线程对象，并执行其他线程。yield()应该做的是让当前运行线程回到可运行状态，以允许具有相同优先级的其他线程获得运行机会。因此，使用yield()的目的是让相同优先级的线程之间能适当的轮转执行。但是，实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。 结论：yield()从未导致线程转到等待/睡眠/阻塞状态。在大多数情况下，yield()将导致线程从运行状态转到可运行状态，但有可能没有效果。 2.6 设置线程优先级PrioritysetPriority不一定起作用的，在不同的操作系统不同的jvm上，效果也可能不同。现在很多jvm的线程的实现都使用的操作系统线程，设置优先级也是使用的操作系统优先级，java层面有10个优先级别，假设操作系统只有3个优先级别，那么jvm可能将1-4级映射到操作系统的1级，5-7级映射到操作系统的2级，剩下的映射到3级，这样的话，在java层面，将优先级设置为5,6,7，其实本质就是一样的了。 另外，操作系统也不能保证设置了优先级的线程就一定会先运行或得到更多的CPU时间。在实际使用中，不建议使用该方法 3 同步 当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步. 如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码. 3.1 同步代码块 使用synchronized关键字加上一个锁对象来定义一段代码, 这就叫同步代码块 多个同步代码块如果使用相同的锁对象, 那么他们就是同步的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ThreadDemo6 &#123; public static void main(String[] args) &#123; Print p = new Print(); new Thread()&#123; public void run() &#123; while (true) &#123; p.print1(); &#125; &#125; &#125;.start(); new Thread()&#123; public void run() &#123; while (true) &#123; p.print2(); &#125; &#125; &#125;.start(); &#125;&#125;class Print &#123; public void print1() &#123; synchronized (ThreadDemo6.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("鼎"); System.out.println("点"); System.out.println("视"); System.out.println("讯"); &#125; &#125; public void print2() &#123; synchronized (ThreadDemo6.class) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("T"); System.out.println("O"); System.out.println("P"); System.out.println("V"); System.out.println("I"); System.out.println("S"); System.out.println("I"); System.out.println("O"); System.out.println("N"); &#125; &#125;&#125; 3.2 同步方法 使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的 注意锁对象 1234567//同步方法，锁对象是thispublic synchronized void print1() &#123; System.out.println("鼎"); System.out.println("点"); System.out.println("视"); System.out.println("讯");&#125; 1234567//静态同步方法，锁对象是字节码文件public static synchronized void print1() &#123; System.out.println("鼎"); System.out.println("点"); System.out.println("视"); System.out.println("讯");&#125; 3.3 线程安全 多线程并发操作同一数据时, 就有可能出现线程安全问题 使用同步技术可以解决这种问题, 把操作数据的代码进行同步, 不要多个线程一起操作。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.topvision.thread;public class ThreadTicket1 &#123; public static void main(String[] args) &#123; /*new Ticket1().start(); new Ticket1().start(); new Ticket1().start(); new Ticket1().start();*/ Ticket2 t2 = new Ticket2(); new Thread(t2).start(); new Thread(t2).start(); new Thread(t2).start(); new Thread(t2).start(); &#125;&#125;class Ticket1 extends Thread &#123; private static int ticktets = 100; public void run() &#123; while (true) &#123; synchronized (Ticket1.class) &#123; if (ticktets &lt;= 0) &#123; break; &#125; System.out.println("这是第" + ticktets-- + "张票"); &#125; &#125; &#125;&#125;class Ticket2 implements Runnable &#123; private int ticktets = 100; @Override public void run() &#123; // TODO Auto-generated method stub while (true) &#123; synchronized (this) &#123; if (ticktets &lt;= 0) &#123; break; &#125; System.out.println("这是第" + ticktets-- + "张票"); &#125; &#125; &#125;&#125; 3.4 死锁两个线程各自拥有对方需要的锁对象，等待对方释放，因此互相等待，程序卡死。 多线程同步的时候, 如果同步代码嵌套, 使用相同锁, 就有可能出现死锁 尽量不要嵌套使用 1234567891011121314151617181920212223242526272829303132333435363738package com.topvision.thread;public class ThreadDemo8 &#123; /** * @param args */ private static String s1 = "筷子左"; private static String s2 = "筷子右"; public static void main(String[] args) &#123; new Thread() &#123; public void run() &#123; while (true) &#123; synchronized (s1) &#123; System.out.println(getName() + "...获取" + s1 + "等待" + s2); synchronized (s2) &#123; System.out.println(getName() + "...拿到" + s2 + "开吃"); &#125; &#125; &#125; &#125; &#125;.start(); new Thread() &#123; public void run() &#123; while (true) &#123; synchronized (s2) &#123; System.out.println(getName() + "...获取" + s2 + "等待" + s1); synchronized (s1) &#123; System.out.println(getName() + "...拿到" + s1 + "开吃"); &#125; &#125; &#125; &#125; &#125;.start(); &#125;&#125;]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用jquery.i18n完成前端国际化]]></title>
    <url>%2F%E4%BD%BF%E7%94%A8jquery-i18n%E5%AE%8C%E6%88%90%E5%89%8D%E7%AB%AF%E5%9B%BD%E9%99%85%E5%8C%96.html</url>
    <content type="text"><![CDATA[本文对 jQuery 国际化插件 jQuery.i18n.properties 进行了介绍，并用实际例子介绍了如何使用 jQuery.i18n.properties 插件实现 Web 前端的国际化。总结起来，jQuery.i18n.properties 具有轻量级（压缩后仅 4kb）、简单易用等特点，但是作为一个普及度不高的轻量级插件，不一定适用于大型的或对效率要求极高的场景。 1. 简介jQuery.i18n.properties 是一款轻量级的 jQuery 国际化插件。与 Java 里的资源文件类似，jQuery.i18n.properties 采用 .properties 文件对 JavaScript 进行国际化。jQuery.i18n.properties 插件根据用户指定的（或浏览器提供的 ）语言和国家编码（符合 ISO-639 和 ISO-3166 标准）来解析对应的以“.properties”为后缀的资源文件。 利用资源文件实现国际化是一种比较流行的方式，例如 Android 应用就可以采用以语言和国家编码命名的资源文件来实现国际化。jQuery.i18n.properties 插件中的资源文件以“.properties”为后缀，包含了区域相关的键值对。我们知道，Java 程序也可以使用以 .properties 为后缀的资源文件来实现国际化，因此，当我们要在 Java 程序和前端 JavaScript 程序中共享资源文件时，这种方式就显得特别有用。jQuery.i18n.properties 插件首先加载默认的资源文件（例如：strings.properties），然后加载针对特定语言环境的资源文件（例如：strings_zh.properties），这就保证了在未提供某种语言的翻译时，默认值始终有效。开发人员可以以 JavaScript 变量（或函数）或 Map 的方式使用资源文件中的 key。 总的来说，jQuery.i18n.properties 有一下一些特点： 使用 Java 标准的 .properties 文件作为资源文件，资源文件命名有以下三种格式： 123basename_properties basename_language.properties basename_language_country.properties 使用 ISO-639 作为语言编码标准，ISO-3166 作为国家名称编码标准 按顺序加载默认资源文件和指定语言环境的资源文件，保证默认值始终可用 未指定语言环境时使用浏览器提供的语言 可以在资源字符串中使用占位符（例如：hello= 你好 {0}! 今天是 {1}。） 资源文件中的 Key 支持命名空间（例如：com.company.msgs.hello = Hello!） 支持跨行的值 可以以 JavaScript 变量（或函数）或 Map 的方式使用资源文件中的 Key 2. APIjQuery.i18n.properties 的 API 非常简单，只有少数几个 API，即 jQuery.i18n.properties()、jQuery.i18n.prop()、jQuery.i18n.browserLang()。当然，和其他 jQuery 插件一样，我们也可以采用 $.i18n.properties()、$.i18n.prop() 和 $.i18n.browserLang() 的形式使用这用这些 API。 2.1 jQuery.i18n.properties(setting)该方法加载资源文件，其中 settings 是配置加载选项的一系列键值对，各配置项的具体描述如表 1 所示。 表 1. settings选项| 描述 | 类型 | 可选——-|———-name | 资源文件的名称，例如 strings 或 [strings1,strings2]，前者代表一个资源文件，后者代表资源文件数组。| String或String[] | 否path | 资源文件所在目录的路径 | String | 是mode | 加载模式：“vars”表示以JavaScript变量或函数的形式使用资源文件中的Key，“map”表示以 Map 的方式使用资源文件中的Key，“both”表示可以同时使用两种方式。如果资源文件中的 Key 包含 JavaScript 的关键字，则只能采用“map”。默认值是“vars”。 | String | 是language | ISO-639 指定的语言编码（如：“en”表示英文、“zh”表示中文），或同时使用ISO-639 指定的语言编码和ISO-3166指定的国家编码（如：“en_US”，“zh_CN”等）。如果不指定，则采用浏览器报告的语言编码。 | String | 是cache | 指定浏览器是否对资源文件进行缓存，默认为 false。 | boolean | 是encoding | 加载资源文件时使用的编码。默认为 UTF-8。 | String | 是callback | 代码执行完成时运行的回调函数 | function | 是 jQuery.i18n.properties() 的使用方法如清单 1 所示。 清单 1. jQuery.i18n.properties() 用法 12345678910jQuery.i18n.properties(&#123; name:'strings',// 资源文件名称 path:'bundle/',// 资源文件所在目录路径 mode:'both',// 模式：变量或 Map language:'pt_PT',// 对应的语言 cache:false, encoding: 'UTF-8', callback: function() &#123;// 回调方法 &#125; &#125;); 2.2 jQuery.i18n.prop(key)该方法以 map 的方式使用资源文件中的值，其中 key 指的是资源文件中的 key。当 key 指定的值含有占位符时，可以使用 jQuery.i18n.prop(key,var1,var2 … ) 的形式，其中 var1,var2 …对各占位符依次进行替换。例如资源文件中有“msg_hello= 您好 {0}，今天是 {1}。”的键值对，则我们可以采用“jQuery.i18n.prop( ‘ msg_hello ’ , ’小明’ , ’星期一’ );”的形式使用 msg_hello。 2.3 jQuery.i18n.browserLang()用于获取浏览浏览器的语言信息，这里不再单独介绍。 3. 示例3.1 建立资源文件如下图所示： 在 i18n 目录下创建 strings_en.properties 和，stirngs_zh.properties 两个资源文件，其中 strings_en.properties 对应英文翻译，如清单 2 所示；string_zh.properties 对应中文翻译，如清单 3 所示。 清单 2. stirngs_en.properties 12345678loginTitle = Login NM3000username = usernameusernameEnter = please enter usernamepassword = passwordpasswordEnter = please enter passwordautoLogin = AutoLoginlogin = Logincopyright = Topvision All Rights Reserved 清单3. strings_zh.properties 12345loginTitle = 登录NM3000username = 用户名password = 密码autoLogin = 自动登录login = 登录 3.2 引用插件和其他 jQuery 插件一样，jQuery.i18n.properties插件依赖jQuery，因此我们首先需要引用 jQuery。jQuery.i18n.properties 对 jQuery 的版本没有明确要求。我们使用清单 4 所示的方式在 index.html 中引用 jQuery 和 jQuery.i18n.properties 插件。 清单 4. 引用 jQuery.i18n.properties12&lt;script type="text/javascript" src="../../lib/jquery/jquery.min.js"&gt;&lt;/script&gt;&lt;script type="text/javascript" src="../../lib/jquery/jquery.i18n.properties-min-1.0.9.js"&gt;&lt;/script&gt; 3.3 使用12345678910111213$(function() &#123; lang = (jQuery.i18n.browserLang().substring(0, 2)); //默认从浏览器语言读取 jQuery.i18n.properties(&#123; name: 'strings', path: '../../i18n/', //资源文件路径 mode: 'map', //用Map的方式使用资源文件中的值 language: 'en', callback: function() &#123; //加载成功后设置显示内容 $('#title').html($.i18n.prop('loginTitle')); ... &#125; &#125;);&#125;) 4. 注意事项4.1 资源文件命名 var lang = jQuery.i18n.browserLang() 获取的语言是zh-CN、en-US格式， jQuery.i18n.properties 默认的资源文件命名方式为“zh_CN”、“en_US”的形式 设置插件语言的时候一定要和资源文件的语言代码一致，否则无法解析。 5. 总结本文对 jQuery 国际化插件 jQuery.i18n.properties 进行了介绍，并用实际例子介绍了如何使用 jQuery.i18n.properties 插件实现 Web 前端的国际化。总结起来，jQuery.i18n.properties 具有轻量级（压缩后仅 4kb）、简单易用等特点，但是作为一个普及度不高的轻量级插件，不一定适用于大型的或对效率要求极高的场景。]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>国际化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DCloud 离线打包之Android Studio]]></title>
    <url>%2FDCloud-%E7%A6%BB%E7%BA%BF%E6%89%93%E5%8C%85%E4%B9%8BAndroid-Studio.html</url>
    <content type="text"><![CDATA[DCloud 官方文档对于一个没有接触过Android开发的人来说相当的坑爹，以下是根据本人开发过程整理的Android Studio离线打包完整记录，对每一个步骤讲解非常详细，没有接触过AS也没有任何影响。 1. 预备环境 AndroidStudio开发环境,要求安装Android4.0或以上（API 14）SDK。安装方法自行百度。 下载HBuilder离线打包Android版SDK（5+ SDK下载）。 2. 5+ SDK目录说明 HBuilder-Hello：离线打包演示应用； HBuilder-Integrate: 5+ SDK 集成和插件开发示例； libs：SDK库文件目录； Feature列表.xls：Android平台各扩展Feature API对应的permission； 3. 搭建AS工程结构3.1 打开AS，创建一个空项目。 3.2 导入5+ SDK中的示例工程下面是AS工程的结构 3.3 将示例工程的main目录替换到app目录下的main 删除导入的module，即HBuilder-Hello。删除步骤： 点击AS左上角 File → Project Structure 弹出框中左下角选中要删除的Module,然后点击弹出框左上角的“-”删除，随后点击右下角OK键 在工程中选中要删除的Module,点击键盘Delete 4. 文件配置根据Feature-Android.xml添加项目包依赖 4.1 删除多余文件 删除app/src/main/assets 下的所有图片 清空app/src/mami/res 下所有目录，不要删除目录 清空app/src/main/jniLibs下所有目录，不要删除目录 删除app/src/main/java 下的目录，保留RInformation 删除app/src/main/iflytek 目录，若使用讯飞语音可保留 编辑apps.HelloH5.www目录为apps.XXX.www,XXX为自己的项目名,固定写法。删除www下所有文件。 4.2 添加基础jar包从Android-SDK@1.9.9.30983_20170414\Android-SDK\SDK\libs下拷贝jar包到工程libs包下。 android-support-v4.jar(运行环境包含了这个包，若运行时报错则将这个包删除) json_simple-1.1.jar 没有找到，但好像已经包含在其他几个包中 nineoldandroids-2.4.0.jar 在SDK中的名字叫my-nineoldandroids-2.4.0.jar pdr.jar my-imageloader.jar ui.jar nativeui.jar 在在Modules Dependencies中加入这些包，操作方法：选中包，点击鼠标右键。 4.3 修改AndroidManifest.xml删除现有文件中的application节点和所有的uses-permission根据Feature-Android.xml文档添加相应的activity和uses-permission,并修改文件头部的package为自己的包名,versionCode和versionName自定义修改。 4.4 添加资源文件严格对照Feature-Android.xml添加相关资源文件 4.5 将HBuilder中开发的项目全部复制到apps.XXX.www目录下5. 参数修改有4个文件需要注意： apps.XXX.www包下：manifest.json文件 MJ src/main包下：AndroidManifest.xml文件 AM src/main/assets/data包下：dcloud_control.xml文件 DC src/main/res/values包下：String.xml文件 STR 项目名 MJ id = apps.XXX.www中的XXX = DC appid 版本名称 MJ version.name = AM android:versionName = DC appver 版本Code MJ version.code = AM android:versionCode APP对外显示名称 MJ name = STR app_name 基座号码 DC version = 下载的5+ SDK目录上的一长串数字编号，如1.9.9.30983 6. APP图标和启动背景图标 AndroidManifest.xml文件的application节点下的android:icon=”@drawable/icon”设置了图标的名字为icon，可自行更改。将切好的图放置到src/main/res包下对应的drawable目录即可。 背景图 默认名为splash.png，切好图放置到对应的drawable目录中即可。 7. 签名文件Android Studio生成 打开Android Studio的build目录，进入Generate Signed APK子菜单! 点击新建，进入创建页，按提示填写! 填写完成自动返回上一菜单并自动填充相关参数 点击next即可生成 8. 查看签名文件SHA-1、MD5 打开cmd,进入签名文件目录 在控制台输入命令debug.keystore：命令为：keytool -list -v -keystore debug.keystore自定义的 keystore：命令为：keytool -list -v -keystore apk的keystore自定义的 jks：命令为：keytool -list -v -keystore apk的jks]]></content>
      <categories>
        <category>DCloud</category>
      </categories>
      <tags>
        <tag>MUI</tag>
        <tag>Android Studio</tag>
        <tag>离线打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mysql存储过程]]></title>
    <url>%2FMysql%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.html</url>
    <content type="text"><![CDATA[1. 存储过程1.1 简介&emsp;&emsp;普通的sql语句在执行的时候需要先编译再执行，而存储过程（Stored Procedure）是一组为了特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定的存储过程名称并给定参数（如果有的话）来调用执行它。&emsp;&emsp;存储过程是可编程的函数，在数据库中创建并保存，可以由SQL语句和控制结构组成。当想要在不同的应用程序或平台上执行相同的函数，或者封装特定功能时，存储过程是非常有用的。数据库中的存储过程可以看做是对编程中面向对象方法的模拟，它允许控制数据的访问方式。 1.2 优点 增强SQL语言的功能和灵活性：存储过程可以用流控制语句编写，有很强的灵活性，可以完成复杂的判断和较复杂的运算。 标准组件式编程：存储过程被创建后，可以在程序中被多次调用，而不必重新编写该存储过程的SQL语句。而且数据库专业人员可以随时对存储过程进行修改，对应用程序源代码毫无影响。 较快的执行速度：如果某一操作包含大量的Transaction-SQL代码或分别被多次执行，那么存储过程要比批处理的执行速度快很多。因为存储过程是预编译的。在首次运行一个存储过程时查询，优化器对其进行分析优化，并且给出最终被存储在系统表中的执行计划。而批处理的Transaction-SQL语句在每次运行时都要进行编译和优化，速度相对要慢一些。 减少网络流量：针对同一个数据库对象的操作（如查询、修改），如果这一操作所涉及的Transaction-SQL语句被组织程存储过程，那么当在客户计算机上调用该存储过程时，网络中传送的只是该调用语句，从而大大增加了网络流量并降低了网络负载。 安全机制：通过对执行某一存储过程的权限进行限制，能够实现对相应的数据的访问权限的限制，避免了非授权用户对数据的访问，保证了数据的安全。 1.3 存储过程创建1.3.1 语法CREATE PROCEDURE 过程名([[IN|OUT|INOUT] 参数名 数据类型[,[IN|OUT|INOUT] 参数名 数据类型…]]) [特性 …] 过程体 1234567DELIMITER // CREATE PROCEDURE myproc(OUT s int) BEGIN SELECT COUNT(*) INTO s FROM students; END //DELIMITER ; 1.3.2 分隔符&emsp;&emsp;MySQL默认以”;”为分隔符，如果没有声明分割符，则编译器会把存储过程当成SQL语句进行处理，因此编译过程会报错，所以要事先用“DELIMITER //”声明当前段分隔符，让编译器把两个”//“之间的内容当做存储过程的代码，不会执行这些代码；“DELIMITER ;”的意为把分隔符还原。 1.3.3 参数&emsp;&emsp;存储过程根据需要可能会有输入、输出、输入输出参数，如果有多个参数用”,”分割开。MySQL存储过程的参数用在存储过程的定义，共有三种参数类型,IN,OUT,INOUT: IN:参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回，为默认值. OUT:值可在存储过程内部被改变，并可返回. INOUT:调用时指定，并且可被改变和返回. 2.3.4 过程体&emsp;&emsp;过程体的开始与结束使用BEGIN与END进行标识。 1.4 变量1.4.1 声明变量&emsp;&emsp;DECLARE 变量名1[,变量名2…] 数据类型 [默认值]; 1.4.2 数值类型&emsp;&emsp;数据类型为MySQL的数据类型 数值类型! 日期和时间类型! 字符串类型! 1.4.3 变量赋值&emsp;&emsp;SET 变量名 = 变量值 [,变量名= 变量值 …] 1.4.4 用户变量&emsp;&emsp;用户变量一般以@开头。&emsp;&emsp;注意：滥用用户变量会导致程序难以理解及管理1234567SELECT 'Hello World' into @x;SELECT @x;SET @y='Goodbye Cruel World';SELECT @y;SET @z=1+2+3;SELECT @z; 执行结果: 在存储过程中使用用户变量 123CREATE PROCEDURE GreetWorld() SELECT CONCAT(@greeting,' World');SET @greeting='Hello';CALL GreetWorld(); 执行结果: ![此处输入图片的描述][7] 在存储过程间传递全局范围的用户变量 1234CREATE PROCEDURE p1() SET @last_proc='p1';CREATE PROCEDURE p2() SELECT CONCAT('Last procedure was ',@last_proc);CALL p1();CALL p2(); 执行结果: ![此处输入图片的描述][8] 1.4.5 变量作用域&emsp;&emsp;内部变量在其作用域范围内享有更高的优先权，当执行到end时，内部变量消失，不再可见了，在存储过程外再也找不到这个内部变量，但是可以通过out参数或者将其值指派给会话变量来保存其值。 123456789101112131415#变量作用域DELIMITER // CREATE PROCEDURE proc() BEGIN DECLARE x1 VARCHAR(5) DEFAULT 'outer'; BEGIN DECLARE x1 VARCHAR(5) DEFAULT 'inner'; SELECT x1; END; SELECT x1; END; //DELIMITER ;#调用CALL proc(); 执行结果：1inner outer 1.5 存储过程的CRUD1.5.1 调用&emsp;&emsp;用call和你过程名以及一个括号，括号里面根据需要，加入参数，参数包括输入参数、输出参数、输入输出参数。 1.5.2 查询1234567#查询存储过程SELECT name FROM mysql.proc WHERE db='数据库名';SELECT routine_name FROM information_schema.routines WHERE routine_schema='数据库名';SHOW PROCEDURE STATUS WHERE db='数据库名';#查看存储过程详细信息SHOW CREATE PROCEDURE 数据库.存储过程名; 1.5.3 修改&emsp;&emsp;ALTER PROCEDURE 更改用CREATE PROCEDURE 建立的预先指定的存储过程，其不会影响相关存储过程或存储功能。 1234ALTER &#123;PROCEDURE | FUNCTION&#125; sp_name [characteristic ...]characteristic:&#123; CONTAINS SQL | NO SQL | READS SQL DATA | MODIFIES SQL DATA &#125;| SQL SECURITY &#123; DEFINER | INVOKER &#125;| COMMENT 'string' sp_name参数表示存储过程或函数的名称； characteristic参数指定存储函数的特性。 CONTAINS SQL表示子程序包含SQL语句，但不包含读或写数据的语句； NO SQL表示子程序中不包含SQL语句； READS SQL DATA表示子程序中包含读数据的语句； MODIFIES SQL DATA表示子程序中包含写数据的语句。 SQL SECURITY { DEFINER | INVOKER }指明谁有权限来执行，DEFINER表示只有定义者自己才能够执行；INVOKER表示调用者可以执行。 COMMENT ‘string’是注释信息。 Example:12345678#将读写权限改为MODIFIES SQL DATA，并指明调用者可以执行。ALTER PROCEDURE num_from_employee MODIFIES SQL DATA SQL SECURITY INVOKER ;#将读写权限改为READS SQL DATA，并加上注释信息'FIND NAME'。ALTER PROCEDURE name_from_employee READS SQL DATA COMMENT 'FIND NAME' ; 1.5.4 删除&emsp;&emsp;DROP PROCEDURE [过程1[,过程2…]]&emsp;&emsp;从MySQL的表格中删除一个或多个存储过程。 1.6 控制语句1.6.1 条件语句123456789101112131415161718#条件语句IF-THEN-ELSEDROP PROCEDURE IF EXISTS proc3;DELIMITER //CREATE PROCEDURE proc3(IN parameter int) BEGIN DECLARE var int; SET var=parameter+1; IF var=0 THEN INSERT INTO t VALUES (17); END IF ; IF parameter=0 THEN UPDATE t SET s1=s1+1; ELSE UPDATE t SET s1=s1+2; END IF ; END ; //DELIMITER ; 1234567891011121314151617#CASE-WHEN-THEN-ELSE语句DELIMITER // CREATE PROCEDURE proc4 (IN parameter INT) BEGIN DECLARE var INT; SET var=parameter+1; CASE var WHEN 0 THEN INSERT INTO t VALUES (17); WHEN 1 THEN INSERT INTO t VALUES (18); ELSE INSERT INTO t VALUES (19); END CASE ; END ; //DELIMITER ; 1.6.2 循环语句12345678910111213#WHILE-DO…END-WHILE语句DELIMITER // CREATE PROCEDURE proc5() BEGIN DECLARE var INT; SET var=0; WHILE var&lt;6 DO INSERT INTO t VALUES (var); SET var=var+1; END WHILE ; END; //DELIMITER ; 123456789101112131415#REPEAT...END REPEAT#此语句的特点是执行操作后检查结果DELIMITER // CREATE PROCEDURE proc6 () BEGIN DECLARE v INT; SET v=0; REPEAT INSERT INTO t VALUES(v); SET v=v+1; UNTIL v&gt;=5 END REPEAT; END; //DELIMITER ; 12345678910111213141516#LOOP...END LOOPDELIMITER // CREATE PROCEDURE proc7 () BEGIN DECLARE v INT; SET v=0; LOOP_LABLE:LOOP INSERT INTO t VALUES(v); SET v=v+1; IF v &gt;=5 THEN LEAVE LOOP_LABLE; END IF; END LOOP; END; //DELIMITER ; LABLES标号&emsp;&emsp;标号可以用在begin repeat while 或者loop语句前，语句标号只能在合法的语句前面使用。可以跳出循环，使运行指令达到复合语句的最后一步。 1.6.3 迭代&emsp;&emsp;通过引用复合语句的标号,来从新开始复合语句 1234567891011121314151617181920#ITERATEDELIMITER // CREATE PROCEDURE proc8() BEGIN DECLARE v INT; SET v=0; LOOP_LABLE:LOOP IF v=3 THEN SET v=v+1; ITERATE LOOP_LABLE; END IF; INSERT INTO t VALUES(v); SET v=v+1; IF v&gt;=5 THEN LEAVE LOOP_LABLE; END IF; END LOOP; END; //DELIMITER ; 2. MySQL存储过程的基本函数2.1 字符串类123456789101112131415161718192021CHARSET(str) //返回字串字符集CONCAT (string2 [,... ]) //连接字串INSTR (string ,substring ) //返回substring首次在string中出现的位置,不存在返回0LCASE (string2 ) //转换成小写LEFT (string2 ,length ) //从string2中的左边起取length个字符LENGTH (string ) //string长度LOAD_FILE (file_name ) //从文件读取内容LOCATE (substring , string [,start_position ] ) 同INSTR,但可指定开始位置LPAD (string2 ,length ,pad ) //重复用pad加在string开头,直到字串长度为lengthLTRIM (string2 ) //去除前端空格REPEAT (string2 ,count ) //重复count次REPLACE (str ,search_str ,replace_str ) //在str中用replace_str替换search_strRPAD (string2 ,length ,pad) //在str后用pad补充,直到长度为lengthRTRIM (string2 ) //去除后端空格STRCMP (string1 ,string2 ) //逐字符比较两字串大小,SUBSTRING (str , position [,length ]) //从str的position开始,取length个字符,注：mysql中处理字符串时，默认第一个字符下标为1，即参数position必须大于等于1TRIM([[BOTH|LEADING|TRAILING] [padding] FROM]string2) //去除指定位置的指定字符UCASE (string2 ) //转换成大写RIGHT(string2,length) //取string2最后length个字符SPACE(count) //生成count个空格 2.2 数学类12345678910111213141516ABS (number2 ) //绝对值BIN (decimal_number ) //十进制转二进制CEILING (number2 ) //向上取整CONV(number2,from_base,to_base) //进制转换FLOOR (number2 ) //向下取整FORMAT (number,decimal_places ) //保留小数位数HEX (DecimalNumber ) //转十六进制注：HEX()中可传入字符串，则返回其ASC-11码，如HEX('DEF')返回4142143也可以传入十进制整数，返回其十六进制编码，如HEX(25)返回19LEAST (number , number2 [,..]) //求最小值MOD (numerator ,denominator ) //求余POWER (number ,power ) //求指数RAND([seed]) //随机数ROUND (number [,decimals ]) //四舍五入,decimals为小数位数]SIGN (number2 ) // 正数返回1，负数返回-1注：返回类型并非均为整数，如：SQRT(number2) //开平方 2.3 时间类12345678910111213141516171819202122232425262728293031ADDTIME (date2 ,time_interval ) //将time_interval加到date2CONVERT_TZ (datetime2 ,fromTZ ,toTZ ) //转换时区CURRENT_DATE ( ) //当前日期CURRENT_TIME ( ) //当前时间CURRENT_TIMESTAMP ( ) //当前时间戳DATE (datetime ) //返回datetime的日期部分DATE_ADD (date2 , INTERVAL d_value d_type ) //在date2中加上日期或时间DATE_FORMAT (datetime ,FormatCodes ) //使用formatcodes格式显示datetimeDATE_SUB (date2 , INTERVAL d_value d_type ) //在date2上减去一个时间DATEDIFF (date1 ,date2 ) //两个日期差DAY (date ) //返回日期的天DAYNAME (date ) //英文星期DAYOFWEEK (date ) //星期(1-7) ,1为星期天DAYOFYEAR (date ) //一年中的第几天EXTRACT (interval_name FROM date ) //从date中提取日期的指定部分MAKEDATE (year ,day ) //给出年及年中的第几天,生成日期串MAKETIME (hour ,minute ,second ) //生成时间串MONTHNAME (date ) //英文月份名NOW ( ) //当前时间SEC_TO_TIME (seconds ) //秒数转成时间STR_TO_DATE (string ,format ) //字串转成时间,以format格式显示TIMEDIFF (datetime1 ,datetime2 ) //两个时间差TIME_TO_SEC (time ) //时间转秒数]WEEK (date_time [,start_of_week ]) //第几周YEAR (datetime ) //年份DAYOFMONTH(datetime) //月的第几天HOUR(datetime) //小时LAST_DAY(date) //date的月的最后日期MICROSECOND(datetime) //微秒MONTH(datetime) //月MINUTE(datetime) //分返回符号,正负或0]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网站数据分析]]></title>
    <url>%2F%E7%BD%91%E7%AB%99%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[我们需要问自己几个问题：访问者来自哪里？ – 页面布局合理吗？访问者在寻找什么？ – 网站导航清晰吗？哪些页面最受欢迎？ – 哪些功能存在问题？访问者从哪里进入？ – 网站内容有效吗？访问者从哪里离开？ – 转化路径靠谱吗？ 对所有网站来说，页面都可以被划分为三个类别：导航页、功能页、内容页。导航页：引导访问者找到信息功能页：帮助访问者完成特定任务内容页：向访问者展示信息并帮助进行决策 有两种诡异行为：1、在导航页中途离开2、从内容页重新返回导航页面 没有规范的分析流程容易使最后的结果逻辑混乱或偏离原来的主题 数据获取方式1、网站日志文件有两个缺点。1、原始的日志文件记录了很多统计中用不到的内容，很难筛选内容；2、很多在页面的操作（点击，ajax）无法被记录。 2、Web Beacons在需要统计的网站页面嵌入一个1*1的透明图片，用户完全察觉不到。当用户访问网页的同时会请求透明图片，并完成页面访问记录工作。Web Beacons实现了日志记录服务器与网站应用服务器的分离。一般的网站页面，传统日志记录6-10条，用可控的图片嵌入方式大幅降低日志记录数。 3、JS页面标记嵌入的不再是图片，而是代码。当用户访问网页时同时执行JS代码，会将一些统计需要的信息以url参数的形式附带在图片请求地址的后面，然后再向日志服务器请求图片。这样，日志服务器就可以获得比较完整的访问数据。 cookie+session相同，是同一个用户在同义词访问过程中进行的操作。将相同的session的点根据发生时间的先后，和页面浏览关系的前后关系连成线。这样，将原先只有页面浏览的日志记录规划到相应的访问层面。底层的表可以从单纯记录页面浏览拆分为记录页面浏览和网站访问的两个表。 页面浏览表（PageView）：浏览时间、页面url、session、停留时长、第几步 访问表（Visit）：session、起始时间、结束时间、进入页面、离开页面、访问页面数、ip、cookie、referral]]></content>
      <categories>
        <category>Web</category>
      </categories>
      <tags>
        <tag>数据收集</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring(4)——持久层封装]]></title>
    <url>%2Fspring-4-%E2%80%94%E2%80%94%E6%8C%81%E4%B9%85%E5%B1%82%E5%B0%81%E8%A3%85.html</url>
    <content type="text"><![CDATA[这边博客介绍了持久层的集中封装方式。 1. 持久层访问方式 2. JDBC3. JDBCTemplete3.1 原始jdbcTemplete12345678DriverManagerDataSource dataSource = new DriverManagerDataSource();dataSource.setDriverClassName("com.mysql.jdbc.Driver");dataSource.setUrl("jdbc:mysql://localhost:3306/springdb");dataSource.setUsername("root");dataSource.setPassword("***********");JdbcTemplate template = new JdbcTemplate(dataSource);template.execute("insert into student values(1,'张三',23)"); 3.2 Spring开发jdbcTemplete 设置Bean 1234567891011121314&lt;bean id="dao" class="com.topvision.daotest.Dao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;&lt;/bean&gt;&lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource" /&gt;&lt;/bean&gt;&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdb" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="xiaoyue*AZ2V65" /&gt;&lt;/bean&gt; 编写dao层测试类 123456@Testpublic void Demo1() &#123; ClassPathXmlApplicationContext ctx = new ClassPathXmlApplicationContext("jdbcTemplete.xml"); JdbcTemplate jdbcTemplate = (JdbcTemplate) ctx.getBean("jdbcTemplate"); jdbcTemplate.execute("insert into student values(5,'23423',24)");&#125; 或者注解式 开启注解扫描 1&lt;context:component-scan base-package="com.topvision.daotest"/&gt; 去掉dao层的bean,即如下配置 123&lt;bean id="dao" class="com.topvision.daotest.Dao"&gt; &lt;property name="jdbcTemplate" ref="jdbcTemplate" /&gt;&lt;/bean&gt; 编写测试类 123456789101112131415 @RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:jdbcTemplete.xml")public class Dao &#123; @Autowired private JdbcTemplate jdbcTemplate; public void setJdbcTemplate(JdbcTemplate jdbcTemplate) &#123; this.jdbcTemplate = jdbcTemplate; &#125; @Test public void Demo2() &#123; jdbcTemplate.execute("insert into student values(8,'王五',25)"); &#125; &#125; 3. jdbcDaoSupportJdbcDaoSupport是JDBC数据访问对象的超类，其实它使用的还是jdbcTemplete，不过需要DI依赖注入dataSource或者jdbcTemplete. 3.1 xml方式 xml配置文件 123456789101112131415&lt;bean id="jdbcDaoSupportTest" class="com.topvision.daotest.JDBCDaoSupportTest"&gt; &lt;bean id="jdbcDaoSupportTest" class="com.topvision.daotest.JDBCDaoSupportTest"&gt; &lt;!-- 必须为继承JdbcDaoSupport的类注入JdbcTemplate，变量名为jdbcTemplate --&gt; &lt;!-- &lt;property name="jdbcTemplate" ref="jdbcTemplate"/&gt; --&gt; &lt;!-- 还可以注入DataSource对象，由JdbcDaoSupport自动创建JdbcTemplate对象 --&gt; &lt;property name="dataSource" ref="dataSource" /&gt; &lt;/bean&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdb" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="*****" /&gt; &lt;/bean&gt; 测试类 1234567891011121314 public class JDBCDaoSupportTest extends JdbcDaoSupport&#123; private static ClassPathXmlApplicationContext ctx; @Test public void Demo2() &#123; ctx = new ClassPathXmlApplicationContext("jdbcDaoSupport.xml"); JDBCDaoSupportTest bean = (JDBCDaoSupportTest) ctx.getBean("jdbcDaoSupportTest"); JdbcTemplate template = bean.getJdbcTemplate(); String sql = "select name from student where id = ?"; String name = template.queryForObject(sql, String.class,1); System.out.println(name); &#125;&#125; 3.2 注解方式 xml配置 1234567 &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdb" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="*****" /&gt;&lt;/bean&gt; 测试类123456789101112131415161718 public class JDBCDaoSupportTest extends JdbcDaoSupport&#123; @Autowired private DataSource dataSource; @PostConstruct private void init() &#123; setDataSource(dataSource); &#125; @Test public void Demo1() &#123; JdbcTemplate template = this.getJdbcTemplate(); String sql = "select name from student where id = ?"; String name = template.queryForObject(sql, String.class,1); System.out.println(name); &#125;&#125; 注入dataSource注意事项查看jdbcDaoSupport源码，可以注入dataSource或者注入jdbcTemplete注入方法有两种： 构造方法中注入： 1234@AutowiredUserVODaoImpl(DataSource dataSource) &#123; setDataSource(dataSource);&#125; 实例化前注入 1234567@Autowiredprivate DataSource dataSource;@PostConstructprivate void init() &#123; setDataSource(dataSource);&#125; 4. Hibernate5. Mybatis6. DataSource6.1 Spring内置DriverManagerDataSource 资源包 123456789101112131415 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; ``` 2. 配置项 ```xml &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdb"/&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="****" /&gt; &lt;/bean&gt; 6.2 DBCP 资源包 12345678910111213141516171819202122 &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.apache.commons.dbcp&lt;/artifactId&gt; &lt;version&gt;1.2.2.osgi&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.org.apache.commons.pool&lt;/artifactId&gt; &lt;version&gt;1.5.3&lt;/version&gt; &lt;/dependency&gt; ``` 4. 配置项 ```xml&lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/springdb" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="*****" /&gt;&lt;/bean&gt; 6.3 C3P0 资源包 1234567891011121314151617 &lt;dependency&gt; &lt;groupId&gt;com.mchange.c3p0&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.com.mchange.v2.c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt;&lt;/dependency&gt; ``` 6. 配置项 ```xml&lt;bean id="dataSource3" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc_username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt;&lt;/bean&gt; 6.4 外部properties输入参数 编写properties文件(jdbc.properties) 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/springdbjdbc_username=rootpassword=***** 在spring配置文件中扫描properties 方式一：可用*匹配加载多个 1&lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; 方式二：一个property对应一个文件 1234&lt;bean class="org.springframework.beans.factory.config.PropertyPlaceholdeConfigurer"&gt; &lt;property name="location" value="classpath:jdbc.properties" /&gt; &lt;property name="location" value="classpath:dsafgusd" /&gt;&lt;/bean&gt; 用&amp;{key}的方式引入 123456&lt;bean id="dataSource3" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="$&#123;driverClass&#125;" /&gt; &lt;property name="jdbcUrl" value="$&#123;url&#125;" /&gt; &lt;property name="user" value="$&#123;jdbc_username&#125;" /&gt; &lt;property name="password" value="$&#123;password&#125;" /&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring(3)——AOP浅析]]></title>
    <url>%2Fspring-3%E2%80%94%E2%80%94AOP%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[这篇博客简要介绍了Spring AOP的执行过程及实现。 1. AOP简介AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 使用”横切”技术，AOP把软件系统分为两个部分：核心关注点和横切关注点。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。 2. AOP核心概念 连接点(Joinpoint):被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 切入点(Pointcut):要被增强的方法，定义了切入发生的地点 通知(advice):要执行的增强方法，定义了切入的时机和执行的动作 切面(Aspect):切入点和通知的对应关系，也就是两者结合的称呼 目标对象(Target Object):包含切入点的运行时对象，也就是被代理的对象 AOP代理(aop proxy):代理对象 织入(Weaving):是一个将通知功能加入原始字节码的动态过程，共有三种方法，Spring使用的是运行时织入。 3. AOP运行环境 Spring核心包（4个） 日志包（两个） AOP包（4个） Spring进行AOP开发(1个)spring-aop-4.2.5.RELEASE.jar Spring整合AspectJ框架spring-aspects-4.2.5.RELEASE.jar AOP联盟规范(1个)com.springsource.org.aopalliance-1.0.0.jar aspectJ支持(1个)com.springsource.org.aspectj.weaver-1.7.2.RELEASE.jar 4. XML实现4.1 在配置文件中开启AOP空间4.2 编写连接点类，即需要增强的业务类业务类可以有上层接口(JDK代理)，也可以没有(cglib代理) 业务类接口 123public interface ImSleep &#123; public void sleep();&#125; 业务类实现 1234567public class HumanSleep implements ImSleep&#123; @Override public void sleep() &#123; System.out.println("我要睡觉了"); &#125; &#125; 4.3 编写通知类，即增强方法所在的类123456public class TimeHandler &#123; //通知方法 public void printTime() &#123; System.out.println("CurrentTime=" + System.currentTimeMillis()); &#125;&#125; 4.4 在xml中配置切面，即关联切入点和通知12345678910111213&lt;bean id="humanSleep" class="com.topvision.ssm.domian.HumanSleep"/&gt;&lt;bean id="timeHandler" class="com.topvision.ssm.domian.TimeHandler"/&gt; &lt;aop:config&gt; //配置切面，ref关联通知类 &lt;aop:aspect id="time" ref="timeHandler"&gt; //切入点，匹配要切入的业务类 &lt;aop:pointcut expression="execution(*com.topvision.ssm.domian.HumanSleep.sleep())" id="addTime"/&gt; //通知类型，执行通知类中的那个方法，关联的切入点 &lt;aop:before method="printTime" pointcut-ref="addTime"/&gt; &lt;aop:after method="printTime" pointcut-ref="addTime"/&gt; &lt;/aop:aspect&gt;&lt;/aop:config&gt; 4.5 测试类123ApplicationContext ctx = new ClassPathXmlApplicationContext("applicationContext.xml");ImSleep human = (ImSleep) ctx.getBean("humanSleep");human.sleep(); 5. 注解实现5.1 开启aop注解核心配置文件中添加以下配置，功能等同于注解配置Bean的自动扫描路径1234//开启bean扫描&lt;context:component-scan base-package="com.topvision.ssm.*"/&gt; //开启aop注解扫描&lt;aop:aspectj-autoproxy/&gt; 5.2 配置业务类123456789101112131415161718192021@Componentpublic class Bussiness &#123; /** * 切入点 */ public String delete(String obj) &#123; System.out.println("==========调用切入点：" + obj + "说：你敢删除我！===========\n"); return obj + "：瞄～"; &#125; public String add(String obj) &#123; System.out.println("================这个方法不能被切。。。============== \n"); return obj + "：瞄～ 嘿嘿！"; &#125; public String modify(String obj) &#123; System.out.println("=================这个也设置加入切吧====================\n"); return obj + "：瞄改瞄啊！"; &#125;&#125; 5.3 配置通知类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 定义切面 * * @Aspect : 标记为切面类 * @Pointcut : 指定匹配切点 * @Before : 指定前置通知，value中指定切入点匹配 * @AfterReturning ：后置通知，具有可以指定返回值 * @AfterThrowing ：异常通知 * * @author yanbin * */@Component@Aspectpublic class AspectAdvice &#123; /** * 指定切入点匹配表达式，注意它是以方法的形式进行声明的。 */ @Pointcut("execution(* com.topvision.*..*.*(..))") public void anyMethod() &#123; &#125; /** * 前置通知 * * @param jp */ @Before(value = "execution(* com.topvision.ssm.domian.Bussiness.delete(..))") public void doBefore(JoinPoint jp) &#123; System.out.println("===========进入before advice============ \n"); System.out.print("准备在" + jp.getTarget().getClass() + "对象上用"); System.out.print(jp.getSignature().getName() + "方法进行对 '"); System.out.print(jp.getArgs()[0] + "'进行删除！\n\n"); System.out.println("要进入切入点方法了 \n"); &#125; /** * 后置通知 * * @param jp * 连接点 * @param result * 返回值 */ @AfterReturning(value = "anyMethod()", returning = "result") public void doAfter(JoinPoint jp, String result) &#123; System.out.println("==========进入after advice=========== \n"); System.out.println("切入点方法执行完了 \n"); System.out.print(jp.getArgs()[0] + "在"); System.out.print(jp.getTarget().getClass() + "对象上被"); System.out.print(jp.getSignature().getName() + "方法删除了"); System.out.print("只留下：" + result + "\n\n"); &#125; /** * 环绕通知 * * @param pjp * 连接点 */ @Around(value = "anyMethod()") public void doAround(ProceedingJoinPoint pjp) throws Throwable &#123; System.out.println("===========进入around环绕方法！=========== \n"); // 调用目标方法之前执行的动作 System.out.println("调用方法之前: 执行！\n"); // 调用方法的参数 Object[] args = pjp.getArgs(); // 调用的方法名 String method = pjp.getSignature().getName(); // 获取目标对象 Object target = pjp.getTarget(); // 执行完方法的返回值：调用proceed()方法，就会触发切入点方法执行 Object result = pjp.proceed(); System.out.println("输出：" + args[0] + ";" + method + ";" + target + ";" + result + "\n"); System.out.println("调用方法结束：之后执行！\n"); &#125; /** * 异常通知 * * @param jp * @param e */ @AfterThrowing(value = "anyMethod())", throwing = "e") public void doThrow(JoinPoint jp, Throwable e) &#123; System.out.println("删除出错啦"); &#125;&#125; 5.4 测试类（集成junit）123456789101112@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations="classpath:applicationContext.xml")public class Test01&#123; @Autowired private Bussiness bs; @Test public void BSTest() &#123; bs.delete("qwe"); &#125;&#125; 6. 切入点表达式及通知6.1 切入点表达式格式：execution(切入点表达式)execution([方法的访问控制修饰符] 方法的返回值 包名.类名/接口名.方法名(参数))注意：方法的访问控制修饰符可以省略12com.topvision.*.dao.UserDAO.add() com包下的topvision包下的任意包下的dao包下的... *..*.*() 任意包下的任意类中的任意方法 方法参数 add() 无参数 add(*) 一个参数 add(int) 一个int型参数 add(,) 两个参数 add(*,int) 两个参数，第一个任意，第二个int add(..) 任意参数 add(*,..) 至少一个参数 6.2 通知类型 类型before:在原始操作前运行after: 在原始操作后运行，无论方法是否抛出异常afterReturning:在原始操作后运行，只有方法正常结束才运行，抛出异常则不运行afterThrowing:在原始操作中如果抛出异常，运行around: 在原始操作前后运行，通过ProceedingJoinPoint对象调用procee()方法完成对原始操作的调用 格式 12345&lt;aop:before pointcut-ref="pt2" method="before"/&gt; &lt;aop:after pointcut-ref="pt2" method="after"/&gt; &lt;aop:after-returning pointcut-ref="pt2" method="afterReturning"/&gt; &lt;aop:after-throwing pointcut-ref="pt2" method="afterThrowing"/&gt; &lt;aop:around pointcut-ref="pt2" method="around"/&gt; 6.3 获取通知参数为环绕通知之外的通知方法定义形参JoinPoint，该参数必须是通知方法的第一个参数。获取参数：Obejct[] args = jp.getArgs();范例： 1234public void before(JoinPoint jp)&#123; Object[] objs = jp.getArgs(); System.out.println("before......"+objs[0]+","+objs[1]);&#125; 为环绕通知方法定义形参ProceedingJoinPoint对象获取参数：Obejct[] args = pjp.getArgs(); 6.4 获取通知返回值afterReturning 与 around可以获取方法的返回值 around通知获取返回值ProceedingJoinPoint对象执行调用原始操作的返回值就是原始方法的运行返回值。 1Object res = pt.proceed(args); 注意：如果原始方法返回值为void类型，则around方法返回值设置为Object。如果原始方法返回值为非void类型，则around方法内必须将原始方法调用的结果返回。原始方法返回值为void类型的，通知内获取的返回值统一为null。 1234public Object around(ProceedingJoinPoint pjp) throws Throwable&#123; Object res = pjp.proceed(args); return res;&#125; afterReturning通知获取返回值在通知方法的参数中，声明一个Object类型的参数，用于保存方法的返回值 123public void afterReturning(JoinPoint jp,Object abc)&#123; System.out.println("afterReturning......"+ abc);&#125; 在配置文件中，为afterReturning声明保存返回值的变量名 6.5 获取异常值异常对象的获取方式与返回值很相似，声明变量，在配置中声明保存异常对象的变量名。1&lt;aop:after-throwing pointcut-ref="pt" method="afterThrowing" throwing="e"/&gt; 123public void afterThrowing (Throwable e)&#123; System.out.println("afterThrowing......."+ e);&#125; 7. JDK代理与cglib代理]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring(2)——IOC浅析]]></title>
    <url>%2Fspring-2%E2%80%94%E2%80%94IOC%E6%B5%85%E6%9E%90.html</url>
    <content type="text"><![CDATA[这篇博客简单分析了IOC和DI的原理及区别，并介绍了基于xml和注解的Bean配置方式。 1. 什么是IOC?1.1 IoC(Inversion of Control)控制反转 控制:控制的双方是什么？谁控制谁？ 主控方：Spring 被控方：应用程序所使用的资源 (原始)应用程序控制自己执行操作需要使用的外部资源 (Spring)Spring控制整个程序中所需要使用的外部资源 反转:什么是反转？反转什么？ 正向：应用程序直接调用资源 反向：应用程序依赖Spring为其提供资源 反转的是资源的控制权 应用程序由主动调用资源，变为被动的等待Spring提供资源 有什么好处？ 正向缺点：应用程序控制的资源分布在程序的每一个地方 反向的优点：所有的资源都在Spring中，便于管理 总结：Spring反向控制应用程序所需要使用的外部资源。资源受Spring管理，利用率最大化。 1.2 spring演进模式A.基于分层设计 UserAction 使用UserService,new UserService() UserService 使用UserDAO,new UserDAO() UserDAO B.工厂模式，使用面向接口编程设计，解决层与层之间的紧耦合 制作接口，制作实现类，制作对象工厂 123A a = AFactory.createA(); B b = BFactory.createB(); a.setB(b); C.工厂模式+配置 制作XML文件，将实现类配置到XML文件中 读取XML文件中的配置信息，得到实现类的类名 使用反射思想，获取实现类对象 class.newInstance(); 123A a = Factory.create(“a”); B b = Factory.create(“b”); a.setB(b); 123&lt;!--配置xml--&gt;a=AImpl b=BImpl D.自动的工厂+配置 12//返回装配好的a A a = Factory.create(“a”); 12345&lt;!--xml配置--&gt;&lt;bean id=“a” class=“AImpl”&gt; &lt;property name=“b” ref=“b”/&gt; &lt;/bean&gt; &lt;bean id=“b” class=“BImpl”/&gt; E.工厂由Spring提供，实现类使用XML格式配置 工厂由Spring提供，实现类使用XML格式配置 12//返回装配好的a A a = ApplicationContext.getBean(“a”); 12345&lt;!--xml配置--&gt;&lt;bean id=“a” class=“AImpl”&gt; &lt;property name=“b” ref=“b”/&gt; &lt;/bean&gt; &lt;bean id=“b” class=“BImpl”/&gt; 2. 什么是DI？2.1 DI的概念DI(Dependency Injection)依赖注入，指应用程序依赖Spring为其提供运行时所需的资源. 谁依赖于谁？ ——- 应用程序依赖于IoC容器 为什么需要依赖？ ——- 应用程序依赖于IoC容器装配类之间的关系 依赖什么东西？ ——- 依赖了IoC容器的装配功能 谁注入于谁？ ——- IoC容器注入应用程序 注入什么东西？ ——- 注入应用程序需要的资源（类之间的关系） 更能描述容器其特点的名字——“依赖注入”（Dependency Injection）IoC容器应该具有依赖注入功能，因此也可以叫DI容器 2.2 DI实现方式 构造器注入 setter注入 接口注入 3. IOC和DI的关系？IOC和DI其实是同一概念的两种说法，两者站立的角度不一样。IOC：从spring的角度看，资源的控制权限被反转了DI：从应用程序的角度看，应用程序要依赖spring为其注入资源。 4. BeanFactory BeanFactory是ApplicationContext的顶层父接口，使用BeanFactory接口也可以完成获取Bean的操作. 操作步骤:123456//初始化Resource对象Resource res = new ClassPathResource("applicationContext.xml");//初始化BeanFactory对象BeanFactory bf = new XmlBeanFactory(res);//根据id名称获取BeanUserService service = (UserService) bf.getBean("userService"); AppplicationContext与BeanFactory的区别A. 加载方式不同 AppplicationContext：立即加载，加载配置文件时即加载 BeanFactory:延迟加载，获取Bean实例时才加载 B. AppplicationContext具有更多的功能 国际化处理 事件传递 Bean自动装配 各种不同应用层的Context实现 注意：实际开发中，优先选择ApplicationContext对象，避免使用BeanFactory Schema风格离线约束配置方式 A.拷贝访问路径 B.打开MyEclipse设置中的XML catalog选项 C.创建新的映射 D.选择对应的schema风格的约束文件 E.将key type修改为schema location F.将要配置的路径复制到key中 5. Bean配置（XML）5.1 Bean初始化 构造器初始化（重点）Bean对应的类必须提供一个默认无参可访问的构造方法 静态工厂初始化 123456&lt;bean id="userService2" &lt;!--配置中所配置的class配置成工厂类的类名--&gt; class="com.topvision.bean.UserStataicFactory" &lt;!--配置工厂类中的创建实例的静态方法--&gt; factory-method="getInst"&gt;&lt;/bean&gt; 实例工厂初始化提供一个实例工厂类，使用其中的实例方法获取对象。由于该工厂类本身需要创建对象，因此该对象必须受Spring控制，所以必须配置该工厂类为Bean. 123456&lt;!—实例化工厂Bean --&gt;&lt;bean id="uf" class="com.topvision.bean.UserFactory"&gt;&lt;/bean&gt;&lt;!--使用实例工厂创建Bean --&gt;&lt;!--factory-bean: 配置实例工厂在Spring范围内对应的Bean的id名称--&gt;&lt;!--factory-method：配置工厂类中的创建实例的实例方法--&gt;&lt;bean id="userService3" factory-bean="uf" factory-method="getInst2"&gt;&lt;/bean&gt; 5.2 Bean的作用域Spring初始化的Bean默认为单例模式，如果想修改成非单例模式需要修改Bean的作用范围。1&lt;bean id=”beanId” class=”BeanClassName” scope=”prototype”&gt;&lt;/bean&gt; scope属性： singleton：单例 prototype：非单例 request：请求对象范围request.setAttribute(&quot;beanId&quot;,obj); session：会话Session范围request.getSession().setAttribute(&quot;beanId&quot;,obj); globalSession：全局会话,分布式服务器 5.3 Bean的生命周期定义Bean初始化与销毁时的动作，属于回调方法配置定义bean时指定两个回调方法，控制bean的初始化与销毁操作时执行的动作 init-method：初始化回调方法名，配置的方法必须由bean对象提供 destroy-method：销毁回调方法名，配置的方法必须由bean对象提供 1&lt;bean id="user" class="com.topvision.lifecycle.User" init-method="init" destroy-method="destroy" scope="prototype"&gt;&lt;/bean&gt; 销毁操作只针对scope=”singletion”的对象，对于非单例对象无效 单例对象的销毁是在IoC容器关闭时发生，使用ClassPathXmlApplicationContext对象close方法完成 非单例Bean对象的内存回收交由JVM完成——GC 5.4 Bean属性注入 构造器注入（了解）A.在domain中提供对象的构造方法B.xml配置中设置构造方法的参数 123456&lt;!-- constructor-arg:使用构造器传递参数 --&gt;&lt;!-- value:赋值 --&gt;&lt;bean id="bean6" class="com.topvision.bean.xml.Bean6"&gt; &lt;constructor-arg value="topvision"/&gt; &lt;constructor-arg value="2017"/&gt;&lt;/bean&gt; 注意：如果类型匹配不成功，可以为配置中指定index索引属性，对应构造器中参数的位置. 1234&lt;bean id="bean6" class="com.topvision.bean.xml.Bean6"&gt; &lt;constructor-arg index="0" value="2014" type="java.lang.Integer"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg index="1" value="topvision" type="java.lang.String"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 说明：构造器传参受构造器参数位置和类型的限定，因此不常使用 setter注入前提：setter注入要求Bean必须提供无参可访问构造方法 A.注入简单类型 1.提供对应要注入的属性 2.为每个要注入的属性提供对应的标准封装setter方法 3.在配置中为Bean指定要注入的属性，使用property元素 name=“属性名” value=”值” 1&lt;property name="属性名" value="值"/&gt; B.注入引用类型 1.为某个Bean注入引用类型的值，首先在Bean对应的类中声明对应的属性 12345678 private TeacherDAO dao; ``` 2.为每个要注入的属性提供对应的标准封装setter方法 (访问器) ```xml public void setDao(TeacherDAO dao) &#123; this.dao = dao;&#125; 3.必须保障引入的对象是Spring控制的Bean 12&lt;!-- 声明引用类型的资源为Bean --&gt;&lt;bean id="teacherDao" class="com.topvision.di.setter.TeacherDAO"&gt; &lt;/bean&gt; 4.在Bean的属性注入中，使用ref引用对应的资源 ref=”beanId/beanName” 123456789 &lt;!-- setter注入 --&gt;&lt;!-- name:属性名 --&gt;&lt;!-- value:简单类型的值 --&gt;&lt;!-- ref:引用别的Bean，beanId/beanName --&gt;&lt;bean id="bean7" class="com.topvision.bean.xml.Bean7"&gt; &lt;property name="name" value="topvision"/&gt; &lt;property name="age" value="8"/&gt; &lt;property name="dao" ref="teacherDao"&gt;&lt;/property&gt;&lt;/bean&gt; 6. Bean配置（注解）从Spring2.5开始提供使用注解的形式配置Bean。 6.1 配置Bean使用@Component注解如需为Bean定义名称，在参数中添加Bean名称@Component(“beanName”) 6.2 设定Spring的自动扫描路径用于检测对应的Bean是否配置了注解，并加载配置了注解的类 开启context空间的支持 12345678&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; 开启自动扫描功能，并指定扫描的路径 1&lt;context:component-scan base-package="com.topvision.annotation"&gt;&lt;/context:component-scan&gt; 说明：扫描路径可以设置多个，中间使用,隔开，扫描路径包含指定包和子包内所有的类,通常使用*号通配符匹配路径 6.3 Spring提供的三个注解 @Repository 用于数据层实现类标注 @Service 用于业务逻辑层实现类标注 @Controller 用于控制层实现类进行标注 6.4 注入简单类型 在属性名上方声明该属性自动装配@Autowired 在属性名上方声明该属性注入的值@Value(value)123@Autowired@Value("topvision")private String msg; 注意：注解自动装配属性值无需提供对应属性的setter方法 6.5 注入引用类型 在属性名上方声明该属性自动装配@Autowired 在属性名上方声明该属性注入的值@Qualifier(bean引用名称)123@Autowired@Qualifier("anno2")private AnnotationOther other; 6.6 AutowiredAutowired的required属性用用于声明自动装配的数据是必须的。 如果required=true，必须为其装配数据，如果没有值，抛出异常 如果required=false，自动装配数据失败，则注入值为null 6.7 Resource 格式一：@Resource(name=”myImpl”) 格式二：@Autowired(required=false) @Qualifier(“myImpl”)以上两种格式效果相同 6.8 Bean声明周期注解 @PostConstruct功能：为当前Bean指定init-method参数格式：定义在成员方法的上方，兼容静态方法 @PreDestroy功能：为当前Bean指定destory-method参数格式：定义在成员方法的上方，兼容静态方法注意：要求当前类被注册为Bean，否则无效果 6.9 Bean作用域注解在类的定义上方添加@Scope指定Bean的作用域常用：@Scope(“prototype”)默认：@Scope(“singleton”) 6.10 配置类注解@Configuration配置当前类为配置类，用于加载其中配置的Bean，与静态工厂初始化Bean很相似@Bean(name=”b1”)将配置类中的某个方法的返回值声明为Bean，该方法必须返回一个对象1234567@Configuration //设定该类参与自动扫描public class MyBeanFactory &#123; @Bean(name=&#123;"aa","bb","cc"&#125;)//设定该方法的返回值是一个Bean public static BookService getInst()&#123; return new BookService(); &#125;&#125; 以上操作必须基于自动扫描功能，如不开启自动扫描，Spring将无法查找到对应的注解配置 6.11 AnnotationConfigApplicationContext不使用自动扫描AnnotationConfigApplicationContext对象可以手工加载基于注解配置的Bean123456//用于手工添加注解开发Bean的上下文对象AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();//加载配置管理类ctx.register(MyConfiguration.class);//刷新上下文对象ctx.refresh(); 注意：注册完成后一定要进行刷新，否则加载的Bean将无法被使用 博客链接 源码解读Spring IOC原理 Spring源代码解析]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>IOC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring(1)——框架简介]]></title>
    <url>%2Fspring-1%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B.html</url>
    <content type="text"><![CDATA[这篇博客介绍了spring框架的组成及应用 1.什么是spring框架？spring是一个轻量级的JAVA开发框架，由Rod Johnson创建。spring对应用对象（如javaBean）的生命周期进行管理，它是一个“粘合平台”，将很多技术粘合在一起，形成一个整体，使每个组件发挥最大功效。 2.架构概述 核心容器 spring-bean是整个核心，Bean的定义、Bean 的创建以及对Bean的解析。 spring-context是bean关系集合，也就是IOC容器 spring-core发现、维护和管理变之间的关系 spring-expression是EL遍地是语言的扩展，支持设置和获取对象属性，调用对象方法，操作数组、集合等。 面向切面编程（AOP）和工具（Instruementation） Spring AOP模块提供了满足AOP Alliance规范的实现，还整合了AspectJ这种AOP语言级的框架。通过AOP能降低耦合。 消息 spring-messaging模块为集成messaging api和消息协议提供支持。 数据访问集成 事务模块：该模块用于Spring管理事务，只要是Spring管理对象都能得到Spring管理事务的好处，无需在代码中进行事务控制了，而且支持编程和声明性的事务管理。 JDBC模块：提供了一个JBDC的样例模板，使用这些模板能消除传统冗长的JDBC编码还有必须的事务控制，而且能享受到Spring管理事务的好处。 ORM模块：提供与流行的“对象-关系”映射框架的无缝集成，包括hibernate、JPA、MyBatis等。而且可以使用Spring事务管理，无需额外控制事务。 OXM模块：提供了一个对Object/XML映射实现，将Java对象映射成XML数据，或者将XML数据映射成java对象，Object/XML映射实现包括JAXB、Castor、XMLBeans和XStream。 JMS模块：用于JMS(Java Messaging Service)，提供一套 “消息生产者、消息消费者”模板用于更加简单的使用JMS，JMS用于用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。 web集成 该模块建立在AoolicationContext模块之上，提供了Web应用的功能。如文件上传、FreeMarker等。 Spring可以整合Struts2等MVC框架。Spring自己提供了MVC框架Spring MVC。 Test Spring可以用非容器依赖的编程方式进行几乎所有的测试工作，支持JUnit和TestNG等测试框架。 3.资源包整理spring资源下载链接 核心 spring-beans-4.2.5.RELEASE.jar spring-context-4.2.5.RELEASE.jar spring-context-support-4.2.5.RELEASE.jar spring-core-4.2.5.RELEASE.jar spring-expression-4.2.5.RELEASE.jar AOP spring-aop-4.2.5.RELEASE.jar spring-aspects-4.2.5.RELEASE.jar spring-instrument-4.2.5.RELEASE.jar spring-instrument-tomcat-4.2.5.RELEASE.jar spring-messaging-4.2.5.RELEASE.jar WEB spring-web-4.2.5.RELEASE.jar spring-websocket-4.2.5.RELEASE.jar spring-webmvc-4.2.5.RELEASE.jar spring-webmvc-portlet-4.2.5.RELEASE.jar DATA spring-jdbc-4.2.5.RELEASE.jar spring-jms-4.2.5.RELEASE.jar spring-orm-4.2.5.RELEASE.jar spring-oxm-4.2.5.RELEASE.jar spring-tx-4.2.5.RELEASE.jar TEST spring-test-4.2.5.RELEASE.jar LOG commons-logging-1.1.1.jar commons-logging log4j-1.2.15.jar]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SNMP学习总结(2)——snmp安装和配置]]></title>
    <url>%2FSNMP%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(2)%E2%80%94%E2%80%94snmp%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE.html</url>
    <content type="text"><![CDATA[这篇博客简要介绍了snmp的安装 针对不同的操作系统有不同的操作流程，具体参见孤傲苍狼的博客。]]></content>
      <categories>
        <category>SNMP</category>
      </categories>
      <tags>
        <tag>snmp</tag>
        <tag>network</tag>
        <tag>snmp4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SNMP学习总结(3)——SNMP4J]]></title>
    <url>%2FSNMP%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(3)%E2%80%94%E2%80%94snmp4j.html</url>
    <content type="text"><![CDATA[这篇博客简要介绍了snmp4j协议栈的基本使用 1 snmp4j简介 SNMP4J是一个用Java来实现SNMP(简单网络管理协议)协议的开源项目.它支持以命令行的形式进行管理与响应。SNMP4J是纯面向对象设计与SNMP++(用C++实现SNMPv1/v2c/v3)相类似。 SNMP4J API 提供以下下特性： - 支持MD5和SHA验证，DES，3DES,AES128、AES192和AES256加密的SNMPv3。 - 支持MPv1,MPv2C和MPv3，带执行的可阻塞的信息处理模块。 - 全部PDU格式。 - 可阻塞的传输拓扑。支持UPD、TCP、TLS 。 - 可阻塞的超时模块。 - 同步和异步请求。 - 命令发生器以及命令应答器的支持。 - 基于Apache license的开源免费。 - JAVA 1.4.1或更高版本(2.0或更高版本需要jdk1.6及以上的支持)。 - 基于LOG4J记录日志。 - 使用GETBULK实现Row-based的有效的异步表格获取。 - 支持多线程。 2 snmp4j重要的类及接口介绍Snmp4j包中最重要的三个概念，也是三个类：Snmp、Target、PDU 2.1 Target类2.1.1 共有方法 Target表示被管理的设备。对于被管理的设备，我们关注它的Address,它所使用的的协议版本Version，访问它的用户名和密码，以及人为设置的跟他打交道的策略，比如超时时间、重传次数等。所以有如下方法： 设置或获取IP地址 12void setAddress（Address address） Address getAddress（） 设置或获取协议版本 12void setVersion(int ver)int getVersion() 超时时间（单位：milliseconds） 12void setTimeout(long out）long getTimeout() 重传次数 12void setRetries(int retries)int getRetries() PUD最大值 12void setMaxSizeRequestPDU(int max)int getMaxSizeRequestPDU() 上面的方法对于snmp三个版本都是相同的，不同的在于安全方面。具体来说，Snmpv1，v2c采用共同体（community）方式，安全性很差；SnmpV3采用基于用户的安全（USM）方式，安全性能得到很大提高。 2.1.2 communityTarget对于Snmpv1，v2c，使用Target派生出一个子类CommunityTarget，增加了对Community的方法：12void setMaxSizeRequestPDU(int max)int getMaxSizeRequestPDU() 2.1.3 UserTarget对于SnmpV3，使用其子类UserTarget，增加了一些有关USM安全方面的设置，比如采用的安全模型、安全级别、访问该设备的用户名以及权威引擎ID（authoritative engine ID）： 安全级别（支持三种安全级别） 12void setSecurityLevel(int level)int getSecurityLevel() 访问用户名（该访问用户名称必须在设置USM的时候添加其相应的UsmUser） 12void setSecurityName(OctetString name)OctetString getSecurityName() 安全模型（支持三种安全模型） 12void setSecurityModel(int model)int getSecurityModel() 权威引擎ID（authoritative engine ID） 12void setAuthoritativeEngineID(byte[] id)byte[] getAuthoritativeEngineID（） 2.2 PDU类 PDU（协议数据单元），用来表示管理站跟代理站点进行通信的数据。包括PDU的类型、传输的数据集合、错误说明等。 该类是SNMP报文单元的抽象，其中PDU类适用于SNMPv1和SNMPv2c。ScopedPDU类继承于PDU类，适用于SNMPv3。 Snmp4j针对Snmp的各个版本，开发了三个有关PDU的类。PDU（针对Snmpv2c）、PDUv1（针对Snmpv1）、ScopedPDU（针对Snmpv3），但三个类除各自特别的一些参数外，都基本相同。所以Snmp4j在设计的时候，将PDU设计成另外两个的超类，使他们能够共享大部分功能。 2.3 Snmp类 snmp类是SNMP4J的核心，它提供了发送和接收SNMP PDUs的方法，所有的SNMP PDU 类型都可以采用同步或者异步的方式被发送。 Snmp采用独立的传输协议，通过TransportMapping接口调用addTransportMapping(TransportMapping transportMapping)方法或者采用默认的构造函数来实现传输映射，以此来实现信息的传输。]]></content>
      <categories>
        <category>SNMP</category>
      </categories>
      <tags>
        <tag>snmp</tag>
        <tag>network</tag>
        <tag>snmp4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SNMP学习总结(1)——基本概念]]></title>
    <url>%2FSNMP%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93(1)%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html</url>
    <content type="text"><![CDATA[这篇博客简要介绍了snmp协议的基本概念 1 SNMP简单概述1.1 什么是SNMP? SNMP是英文”Simple Network Management Protocol”的缩写，中文意思是“简单的网络管理协议”。它属于TCP/IP五层协议中的应用层协议，用于网络管理的协议。SNMP主要用于网络设备的管理。由于SNMP协议简单可靠 ，受到了众多厂商的欢迎，成为了目前最为广泛的网管协议。 SNMP协议主要由两大部分组成：SNMP管理站和SNMP代理。SNMP管理站是一个中心节点，负责收集维护各个SNMP元素的信息，并对这些信息进行处理，最后反馈给网络管理员；而SNMP代理是运行在各个被管理的网络节点之上，负责统计该节点的各项信息，并且负责与SNMP管理站交互，接收并执行管理站的命令，上传各种本地的网络信息。 SNMP管理站和SNMP代理之间是松散耦合。他们之间的通信是通过UDP协议完成的。一般情况下，SNMP管理站通过UDP协议向SNMP代理发送各种命令，当SNMP代理收到命令后，返回SNMP管理站需要的参数。但是当SNMP代理检测到网络元素异常的时候，也可以主动向SNMP管理站发送消息，通告当前异常状况。 SNMP的基本思想：为不同种类的设备、不同厂家生产的设备、不同型号的设备，定义为一个统一的接口和协议，使得管理员可以是使用统一的外观面对这些需要管理的网络设备进行管理。通过网络，管理员可以管理位于不同物理空间的设备，从而大大提高网络管理的效率，简化网络管理员的工作。 SNMP的工作方式：管理员需要向设备获取数据，所以SNMP提供了【读】操作；管理员需要向设备执行设置操作，所以SNMP提供了【写】操作；设备需要在重要状况改变的时候，向管理员通报事件的发生，所以SNMP提供了【Trap】操作。 1.2 SNMP和UDPSNMP采用UDP协议在管理端和agent之间传输信息。 SNMP采用UDP161端口接收和发送请求，162端口接收trap，执行SNMP的设备缺省都必须采用这些端口。SNMP消息全部通过UDP端口161接收，只有Trap信息采用UDP端口162。 1.3 Snmp版本SNMP目前共有v1，v2，v3这三个版本： SNMP v1是SNMP协议的最初版本，不过依然是众多厂家实现SNMP基本方式。 SNMP v2通常被指是基于community的SNMP V2。Community实质上就是密码。 SNMP v3 是最新版本的SNMP。它对网络管理最大的贡献在于其安全性。增加了对认证和密文传输的支持。 2 SNMP工作原理 在具体的实现上，SNMP为管理员提供了一个网管平台（NMS），又称为管理站，负责网管命令的发出、数据存储及数据分析。被监管的设备上运行一个SNMP代理（Agent），代理实现设备与管理站的SNMP通信。 管理站和代理端使用MIB进行接口统一，MIB定义了设备中的被管理对象。管理站和代理都实现相应的MIB对象，使得双方可以识别对方的数据，实现通信。管理站向代理请求MIB中定义的数据，代理端识别后，将管理设备提供的相关状态或参数等数据转换成MIB定义的格式，最后将该信息返回给管理站，完成一次管理操作。 3 SNMP报文3.1 报文类型 SNMP中定义了五种消息类型：Get-Request、Get-Response、Get-Next-Request、Set-Request和Trap。 Get-Request 、Get-Next-Request与Get-ResponseSNMP 管理站用Get-Request消息从拥有SNMP代理的网络设备中检索信息，而SNMP代理则用Get-Response消息响应。Get-Next- Request用于和Get-Request组合起来查询特定的表对象中的列元素。 Set-Request SNMP管理站用Set-Request 可以对网络设备进行远程配置（包括设备名、设备属性、删除设备或使某一个设备属性有效/无效等）。 Trap SNMP代理使用Trap向SNMP管理站发送非请求消息，一般用于描述某一事件的发生，如接口UP/DOWN，IP地址更改等。 上面五种消息中Get-Request、Get-Next-Request和Set-Request是由管理站发送到代理侧的161端口的；后面两种Get-Response和Trap 是由代理进程发给管理进程的，其中Trap消息被发送到管理进程的162端口，所有数据都是走UDP封装。SNMP工作流程如图2： 3.2 报文格式SNMP代理和管理站通过SNMP协议中的标准消息进行通信，每个消息都是一个单独的数据报。SNMP使用UDP（用户数据报协议）作为第四层协议（传输协议），进行无连接操作。SNMP消息报文包含两个部分：SNMP报头和协议数据单元PDU。 以下部分是报文格式的具体分析，有需要可以继续学习。 在实际网络传输环境下，SNMP报文的长度取决于其所采用的编码方式。SNMP统一采用BER(Basic Encoding Rule)的编码规则，同时在正式SNMP规范中使用的是ASN.1语法，Abastract Syntax Notation v1，即抽象语法描述语言。这两个概念在后面实践环节再做进一步介绍，这里只要稍微了解一下即可，不妨碍我们对协议本身的分析。这里我们简单解释一下BER编码规则： BER作为ANS.1的基本编码规则，描述具体的ANS.1对象如何编码为比特流在网络上进行传输。BER编码规则由三部分组成： SNMP中定义了几种基本的数据类型，其中v1和v2版有些改动，具体参见相应的RFC文档。这里我们只介绍几种最常见的类型： INTEGER：一个整数 OCTER STRING： 0或多个8bit字节，每个字节在0~255之间取值 DisplayString：0或多个8bit字节，每个字节必须是ASCII码。在MIB-II中，所有该类型变量不能超过255个字符(0个字符可以) NULL：代表相关的变量没有值 IpAddress：4字节长的OCTER STRING，以网络字节序表示IP地址 PhyAddress：6字节长的OCTER STRING，代表物理地址 Counter：非负整数，可以从0递增到232-1()。达到最大值后归0 TimeTicks：时间计数器，以0.01秒为单位递增，不同的变量可以有不同的递增幅度。所以在定义这种类型的变量时需要制定递增幅度 SEQUENCE：与C语言中的结构体类似 SEQUENCE OF：一个向量，参见后面ANS.1语法详细介绍章节 SNMP报文在传输层是封装在UDP报文中的，而UDP又是基于IP网络的，因此，我们可以得到完整的报文描述结构，如下图所示：PDU类型其实包含两个字节，第一个字节表示真实的PDU的类型；第二个字节表示后面报文所占的字节总数。针对SNMPv1，这个字段取值如下：| PDU类型 | 名 称 || :——–: | :—–: || 0 | get-request || 1 | get-next-request || 2 | get-response || 3 | set-request || 4 | trap | 也就是说，trap的类型是4。但是在数据报文中，该字段一般表示为ax，其中x取[0,4]，即a0~a3表示相应的get、set等操作，a4表示trap报文。这里除了类型字段意外，其他字段均采用BER编码方式： 实战演练之报文格式分析 Trap报文格式和上述图5所展示的结构有些差别，这里我们只分析SNMPv1和SNMPv2的Trap报文格式。trap报文前面的部分都一样，区别在PDU协议数据单元部分。 SNMPv1 Trap报文SNMPv1的Trap报文格式如下所示：注意：除了PDU类型和PDU长度字段外，后面的每个字段都是BER编码方式。 trap类型”可以取以下值，其中0~6是已定义的特定trap，7及其以后的类型由供应商自定义。表2 trap类型、名称及描述信息| trap类型 | 名称 | 描述信息 || :——–: | :—–: | :—-: || ０ | coldStart | 代理进程对自己初始化 || １ | warmStart | 代理进程对自己重新初始化 || ２ | linkDown | 一个接口已从工作状态变为故障状态(报文中的第一个变量标识此接口) || ３ | linkUp | 一个接口已从故障状态变为工作状态(报文中的第一个变量标识此接口) || ４ | authenticationFailure | 从SNMP管理进程收到无效共同体的报文 || ５ | egpNeighborLoss | 一个EGP邻站已变为故障状态(报文中的第一个变量包含邻站IP地址) || ６ | enterpriseSpecific | 在这个特定的代码段中查找trap信息 | 通过wireshark抓包工具，捕获一条如下的SNMP报文，接下来对其进行仔细分析。SNMPv1原始报文内容： 00 23 5a 9e 58 b9 00 4c 41 49 50 55 08 005 45 00 00 48 00 00 40 00 40 11 a5 4e c0 a8 0a 01 c0 a8 0a 05 0c 00 00 a2 00 34 ff e0 30 2a 02 01 00 04 06 70 75 62 6c 69 63 a4 1d 06 0a 2b 06 01 04 01 bf 08 03 02 0a 40 04 c0 a8 0a 01 02 01 00 02 01 00 43 01 0e 30 00 目的MAC：00 23 5a 9e 58 b9源MAC：00 4c 41 49 50 55协议类型：08 005 ，为IP数据报IP头：45 00 00 48 00 00 40 00 40 11 a5 4e c0 a8 0a 01 c0 a8 0a 05UDP头：0c 00 00 a2 00 34 ff e0其余部分都为SNMP报文，接下来我们对照前面的报文结构体来逐个分析一下。 30 表示SNMP消息是ASN.1的SEQUENCE类型； 2a 表示该SNMP报文的总长度是42(0x2a)个字节，该字段所表示的报文长度起始于它后面的第一个字节直到报文结束； 02 01 00 表示版本号，可见其确实为BER编码方式。02表示该字段是INTEGER类型；01表示该字段占1个字节；00表示版本号，该值为“版本号-1”； 04 06 70 75 62 6c 69 63 表示团体名，04表示该字段为OCTET STRING类型；06表示该字段占6个字节；70 75 62 6c 69 63 表示团体名的ANSII码的十六进制形式，这里是“public”； a4 1d 其中a4中的“4”表示这是一个trap报文，a4又叫报文的标签标记；1d表示后面还有29(0x1d)个字节的数据； 06 0a 2b 06 01 04 01 bf 08 03 02 0a 企业OID标识。06表示该字段是个对象标识符，OBJECT IDENTIFIER；0a表示该字段占10(0x0a)个字节；关于SNMP的OID的编码方式有些奇特：例如1.3.6.1.2…. 取前两个数字分别记为x和y。编码时40x+y，这里x=1，y=3，因此结果为401+3=43，即表示十六进制的2b。因此，这里的企业OID编码即为1.3.6.1.4.1.8072.3.2.10； 40 04 c0 a8 0a 01 同样40表示该字段为OCTET STRING 类型；04表示IP地址占4个字节；IP地址为192.168.10.1； 02 01 00 其中00表示trap类型为coldStart； 02 01 00 其中00表示我们指定的trap即specific-trap也为coldStart类型； 43 01 0e 43表示为TimeTicks类型；01表示该字段占1个字节；0e即十进制的14表示时间标签为0.14秒，这里时间计数器以0.01秒递增； 30 00 30表示“键-值”值对的编码类型为SEQUENCE；00表示该字段占0个字节，即没有该字段。 SNMPv2 Trap报文SNMPv2的Trap报文格式如图8所示：同样的，这里除了trap类型和报文长度是标准网络字节序之外，其余协议字段也均为BER编码方式。可以看到v2版的trap报文正在向统一的报文格式发展，已经非常类似普通的SNMP请求、响应报文了。SNMPv2原始报文内容：00 23 5a 9e 58 b9 00 4c 41 49 50 55 08 00 45 00 00 7b 00 00 40 00 40 11 a5 1b c0 a8 0a 01 c0 a8 0a 05 0c 01 00 a2 00 67 04 bb 30 5d 02 01 01 04 06 70 75 62 6c 69 63 a7 50 02 04 17 73 2c fb 02 01 00 02 01 00 30 42 30 0d 06 08 2b 06 01 02 01 01 03 00 43 01 0e 30 17 06 0a 2b 06 01 06 03 01 01 04 01 00 06 09 2b 06 01 06 03 01 01 05 01 30 18 06 0a 2b 06 01 06 03 01 01 04 03 00 06 0a 2b 06 01 04 01 bf 08 03 02 0a 目的MAC：00 23 5a 9e 58 b9源MAC：00 4c 41 49 50 55协议类型：08 00，IP报文IP头：45 00 00 7b 00 00 40 00 40 11 a5 1b c0 a8 0a 01 c0 a8 0a 05UDP头：0c 01 00 a2 00 67 04 bb余下部分全为SNMP报文内容，这里我们做一下简单的约定：xx 标注类型；xx 标注长度；xx 标注真正的数据。这样一来上面这串原始数据就好分析多了 30 5d 整个SNMP报文的编码方式为30，即SEQUENCE类型，报文长度93(0x5d)字节； 02 01 01 版本号01即v2版本； 04 06 70 75 62 6c 69 63 团体名70 75 62 6c 69 63 即英文的“public”； a7 50 a7表示trap类型为7，即厂商自定义trap；50表示PDU区段占80(0x50)字节； 02 04 17 73 2c fb 请求ID为17 73 2c fb 十进制的393424123； 02 01 00 错误状态0； 02 01 00 错误索引0； 30 42 “变量名-值”对编码类型30 即SEQUENCE类型；“变量名-值”所占总字节0x42，即66字节； 30 0d 06 08 2b 06 01 02 01 01 03 00 43 01 0e 第一个“名-值”对区段编码方式30 即SEQUENCE类型；第一个“名-值”对总长度0x0d，13字节；第一个变量名的编码类型0x06，时间标签；第一个变量名占0x08个字节；第一个变量名2b 06 01 02 01 01 03 00，为1.3.6.1.2.1.1.3.0；第一个变量值为0x0e，即14； 30 17 06 0a 2b 06 01 06 03 01 01 04 01 00 06 09 2b 06 01 06 03 01 01 05 01 第二个“名-值”对；变量名1.3.6.1.6.3.1.1.4.1.0；变量值1.3.6.1.6.3.1.1.5.1； 30 18 06 0a 2b 06 01 06 03 01 01 04 03 00 06 0a 2b 06 01 04 01 bf 08 03 02 0a 第三个“名-值”对；变量名1.3.6.1.6.3.1.1.4.3.0；变量值1.3.6.1.4.1.8072.3.2.10； 今天我们简单对SNMP协议做个入门普及，包括它的原理，应用场景报文格式等。下面的章节，我们将以开源net-snmp为例来向大家阐述多种代理开发流程和原理，以及要注意的问题，其中每种扩展mib的方式都对应不同的开发需求。]]></content>
      <categories>
        <category>SNMP</category>
      </categories>
      <tags>
        <tag>snmp</tag>
        <tag>network</tag>
        <tag>snmp4j</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5+常用功能]]></title>
    <url>%2Fhtml5-%E5%B8%B8%E7%94%A8%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[这篇博文介绍了html5+在webApp开发中经常使用的功能模块 获取wifi信息 获取wifi的IP 123456789101112131415function getOnuIp() &#123; if(mui.os.android) &#123; var Context = plus.android.importClass("android.content.Context"); var WifiManager = plus.android.importClass("android.net.wifi.WifiManager"); var WifiInfo = plus.android.importClass("android.net.wifi.WifiInfo"); var wifiManager = plus.android.runtimeMainActivity().getSystemService(Context.WIFI_SERVICE); var wifiInfo = wifiManager.getConnectionInfo(); var ipAddress = wifiInfo.getIpAddress(); if(ipAddress == 0) return "未连接wifi"; return((ipAddress &amp; 0xff) + "." + (ipAddress &gt;&gt; 8 &amp; 0xff) + "." + (ipAddress &gt;&gt; 16 &amp; 0xff) + "." + (ipAddress &gt;&gt; 24 &amp; 0xff)); &#125; else if(mui.os.ios) &#123; mui.toast("ios暂未获"); &#125;&#125; 获取wifi的网关 123456789101112131415161718192021function getOnuIp() &#123; if(mui.os.android) &#123; var Context = plus.android.importClass("android.content.Context"); var WifiManager = plus.android.importClass("android.net.wifi.WifiManager"); var WifiInfo = plus.android.importClass("android.net.wifi.WifiInfo"); var DhcpInfo=plus.android.importClass("android.net.DhcpInfo"); var wifiManager = plus.android.runtimeMainActivity().getSystemService(Context.WIFI_SERVICE); var dhcpInfo = wifiManager.getDhcpInfo() var begin=dhcpInfo.toString().indexOf("gateway"); var end=dhcpInfo.toString().indexOf("netmask"); var ipAddress = dhcpInfo.toString().substring(begin+7,end).trim(); if(ipAddress == 0) return "未连接wifi"; return ipAddress;// return((ipAddress &amp; 0xff) + "." + (ipAddress &gt;&gt; 8 &amp; 0xff) + "." + (ipAddress &gt;&gt; 16 &amp; 0xff) + "." + (ipAddress &gt;&gt; 24 &amp; 0xff)); &#125; else if(mui.os.ios) &#123; var WifiManager = plus.ios.importClass("WifiManager"); var wifiManager = new WifiManager(); var gateWay = wifiManager.defaultGateWay(); return gateWay; &#125;&#125; 软键盘 强制打开全键盘 1234567891011121314151617181920212223242526272829303132333435363738394041424344//弹出软键盘，搜索框获得焦点var nativeWebview, imm, InputMethodManager;var initNativeObjects = function() &#123; if(mui.os.android) &#123; var main = plus.android.runtimeMainActivity(); var Context = plus.android.importClass("android.content.Context"); InputMethodManager = plus.android.importClass("android.view.inputmethod.InputMethodManager"); imm = main.getSystemService(Context.INPUT_METHOD_SERVICE); &#125; else &#123; nativeWebview = plus.webview.currentWebview().nativeInstanceObject(); &#125;&#125;;var showSoftInput = function() &#123; if(mui.os.android) &#123; imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED); &#125; else &#123; nativeWebview.plusCallMethod(&#123; "setKeyboardDisplayRequiresUserAction": false &#125;); &#125; setTimeout(function() &#123; //此处可写具体逻辑设置获取焦点的input var inputElem = document.querySelector('input'); inputElem.focus(); &#125;, 200);&#125;;var showSoftInput2 = function() &#123; var nativeWebview = plus.webview.currentWebview().nativeInstanceObject(); if(mui.os.android) &#123; //强制当前webview获得焦点 plus.android.importClass(nativeWebview); nativeWebview.requestFocus(); imm.toggleSoftInput(0, InputMethodManager.SHOW_FORCED); &#125; else &#123; nativeWebview.plusCallMethod(&#123; "setKeyboardDisplayRequiresUserAction": false &#125;); &#125; setTimeout(function() &#123; //此处可写具体逻辑设置获取焦点的input var inputElem = document.querySelector('input'); inputElem.select(); &#125;, 200);&#125;; 关闭软键盘 1document.activeElement.blur(); //隐藏软键盘 两次点击退出123456789101112131415//首页返回键处理 //处理逻辑：2秒内，连续两次按返回键，则退出应用 //首次按键，提示‘再按一次退出应用’ if(!first) &#123; first = new Date().getTime(); mui.toast('再按一次退出应用'); setTimeout(function() &#123; first = null; &#125;, 2000); return false;&#125; else &#123; if(new Date().getTime() - first &lt; 2000) &#123; plus.runtime.quit(); &#125;&#125; 注销关闭其他窗口12345678910111213141516171819202122232425262728/*监听注销按钮*/document.getElementById("logoutBtn").addEventListener("tap", function() &#123; var btnArray = ['是', '否']; mui.confirm('您确定退出?', '', btnArray, function(e) &#123; if(e.index == 0) &#123; // 获取所有Webview窗口 var launchWebview = plus.webview.getLaunchWebview(); var curr = plus.webview.currentWebview(); var wvs = plus.webview.all(); for(var i = 0, len = wvs.length; i &lt; len; i++) &#123; //关闭除setting页面和首页外的其他页面 if(wvs[i].getURL() == curr.getURL() || wvs[i].getURL() == launchWebview.getURL()) continue; plus.webview.close(wvs[i]); &#125; //清除已存储的账号信息 myStorage.removeItem('ONU.token.username'); myStorage.removeItem('ONU.token.password'); myStorage.removeItem('ONU.token.autoLogin'); myStorage.removeItem('isLogin'); //注销静默登录的定时器 //clearInterval('backLoading()'); //打开login页面后再关闭setting页面 launchWebview.show(); curr.close(); &#125; &#125;)&#125;);]]></content>
      <categories>
        <category>DCloud</category>
      </categories>
      <tags>
        <tag>html5+</tag>
        <tag>native.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于MUI及Html5+开发app]]></title>
    <url>%2F%E5%9F%BA%E4%BA%8EMUI%E5%8F%8AHtml5-%E5%BC%80%E5%8F%91app.html</url>
    <content type="text"><![CDATA[这边博客简要介绍了使用MUI和5+开发APP的流程 MUI简介MUI官网&amp;nbsp&amp;nbspMUI是最接近原生APP体验的高性能前端框架，不依赖任何第三方JS库，以iOS平台UI为基础，补充部分Android平台特有的UI控件。 工具 HBilder 5+ SDK Android Studio + Android SDK html5+简介HTML5+规范 开发步骤1.在Hbuilder中创建移动app项目 2.在manifest.json文件中按照提示配置app相关信息，包括权限选择，这个地方和下面将要提到的androidManifest.xml文件是相互独立的 3.新建View文件夹编写html，新建js、css文件夹放置对应文件 4.若使用5+相关的东西,如下操作： - 在5+ SDK中，对应Feature-Android.xls文件，使用哪个模块，就在xls文件中找到对应模块 - 将文件中提到的相关文件从5+ SDK中的HBuilder-Integrate工程中找到，并移入android工程中 5.参照[5+ API](http://www.html5plus.org/doc/h5p.html),编写相关代码 调试调试可使用真机调试和模拟调试，建议真机调试，涉及到5+的代码只能在真机上运行。]]></content>
      <categories>
        <category>DCloud</category>
      </categories>
      <tags>
        <tag>MUI</tag>
        <tag>html5+</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+github搭建个人博客]]></title>
    <url>%2Fhexo%2Bgithub%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[1.前言使用github pages服务搭建博客的好处有：1.全是静态文件，访问速度快；2.免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3.可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；4.数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5.博客内容可以轻松打包、转移、发布到其它平台；6.等等； 1.1准备工作 创建github账号 github注册地址 安装node.js、npm node.js下载地址 安装git for windows git下载地址 本文所使用的环境 windows7 git@1.9.5 node.js@6.10.2 hexo@3.7 2.搭建github博客2.1创建仓库登陆github,打开新建页面，如图新建仓库名必须为你的用户名.github.io,假如说你的用户名是test,那仓库名为test.github.io,将来的博客访问地址就是http://test.github.io 了，是不是很方便？由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。 几个注意的地方： 1.注册的邮箱一定要验证，否则不会成功；2.仓库名字必须是：username.github.io，其中username是你的用户名；3.仓库创建成功不会立即生效，需要过一段时间，大概10-30分钟，或者更久 ###2.2绑定域名 这一步不是必须，若不绑定则可用默认的http://xxx.github.io来访问，若想自己拥有一个域名，则需要注册，[关联域名][7]。 3.配置SSH key为什么要配置这个呢？因为你提交代码肯定要拥有你的github权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。在电脑任意位置进入git bash 1234567$ cd ~/.ssh #检查本机已存在的ssh密钥``` 如果提示：No such file or directory 说明你是第一次使用git```clissh-keygen -t rsa -C &quot;邮件地址&quot; 然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，文本编辑器打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：将刚复制的内容粘贴到key那里，title随便填，保存。 测试是否设置成功 1$ ssh -T git@github.com # 注意邮箱地址不用改 如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到： Hi xiaoyue! You’ve successfully authenticated, but GitHub does not provide shell access. 看到这个信息说明SSH已配置成功！ 测试Coding的连接： 1$ ssh -T git@git.coding.net # 注意邮箱地址不用改 此时你还需要配置： 12$ git config --global user.name &quot;kevinXiao2016&quot;// 你的github用户名，非昵称$ git config --global user.email &quot;xxx@qq.com&quot;// 填写你的github注册邮箱 4.使用hexo写博客4.1hexo简介Hexo是一个简单、快速、强大的基于 Github Pages 的博客发布工具，支持Markdown格式，有众多优秀插件和主题。 官网： http://hexo.iogithub: https://github.com/hexojs/hexo ###4.2原理由于github pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，假如每次写完一篇文章都要手动更新博文目录和相关链接信息，相信谁都会疯掉，所以hexo所做的就是将这些md文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到github。 注意事项 很多命令既可以用Windows的cmd来完成，也可以使用git bash来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用git bash来执行； hexo不同版本差别比较大，网上很多文章的配置信息都是基于2.x的，所以注意不要被误导； hexo有2种_config.yml文件，一个是根目录下的全局的_config.yml，一个是各个theme下的； 安装hexo 1$ npm install -g hexo npm更换淘宝镜像，提升下载速度 123临时使用：npm config set registry https://registry.npm.taobao.org永久使用：npm config set registry https://registry.npm.taobao.org验证：npm config get registry 初始化 在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。 12$ cd /f/Workspaces/hexo/$ hexo init hexo会自动下载一些文件到这个目录，包括node_modules。继续执行下面两条命令 12$ hexo g # 生成$ hexo s # 启动服务 执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。 hexo s是开启本地预览服务，打开浏览器访问 http://localhost:4000 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章： http://blog.liuxianan.com/windows-port-bind.html 第一次初始化的时候hexo已经帮我们写了一篇名为 Hello World 的文章，默认的主题比较丑。 5.配置主题5.1更换主题既然默认主题很丑，那我们别的不做，首先来替换一个好看点的主题。这是 官方主题。个人比较喜欢的主题：hexo-theme-next 和hexo-theme-yilia以next主题为例，首先clone这个主题： 进入之前建立的hexo目录，在git bash中执行clone命令 $ git clone https://github.com/iissnan/hexo-theme-next.git themes/next 下载的主题到了hexo&gt;theme文件夹下。修改##hexo##根目录下的_config.yml文件中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成静态文件，hexo s部署到本地，localhost:4000预览博客效果。 如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>Blog</tag>
      </tags>
  </entry>
</search>
